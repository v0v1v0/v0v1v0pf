<div class="container">

<table style="width: 100%;"><tr>
<td>SchmidLeiman</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Schmid-Leiman Orthogonalization to a (Rank-Deficient) Bifactor Structure</h2>

<h3>Description</h3>

<p>The Schmid-Leiman (SL) procedure orthogonalizes a higher-order factor 
structure into a rank-deficient bifactor structure. The Schmid-Leiman method 
is a generalization of Thomson's orthogonalization routine.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SchmidLeiman(
  R,
  numFactors,
  facMethod = "fals",
  rotate = "oblimin",
  rescaleH2 = 0.98,
  faControl = NULL,
  rotateControl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>(Matrix) A correlation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numFactors</code></td>
<td>
<p>(Vector) The number of latent factors at each level of 
analysis. For example, c(3, 1) estimates three latent factors in the first-order 
common factor model and one latent factor in the second-order common factor 
model (i.e., 3 group factors and 1 general factor). This function can 
orthogonalize up to (and including) a three-order factor solution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>facMethod</code></td>
<td>
<p>(Character) The method used for factor extraction 
(<code>faX</code>). The supported options are "fals" for unweighted least 
squares, "faml" for maximum likelihood, "fapa" for iterated principal axis 
factoring, "faregLS" for regularized least squares,
"faregML" for regularized maximum likelihood, and "pca" for principal components 
analysis. The default method  is "fals". 
</p>

<ul>
<li> <p><strong>"fals"</strong>: Factors are extracted using the unweighted least 
squares estimation procedure using the <code>fals</code> function.
</p>
</li>
<li> <p><strong>"faml"</strong>: Factors are extracted using the maximum likelihood 
estimation procedure using the <code>factanal</code> function.
</p>
</li>
<li> <p><strong>"fapa"</strong>: Factors are extracted using the iterated principal 
axis factoring estimation procedure using the <code>fapa</code> function.
</p>
</li>
<li> <p><strong>"faregLS"</strong>: Factors are extracted using regularized 
least squares factor analysis using the <code>fareg</code> function. 
</p>
</li>
<li> <p><strong>"faregML"</strong>: Factors are extracted using regularized 
maximum likelihood factor using the <code>fareg</code> function. 
</p>
</li>
<li> <p><strong>"pca"</strong>: Principal components are extracted. 
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotate</code></td>
<td>
<p>(Character) Designate which rotation algorithm to apply. See 
the <code>faMain</code> function for more details about possible rotations. 
Defaults to rotate = "oblimin".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rescaleH2</code></td>
<td>
<p>(Numeric) If a Heywood case is detected at any level of the 
higher-order factor analyses, rescale the communality value to continue with 
the matrix algebra. When a Heywood case occurs, the uniquenesses (i.e., 
specific-factor variances) will be negative and the SL orthogonalization of 
the group factors is no longer correct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>faControl</code></td>
<td>
<p>(List) A list of optional parameters passed to the factor 
extraction (<code>faX</code>) function.
</p>

<ul>
<li> <p><strong>treatHeywood</strong>: (Logical) In <code>fals</code>, if treatHeywood is 
true, a penalized least squares function is used to bound the communality 
estimates below 1.0. Defaults to treatHeywood = TRUE.
</p>
</li>
<li> <p><strong>nStart</strong>: (Numeric) The number of starting values to be tried 
in <code>faml</code>. Defaults to nStart = 10.
</p>
</li>
<li> <p><strong>start</strong>: (Matrix) NULL or a matrix of starting values, each column 
giving an initial set of uniquenesses. Defaults to start = NULL. 
</p>
</li>
<li> <p><strong>maxCommunality</strong>: (Numeric) In <code>faml</code>, set the maximum 
communality value for the estimated solution. Defaults to maxCommunality = .995.
</p>
</li>
<li> <p><strong>epsilon</strong>: (Numeric) In <code>fapa</code>, the numeric threshold 
designating when the algorithm has converged. Defaults to epsilon = 1e-4.
</p>
</li>
<li> <p><strong>communality</strong>: (Character) The method used to estimate the 
initial communality values in <code>fapa</code>. Defaults to communality = 'SMC'.
</p>

<ul>
<li> <p><strong>"SMC"</strong>: Initial communalities are estimated by taking the 
squared multiple correlations of each indicator after regressing the 
indicator on the remaining variables.
</p>
</li>
<li> <p><strong>"maxr"</strong>: Initial communalities equal the largest 
(absolute value) correlation in each column of the correlation matrix.
</p>
</li>
<li> <p><strong>"unity"</strong>: Initial communalities equal 1.0 for all variables.
</p>
</li>
</ul>
</li>
<li> <p><strong>maxItr</strong>: (Numeric) In <code>fapa</code>, the maximum number of 
iterations to reach convergence. Defaults to maxItr = 15,000.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotateControl</code></td>
<td>
<p>(List) A list of control values to pass to the factor rotation algorithms.
</p>

<ul>
<li> <p><strong>numberStarts</strong>: (Numeric) The number of random (orthogonal) 
starting configurations for the chosen rotation method (e.g., oblimin). The first
rotation will always commence from the unrotated factors orientation.
Defaults to numberStarts = 10. 
</p>
</li>
<li> <p><strong>gamma</strong>: (Numeric) This is a tuning parameter (between 0 
and 1, inclusive) for an oblimin rotation.  See the <span class="pkg">GPArotation</span> 
library's oblimin documentation for more details. Defaults to gamma = 0 
(i.e., a quartimin rotation).
</p>
</li>
<li> <p><strong>delta</strong>: (Numeric) This is a tuning parameter for the geomin
rotation. It adds a small number (default = .01) to the squared factor 
loadings before computing the geometric means in the discrepancy function.
</p>
</li>
<li> <p><strong>kappa</strong>: (Numeric) The main parameterization of the 
Crawford-Ferguson (CF) rotations (i.e., "cfT" and "cfQ" for orthogonal and 
oblique CF rotation, respectively). Defaults to kappa = 0. 
</p>
</li>
<li> <p><strong>k</strong>: (Numeric) A specific parameter of the simplimax rotation. 
Defaults to k = the number of observed variables.
</p>
</li>
<li> <p><strong>standardize</strong>: (Character) The standardization routine used 
on the unrotated factor structure. The three options are "none", "Kaiser", 
and "CM". Defaults to standardize = "none". 
</p>

<ul>
<li> <p><strong>"none"</strong>: No standardization is applied to the unrotated 
factor structure. 
</p>
</li>
<li> <p><strong>"Kaiser"</strong>: Use a factor structure matrix that has been 
normed by Kaiser's method (i.e., normalize all rows to have a unit length).
</p>
</li>
<li> <p><strong>"CM"</strong>: Use a factor structure matrix that has been normed
by the Cureton-Mulaik method.
</p>
</li>
</ul>
</li>
<li> <p><strong>epsilon</strong>: (Numeric) The rotational convergence criterion to 
use. Defaults to epsilon = 1e-5.
</p>
</li>
<li> <p><strong>power</strong>: (Numeric) Raise factor loadings the the n-th power 
in the <code>promaxQ</code> rotation. Defaults to power = 4.
</p>
</li>
<li> <p><strong>maxItr</strong>: (Numeric) The maximum number of iterations for the 
rotation algorithm. Defaults to maxItr = 15000.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The obtained Schmid-Leiman (SL) factor structure matrix is rescaled if 
its communalities differ from those of the  original first-order 
solution (due to the presence of one or more Heywood cases in a solution of any order). 
Rescaling will produce SL communalities that match those of 
the original first-order  solution.
</p>


<h3>Value</h3>


<ul>
<li> <p><strong>L1</strong>: (Matrix) The first-order (oblique) factor pattern matrix.
</p>
</li>
<li> <p><strong>L2</strong>: (Matrix) The second-order (oblique) factor pattern matrix.
</p>
</li>
<li> <p><strong>L3</strong>: (Matrix, NULL) The third-order (oblique) factor pattern 
matrix (if applicable).
</p>
</li>
<li> <p><strong>Phi1</strong>: (Matrix) The first-order factor correlation matrix.
</p>
</li>
<li> <p><strong>Phi2</strong>: (Matrix) The second-order factor correlation matrix.
</p>
</li>
<li> <p><strong>Phi3</strong>: (Matrix, NULL) The third-order factor pattern matrix 
(if applicable).
</p>
</li>
<li> <p><strong>U1</strong>: (Matrix) The square root of the first-order factor 
uniquenesses (i.e., factor standard deviations).
</p>
</li>
<li> <p><strong>U2</strong>: (Matrix) The square root of the second-order factor 
uniquenesses (i.e., factor standard deviations).
</p>
</li>
<li> <p><strong>U3</strong>: (Matrix, NULL) The square root of the third-order factor 
uniquenesses (i.e., factor standard deviations) (if applicable).
</p>
</li>
<li> <p><strong>B</strong>: (Matrix) The resulting Schmid-Leiman transformation.
</p>
</li>
<li> <p><strong>rotateControl</strong>: (List) A list of the control parameters 
passed to the <code>faMain</code> function.
</p>
</li>
<li> <p><strong>faControl</strong>: (List) A list of optional parameters passed to 
the factor extraction (<code>faX</code>) function.
</p>
</li>
<li>
<p><strong>HeywoodFlag</strong>(Integer) An integer indicating whether one or more 
Heywood cases were encountered during estimation.
</p>
</li>
</ul>
<h3>Author(s)</h3>


<ul>
<li>
<p> Casey Giordano (Giord023@umn.edu)
</p>
</li>
<li>
<p> Niels G. Waller (nwaller@umn.edu)
</p>
</li>
</ul>
<h3>References</h3>

<p>Abad, F. J., Garcia-Garzon, E., Garrido, L. E., &amp; Barrada, J. R. 
(2017). Iteration of partially specified target matrices: application to the 
bi-factor case. <em>Multivariate Behavioral Research, 52</em>(4), 416-429.
</p>
<p>Giordano, C. &amp; Waller, N. G. (under review). Recovering bifactor 
models: A comparison of seven methods.
</p>
<p>Schmid, J., &amp; Leiman, J. M. (1957). The development of 
hierarchical factor solutions. <em>Psychometrika, 22</em>(1), 53-61.
</p>


<h3>See Also</h3>

<p>Other Factor Analysis Routines: 
<code>BiFAD()</code>,
<code>Box26</code>,
<code>GenerateBoxData()</code>,
<code>Ledermann()</code>,
<code>SLi()</code>,
<code>faAlign()</code>,
<code>faEKC()</code>,
<code>faIB()</code>,
<code>faLocalMin()</code>,
<code>faMB()</code>,
<code>faMain()</code>,
<code>faScores()</code>,
<code>faSort()</code>,
<code>faStandardize()</code>,
<code>faX()</code>,
<code>fals()</code>,
<code>fapa()</code>,
<code>fareg()</code>,
<code>fsIndeterminacy()</code>,
<code>orderFactors()</code>,
<code>print.faMB()</code>,
<code>print.faMain()</code>,
<code>promaxQ()</code>,
<code>summary.faMB()</code>,
<code>summary.faMain()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Dataset used in Schmid &amp; Leiman (1957) rounded to 2 decimal places
SLdata &lt;-
  matrix(c(1.0, .72, .31, .27, .10, .05, .13, .04, .29, .16, .06, .08,
           .72, 1.0, .35, .30, .11, .06, .15, .04, .33, .18, .07, .08,
           .31, .35, 1.0, .42, .08, .04, .10, .03, .22, .12, .05, .06,
           .27, .30, .42, 1.0, .06, .03, .08, .02, .19, .11, .04, .05,
           .10, .11, .08, .06, 1.0, .32, .13, .04, .11, .06, .02, .03,
           .05, .06, .04, .03, .32, 1.0, .07, .02, .05, .03, .01, .01,
           .13, .15, .10, .08, .13, .07, 1.0, .14, .14, .08, .03, .04,
           .04, .04, .03, .02, .04, .02, .14, 1.0, .04, .02, .01, .01,
           .29, .33, .22, .19, .11, .05, .14, .04, 1.0, .45, .15, .17,
           .16, .18, .12, .11, .06, .03, .08, .02, .45, 1.0, .08, .09,
           .06, .07, .05, .04, .02, .01, .03, .01, .15, .08, 1.0, .42,
           .08, .08, .06, .05, .03, .01, .04, .01, .17, .09, .42, 1.0),
         nrow = 12, ncol = 12, byrow = TRUE)

Out1 &lt;- SchmidLeiman(R          = SLdata,
                     numFactors = c(6, 3, 1))$B

## An orthogonalization of a two-order structure
bifactor &lt;- matrix(c(.46, .57, .00, .00,
                     .48, .61, .00, .00,
                     .61, .58, .00, .00,
                     .46, .00, .55, .00,
                     .51, .00, .62, .00,
                     .46, .00, .55, .00,
                     .47, .00, .00, .48,
                     .50, .00, .00, .50,
                     .49, .00, .00, .49),
                   nrow = 9, ncol = 4, byrow = TRUE)

## Model-implied correlation (covariance) matrix
R &lt;- bifactor %*% t(bifactor)

## Unit diagonal elements
diag(R) &lt;- 1

Out2 &lt;- SchmidLeiman(R          = R,
                     numFactors = c(3, 1),
                     rotate     = "oblimin")$B

</code></pre>


</div>