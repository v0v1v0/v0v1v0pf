<div class="container">

<table style="width: 100%;"><tr>
<td>Approx.cfpt.density</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximating First-Passage-Time Densities for Conditioned Problems</h2>

<h3>Description</h3>

<p><code>Approx.cfpt.density</code> computes values of the approximate first-passage-time (f.p.t.) density, for a conditioned problem, 
from an object of class “summary.fptl” that contains the information provided by First-Passage-Time Location (FPTL) function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Approx.cfpt.density(sfptl, variableStep = TRUE, from.t0 = FALSE, 
                   to.T = FALSE, skip = TRUE, n = 250, p = 0.2, 
                   alpha = 1, tol = 1e-03, it.max = 50000L)                      
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sfptl</code></td>
<td>
<p>an object of class “summary.fptl”, a result of applying the <code>summary.fptl</code> method to an object
of class “fptl”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variableStep</code></td>
<td>
<p>a logical value indicating whether a variable integration step is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from.t0</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated from the lower end of the
interval considered, <code class="reqn">t_0</code>, specified in the <code>sfptl</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to.T</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated to the upper end of the
interval considered, <code class="reqn">T</code>, specified in the <code>sfptl</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip</code></td>
<td>
<p>a logical value indicating whether the intervals at which the FPTL function is near zero could be
avoided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of points used to determine the integration step in subintervals <code class="reqn">[t_i^*, t_{max,i}^+]</code> 
<code class="reqn">i=1, \ldots, m</code>, from interesting instants provided by the FPTL function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Ratio of n used to determine the integration step in subintervals  
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter used to determine the integration step in subintervals 
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>, in order to reduce the computational cost of approximating the f.p.t. density function 
in those cases where <code class="reqn">t_{i+1}^* - t_{max,i}^+ &gt;&gt; t_{max,i}^{-} - \thinspace t_i^*</code>, 
for some <code class="reqn">i</code>, <code class="reqn">t_1^* - t_0 &gt;&gt; t_{max,1}^{-} - \thinspace t_1^*</code> or 
<code class="reqn">T - t_{max,m}^+ &gt;&gt; t_{max,m}^{-} - \thinspace t_m^*</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>If the cumulative integral of the approximation is greater than or equal to 1 - tol the algorithm is stopped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>it.max</code></td>
<td>
<p>If the number of iterations required for the approximation process is greater than it.max, the function asks for permission to continue.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For a diffusion process <code class="reqn">\{X(t), t_0 \leq t \leq T \}</code>, the f.p.t. variable,   
conditioned to <code class="reqn">X(t_0) = x_0</code>, through a continuous boundary <code class="reqn">S(t)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">T_{S(t), x_0} = \left\{
\begin{array}{lll}
Inf \ \{ t \geq t_0 \ : \ X(t) &gt; S(t) \mid X(t_0)=x_0 \} &amp; &amp; if \ x_0 &lt; S(t_0) \\[7pt]
Inf \ \{ t \geq t_0 \ : \ X(t) &lt; S(t) \mid X(t_0)=x_0 \} &amp; &amp; if \ x_0 &gt; S(t_0)
\end{array}
 \right. .</code>
</p>

<p>Its density function is the solution to a Volterra integral equation of the second kind. The kernel of this equation depends
on the infinitesimal moments of the process, the transition probability density function and the boundary. 
</p>
<p>Nevertheless, and apart from some particular processes and boundaries,
closed-form solutions for the integral equation are not available. For this reason, 
in the cases without explicit solutions, numerical procedures are required. That is the situation 
considered here and the numerical procedure implemented by the <code>Approx.fpt.density</code> function is the one 
proposed by Buonocore et al. (1987), based on the composite trapezoid method. <br></p>
<p>The <code>Approx.cfpt.density</code> function computes efficiently the approximate f.p.t. density by
using the information provided by the FPTL function contained in the 
<code>sfptl</code> object. See the function <code>summary.fptl</code> for details. <br></p>
<p>By default the function does not compute the approximate f.p.t. density 
from the time instant <code class="reqn">t_0</code>, but from a more suitable time instant <code class="reqn">t_1^*</code>
provided by the FPTL function. It also uses a variable integration step. <br></p>
<p>The function makes an internal call to <code>Integration.Steps</code> function in order to determine the subintervals and 
integration steps to be used in the application of the numerical algorithm according to the <code>variableStep</code>, 
<code>from.t0</code>, <code>to.T</code>, <code>n</code>, <code>p</code> and <code>alpha</code> arguments. <br></p>
<p>In addition, if <code>skip = TRUE</code>, the function checks the approximate density value for each <code class="reqn">t_{max,i}^+</code>, 
and, if it is almost 0, the application of the numerical algorithm in the subinterval <code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code> 
is avoided, and then continued from instant <code class="reqn">t_{i+1}^*</code> considering a zero value of the approximate 
density. <br></p>
<p>Similarly, if <code>to.T = FALSE</code>, the function checks the cumulative value of the integral for each <code class="reqn">t_{max,i}^+</code> 
provided by the FPTL function and, if it is greater than or equal to 1 - tol, the numerical algorithm is stopped. In any case, 
the algorithm is stopped in the final <code class="reqn">t_{max,i}^+</code>, and if the cumulative value of the integral is less than 1 - tol
the function issues a warning. <br></p>


<h3>Value</h3>

<p>The <code>Approx.cfpt.density</code> function computes and returns an object of class “fpt.density”. It 
is a three-component list:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a sequence of suitable time instants in <code class="reqn">[t_0, \ T]</code> according to the arguments in the function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the approximate conditioned f.p.t. density function values on the x sequence.</p>
</td>
</tr>
</table>
<p><br></p>
<table><tr style="vertical-align: top;">
<td><code>y.x0</code></td>
<td>
<p>NULL (for consistency with the object of class “fpt.density” that produces the <code>Approx.fpt.density</code> function).</p>
</td>
</tr></table>
<p>It also includes six additional attributes: 
</p>

<table>
<tr>
<td style="text-align: right;">
<code>Call</code> </td>
<td style="text-align: left;"> the unevaluated function call, substituting each name in this call by its value when </td>
</tr>
<tr>
<td style="text-align: right;"> 
 </td>
<td style="text-align: left;"> the latter has length 1. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>Steps</code> </td>
<td style="text-align: left;"> matrix of subintervals and integration steps to consider for computing </td>
</tr>
<tr>
<td style="text-align: right;"> 
 </td>
<td style="text-align: left;"> the approximate conditioned f.p.t. density. </td>
</tr>
<tr>
<td style="text-align: right;"> 
<code>cumIntegral</code> </td>
<td style="text-align: left;"> vector of the values of the cumulative integral of the </td>
</tr>
<tr>
<td style="text-align: right;">
 </td>
<td style="text-align: left;"> approximation for each subinterval considered. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>skips</code> </td>
<td style="text-align: left;"> a list that contains, for each subinterval, the value 1 if the application of the </td>
</tr>
<tr>
<td style="text-align: right;">
 </td>
<td style="text-align: left;"> numerical algorithm has been avoided or integer(0) otherwise. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>CPUTime</code> </td>
<td style="text-align: left;"> matrix of user and system times, by columns, required to approximate </td>
</tr>
<tr>
<td style="text-align: right;">
 </td>
<td style="text-align: left;"> the density for each subinterval considered, by rows. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>summary.fptl</code> </td>
<td style="text-align: left;"> the object used as <code>sfptl</code> argument in the function call. </td>
</tr>
<tr>
<td style="text-align: right;">
</td>
</tr>
</table>
<p><code>x</code> is the vector result of the concatenation of the sequences of equally spaced values in the suitable subintervals 
determined by the <code>Integration.Steps</code> function. 
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>Buonocore, A., Nobile, A.G. and Ricciardi, L.M. (1987) A new integral equation for the evaluation of
first-passage-time probability densities. <em>Adv. Appl. Probab.</em>, <b>19</b>, 784–800.
</p>
<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132–4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408–8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432–446.
</p>


<h3>See Also</h3>

<p><code>summary.fptl</code> to locate the f.p.t. variable and create objects of class “summary.fptl”.
</p>
<p><code>is.fpt.density</code> to test for objects of class “fpt.density”.
</p>
<p><code>print.fpt.density</code> to show objects of class “fpt.density”. 
</p>
<p><code>report.fpt.density</code> to generate a report.
</p>
<p><code>plot.fpt.density</code> for graphical display.
</p>
<p><code>FPTL</code> to evaluate the FPTL function and create objects of class “fptl”.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Continuing the summary.fptl(.) example:

## Making an efficient approximation of the f.p.t. density 
## (optimal variable integration steps and small computational cost)
yyy &lt;- Approx.cfpt.density(yy)
yyy

zzz &lt;- Approx.cfpt.density(zz)
zzz

## Making a less efficient approximation of the f.p.t. density 
## (optimal fixed integration step but high computational cost related to 
##  the efficient approximation)
## Not run: 
yyy1 &lt;- Approx.cfpt.density(yy, variableStep = FALSE, from.t0 = TRUE, to.T = 
                         TRUE, skip = FALSE)
yyy1
## End(Not run)
</code></pre>


</div>