<div class="container">

<table style="width: 100%;"><tr>
<td>bpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function which calculates pi, or other irrationals,  using the BaileyBorweinPlouffe formula  ~~
</h2>

<h3>Description</h3>

<p>THe BPP algorithm consists of a double summation over specified fractions. Rather than go into the gory details here, please refer to the link in the References section.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">bpp(k,pdat = c(1,16,8,4,0,0,-2,-1,-1,0,0), init = 0, chunk = 1e4,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>The number of terms in the series to calculate.  Note that zero is a valid entry. If a single value, the terms <code>0:k</code> are used.  If two values are provided (see information for the input parameter <code>init</code>), then the terms <code>k{1}:k[2]</code> are run.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdat</code></td>
<td>

<p>The parameter <code>P</code> which is used to define the coefficients used in all fractions in each term of the series.  In brief, pdat contains the following BPP parameters:  <code>pdat(s,b,m,A)</code> where <code>A</code>comprises all elements of the vector <code>pdat</code> after the first three.  There are strict rules about the length of <code>A</code>; see the Details section.   
The default value will calculate pi. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>If there's a previous value calculated with <code>bpp</code> for a certain value of <code>k</code>, this term allows the user to continue the calculation. Assign the previous output's <code>bppgmp</code> value to  <code>init</code> . Note that one must set up the input <code>k</code> to start at one more than the previous run's maximum "k" value.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunk</code></td>
<td>
 
<p>There is a call to <code>sum</code> in the main loop of this function. Use <code>chunk</code> to specify how many terms to pass to the sum call at a time, thus reducing the peak memory requirements of this function.  The more RAM available on your machine, the larger this number can be.  Set to a value greater than the argument <code>k</code> to run a single "chunk," which is the fastest approach if sufficient memory is available. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Optional arguments to pass to <code>.bigq2mpfr</code> . 
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The BPP algorithm calculates the sum(K=0,k, 1/(b^K) * FracSum) , where FracSum is defined by the sum(M=1,m, A[M]/(m*K + M)^s) .
This means that the number of elements of <code>A</code> must equal <code>m</code>. Zero values are legal and are used to reject fractions not wanted in the inner sum. 
The default values for <code>pdat</code> correspond to the coefficients used to generate pi (the sum to infinity is mathematically equal to pi).
Other values have been found to calculate a few other irrationals but there is as yet no known procedure to generate the <code>pdat</code> set for any given number.
</p>


<h3>Value</h3>

<p>A list containing <code>bppgmp</code> , the <code>gmp</code> fraction calculated; <code>bppval</code>, the <code>mpfr</code> decimal representation of said fraction; and <code>kvals</code>, echoing the input <code>k</code>. 
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a> 
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bailey-Borwein-Plouffe_formula">https://en.wikipedia.org/wiki/Bailey-Borwein-Plouffe_formula</a>   and references cited there. 
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Compare the decimal outputs to the first 130 digits of pi, which are:
#  [1] 3 . 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4
#  [26] 3 3 8 3 2 7 9 5 0 2 8 8 4 1 9 7 1 6 9 3 9 9 3 7 5
#  [51] 1 0 5 8 2 0 9 7 4 9 4 4 5 9 2 3 0 7 8 1 6 4 0 6 2
#  [76] 8 6 2 0 8 9 9 8 6 2 8 0 3 4 8 2 5 3 4 2 1 1 7 0 6
# [101] 7 9 8 2 1 4 8 0 8 6 5 1 3 2 8 2 3 0 6 6 4 7 0 9 3
# [126] 8 4 4 6 0

# Lots of precision, but most of the digits are inaccurate.
(bpp(5))

# extend the series.
(bpp(20))

</code></pre>


</div>