<div class="container">

<table style="width: 100%;"><tr>
<td>interpol.matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Interpolation matrix</h2>

<h3>Description</h3>

<p>Calculate the matrix giving the linear interpolation of regularly
spaced points.
</p>


<h3>Usage</h3>

<pre><code class="language-R">interpol.matrix(n = 12, m = 24, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> Number (integer) of points in output space </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p> Number (integer) of points in the input function (or space) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> A relative tolerance to detect zero singular values. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The general principle is, considering a function for which we know
values at <code>m</code> equally spaced points (for instance 1/<code>m</code>,
2/<code>m</code>, ..., 1), to compute the matrix giving the linear
approximation of <code>n</code> equally spaced points (for instance
1/<code>n</code>, 2/<code>n</code>, ..., 1).
</p>
<p>The function works whether <code>n</code> or <code>m</code> is the largest.
</p>
<p>The function is vectorized, so <code>m</code> and <code>n</code> can be vectors of
integers. In this case, they have to be of the same size and the
resulting matrix is block diagonal.
</p>


<h3>Value</h3>

<p>A <code>n</code>x<code>m</code> matrix if they are integer, else a
<code>sum(n)</code>x<code>sum(m)</code> matrix.
</p>


<h3>Author(s)</h3>

<p>J. Damon</p>


<h3>See Also</h3>

 <p><code>theoretical.coef</code>, <code>simul.far</code> or
<code>simul.farx</code>. </p>


<h3>Examples</h3>

<pre><code class="language-R">  mat1 &lt;- interpol.matrix(12,24)
  mat2 &lt;- interpol.matrix(c(3,5),c(12,12))
  print(mat1 %*% base.simul.far(24,5))
  print(mat2 %*% base.simul.far(24,5))  
</code></pre>


</div>