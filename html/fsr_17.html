<div class="container">

<table style="width: 100%;"><tr>
<td>fsi_qw_eval</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluate region inference methods</h2>

<h3>Description</h3>

<p><code>fsi_qw_eval()</code> implements two methods for evaluating region inference (RI) queries: (i) Linguistic value-based RI query, and (ii) Optimal RI query.
The objective of these queries is to capture all points that intersect a search object (e.g., a query window) and
whose inferred values fulfill some specific user requirements (e.g., the points with the maximum or minimum inferred values).
</p>


<h3>Usage</h3>

<pre><code class="language-R">fsi_qw_eval(fsi, qw, approach = "discretization", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fsi</code></td>
<td>
<p>An FSI model built with the <code>fsi_create()</code> function and populated by the functions <code>fsi_add_fsa()</code>, <code>fsi_add_cs()</code>, and <code>fsi_add_rules()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qw</code></td>
<td>
<p>An <code>sfg</code> object representing the search object (e.g., a query window). It has to be an axis-aligned rectangle represented by a simple polygon object of 5 points (since the last coordinate pair closes the external ring of the rectangle).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>approach</code></td>
<td>
<p>Defines which approach is employed to perform the region inference: <code>"discretization"</code> or <code>"pso"</code>. Default value is <code>"discretization"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>&lt;<code>dynamic-dots</code>&gt; Different set of parameters required depending on the chosen approach (see more in details below).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>fsi_qw_eval()</code> function evaluates two types of RI queries:
</p>

<ul>
<li> <p><em>Linguistic value-based RI query</em>, which answers the following type of question: what are the points that intersect a given search object and have inferred values that belong to a target linguistic value?
</p>
</li>
<li> <p><em>Optimal RI query</em>, which answers the following type of question: what are the points that intersect a given search object and have the maximum (or minimum) inferred values?
</p>
</li>
</ul>
<p><code>fsi_qw_eval()</code> offers two different methods to answer these questions: (i) <em>discretization</em> method, and (ii) <em>optimization</em> method.
Comparative analyses (see reference below) indicate that the discretization method should be employed to process linguistic value-based RI queries, while
the optimization method is more adequate for processing optimal RI queries. The details below describe how to use these methods.
</p>
<p>For the <em>discretization</em> method, two additional parameters are needed and must be informed by using the three-dots parameter <code>...</code>:
</p>

<ul>
<li> <p><code>target_lval</code>: A character value that indicates the target linguistic value from the linguistic variable of the consequent.
</p>
</li>
<li> <p><code>k</code>: A numeric value that defines the number of points that will be captured from the query window and evaluated by <code>fsi_eval()</code>.
Its square root has to an integer value.
Alternatively, you can inform the number of columns and rows of the regular grid to be created on the query window by informing numeric values for <code>n_col</code> and <code>n_row</code>, respectively.
Thus, these parameters can be given instead of the number <code>k</code>.
</p>
</li>
</ul>
<p>The <em>optimization</em> method employs the particle swarm optimization (PSO) algorithm. Thus, the parameter <code>approach = "pso"</code> must be set together with the following parameters:
</p>

<ul>
<li> <p><code>what</code>: A character value that defines the user's goal, which can be either <strong>maximize</strong> or <strong>minimize</strong> inferred values.
Thus, this parameter can be either <code>"max"</code> or <code>"min"</code>. The default value is <code>"max"</code>.
</p>
</li>
<li> <p><code>max_depth</code>: A numeric value that refers to the number of times that the query window is divided into subquadrants.
The default value is equal to 2. For instance, a <code>max_depth = 2</code> means that the query window will be split into four subquadrants, where the PSO will be applied to each one as its search space.
</p>
</li>
</ul>
<p>In addition, the PSO algorithm has its own set of parameters:
</p>

<ul>
<li> <p><code>maxit</code>: A numeric value that defines the maximum number of iterations. Default value is 50.
</p>
</li>
<li> <p><code>population</code>: A numeric value that defines the number of particles. Default value is 10.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A tibble in the format <code style="white-space: pre;">⁠(points, inferred_values)⁠</code>, where <code>points</code> is an <code>sfc</code> object and <code>inferred_values</code> are inferred values in the domain of the consequent of the FSI model.
</p>


<h3>References</h3>

<p><a href="https://dl.acm.org/doi/10.1145/3474717.3484255">Carniel, A. C.; Galdino, F.; Philippsen, J. S.; Schneider, M. Handling Fuzzy Spatial Data in R Using the fsr Package. In Proceedings of the 29th International Conference on Advances in Geographic Information Systems (AM SIGSPATIAL 2021), pp. 526-535, 2021.</a>
</p>
<p>Underlying concepts and definitions on the evaluation of region inference methods are explained in:
</p>

<ul><li> <p><a href="https://ieeexplore.ieee.org/document/9882658">Carniel, A. C.; Galdino, F.; Schneider, M. Evaluating Region Inference Methods by Using Fuzzy Spatial Inference Models. In Proceedings of the 2022 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE 2022), pp. 1-8, 2022.</a>
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">library(sf)

# Creating the FSI model from an example
fsi &lt;- visitation()

# Creating a vector of fuzzy rules
## note that we make use of the linguistic variables and linguistic values previously defined
rules &lt;- c(
 "IF accommodation review is reasonable AND 
    food safety is low 
  THEN visiting experience is awful",
 "IF accommodation price is expensive AND 
    accommodation review is reasonable 
  THEN visiting experience is awful",
 "IF accommodation price is affordable AND 
    accommodation review is good AND 
    food safety is medium 
  THEN visiting experience is average",
 "IF accommodation price is affordable AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great",
 "IF accommodation price is cut-rate AND 
    accommodation review is excellent AND 
    food safety is high 
  THEN visiting experience is great")

# Adding these rules to the FSI model previously instantiated
fsi &lt;- fsi_add_rules(fsi, rules)

# Defining the query window
pts_qw1 &lt;- rbind(c(-73.92, 40.68527), c(-73.75, 40.68527), 
                 c(-73.75, 40.75), c(-73.92, 40.75), c(-73.92, 40.68527))
qw1 &lt;- st_polygon(list(pts_qw1))

# Recall that our running example is based on a small set of point datasets
# This means that inferred values will likely be the same

## Not run: 
# Example using the discretization method
fsi_qw_eval(fsi, qw1, approach = "discretization", target_lval = "great", k = 25)

# Example using the optimization method
fsi_qw_eval(fsi, qw1, approach = "pso", max_depth = 2)

## End(Not run)
</code></pre>


</div>