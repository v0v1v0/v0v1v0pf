<div class="container">

<table style="width: 100%;"><tr>
<td>kernel_new</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transition Kernels for MCMC</h2>

<h3>Description</h3>

<p>The function <code>kernel_new</code> is a helper function that allows creating
<code>fmcmc_kernel</code> objects which are passed to the <code>MCMC()</code> function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kernel_new(proposal, ..., logratio = NULL, kernel_env = new.env(hash = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>proposal, logratio</code></td>
<td>
<p>Functions. Both receive a single argument, an environment.
This functions are called later within MCMC (see details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In the case of <code>kernel_new</code>, further arguments to be stored with
the kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel_env</code></td>
<td>
<p>Environment. This will be used as the main container of the
kernel's components. It is returned as an object of class <code>c("environment", "fmcmc_kernel")</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The objects <code>fmcmc_kernels</code> are environments that in general contain the
following objects:
</p>

<ul>
<li> <p><code>proposal</code>: The function used to propose changes in the chain based
on the current state. The function must return a vector of length equal
to the number of parameters in the model.
</p>
</li>
<li> <p><code>logratio</code>: This function is called after a new state has been proposed,
and is used to compute the log of the Hastings ratio.
</p>
<p>In the case that the <code>logratio</code> function is not specified, then it is assumed
that the transition kernel is symmetric, this is, log-ratio is then implemented
as <code>function(env) {env$f1 - env$f0}</code>
</p>
</li>
<li> <p><code>...</code>: Further objects that are used within those functions.
</p>
</li>
</ul>
<p>Both functions, <code>proposal</code> and <code>logratio</code>, receive a single argument, an
environment, which is passed by the <code>MCMC()</code> function during each step using
the function <code>environment()</code>.
</p>
<p>The passed environment is actually the environment in which the <code>MCMC</code>
function is running, in particular, this environment contains the following
objects:
</p>

<table>
<tr>
<td style="text-align: left;">
<strong>Object</strong> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> <strong>Description</strong> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>i</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> Integer. The current iteration. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>theta1</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> Numeric vector. The last proposed state. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>theta0</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> Numeric vector. The current state </td>
</tr>
<tr>
<td style="text-align: left;">
<code>f</code>
</td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> The log-unnormalized posterior function (a wrapper of <code>fun</code> passed
to MCMC). </td>
</tr>
<tr>
<td style="text-align: left;">
<code>f1</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> The last value of <code>f(theta1)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>f0</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> The last value of <code>f(theta0)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>kernel</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> The actual <code>fmcmc_kernel</code> object. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>ans</code> </td>
<td style="text-align: center;"> </td>
<td style="text-align: left;"> The matrix of samples defined up to <code>i - 1</code>.
</td>
</tr>
</table>
<p>These are the core component of the <code>MCMC</code> function. The following block
of code is how this is actually implemented in the package:
</p>
<div class="sourceCode"><pre>for (i in 1L:nsteps) {
  # Step 1. Propose
  theta1[] &lt;- kernel$proposal(environment())
  f1       &lt;- f(theta1)
  
  # Checking f(theta1) (it must be a number, can be Inf)
  if (is.nan(f1) | is.na(f1) | is.null(f1)) 
    stop(
      "fun(par) is undefined (", f1, ")",
      "Check either -fun- or the -lb- and -ub- parameters.",
      call. = FALSE
    )
  
  # Step 2. Hastings ratio
  if (R[i] &lt; kernel$logratio(environment())) {
    theta0 &lt;- theta1
    f0     &lt;- f1
  }
  
  # Step 3. Saving the state
  ans[i,] &lt;- theta0
  
}
</pre></div>
<p>For an extensive example on how to create new kernel objects see the vignette
<code>vignette("user-defined-kernels", "fmcmc")</code>.
</p>


<h3>Value</h3>

<p>An environment of class <code>fmcmc_kernel</code> which contains the following:
</p>

<ul>
<li> <p><code>proposal</code> A function that receives a single argument, an environment. This
is the proposal function used within <code>MCMC()</code>.
</p>
</li>
<li> <p><code>logratio</code> A function to compute log ratios of the current vs the proposed
step of the chain. Also used within <code>MCMC()</code>.
</p>
</li>
<li> <p><code>...</code> Further arguments passed to <code>kernel_new</code>.
</p>
</li>
</ul>
<h3>Behavior</h3>

<p>In some cases, calls to the <code>proposal()</code> and <code>logratio()</code> functions in
<code>fmcmc_kernels</code> can trigger changes or updates of variables stored within them.
A concrete example is with adaptive kernels.
</p>
<p>Adaptive Metropolis and Robust Adaptive Metropolis implemented in the functions
<code>kernel_adapt()</code> and <code>kernel_ram()</code> both update a covariance matrix used
during the proposal stage, and furthermore, have a <code>warmup</code> stage that sets
the point at which both will start adapting. Because of this, both kernels
have internal counters of the absolute step count which allows them activating,
scaling, etc. the proposals correctly.
</p>

<ol>
<li>
<p> When running multiple chains, <code>MCMC</code> will create independent copies of a
baseline passed <code>fmcmc_kernel</code> object. These are managed together in a
<code>fmcmc_kernel_list</code> object.
</p>
</li>
<li>
<p> Even if the chains are run in parallel, if a predefined kernel object is
passed it will be updated to reflect the last state of the kernels
before the <code>MCMC</code> call returns.
</p>
</li>
</ol>
<h3>References</h3>

<p>Brooks, S., Gelman, A., Jones, G. L., &amp; Meng, X. L. (2011). Handbook of
Markov Chain Monte Carlo. Handbook of Markov Chain Monte Carlo.
</p>


<h3>See Also</h3>

<p>Other kernels: 
<code>kernel_adapt()</code>,
<code>kernel_mirror</code>,
<code>kernel_normal()</code>,
<code>kernel_ram()</code>,
<code>kernel_unif()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Example creating a multivariate normal kernel using the mvtnorm R package
# for a bivariate normal distribution
library(mvtnorm)

# Define your Sigma
sigma &lt;- matrix(c(1, .2, .2, 1), ncol = 2)

# How does it looks like?
sigma
#      [,1] [,2]
# [1,]  1.0  0.2
# [2,]  0.2  1.0

# Create the kernel
kernel_mvn &lt;- kernel_new(
  proposal = function(env) {
  env$theta0 + as.vector(mvtnorm::rmvnorm(1, mean = 0, sigma = sigma.))
  },
  sigma. = sigma
)

# As you can see, in the previous call we passed sigma as it will be used by
# the proposal function
# The logaratio function was not necesary to be passed since this kernel is
# symmetric.

</code></pre>


</div>