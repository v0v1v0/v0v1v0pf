<div class="container">

<table style="width: 100%;"><tr>
<td>monte</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate Clustered Data with User-Defined Properties</h2>

<h3>Description</h3>

<p>Function for simulating clustered data with user defined characteristics
such as: within cluster indicator correlations, within cluster indicator
skewness values, within cluster indicator kurtosis values, and cluster
separations as indexed by each variable (indicator validities).
</p>


<h3>Usage</h3>

<pre><code class="language-R">monte(
  seed = 123,
  nvar = 4,
  nclus = 3,
  clus.size = c(50, 50, 50),
  eta2 = c(0.619, 0.401, 0.941, 0.929),
  cor.list = NULL,
  random.cor = FALSE,
  skew.list = NULL,
  kurt.list = NULL,
  secor = NULL,
  compactness = NULL,
  sortMeans = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Required: An integer to be used as the random number seed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar</code></td>
<td>
<p>Required: Number of variables to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclus</code></td>
<td>
<p>Required: Number of clusters to simulate. <em>Note</em> that
number of clusters must be equal to or greater than 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clus.size</code></td>
<td>
<p>Required: Number of objects in each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta2</code></td>
<td>
<p>Required: A vector of indicator validities that range from 0 to
1. Higher numbers produce clusters with greater separation on that
indicator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor.list</code></td>
<td>
<p>Optional: A list of correlation matrices. There should be
one correlation matrix for each cluster.  The first correlation matrix will
represent the indicator correlations within cluster 1.  The second
correlation matrix will represent the indicator correlations for cluster 2.
Etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.cor</code></td>
<td>
<p>Optional: Set to TRUE to generate a common within cluster
correlation matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skew.list</code></td>
<td>
<p>Optional: A list of within cluster indicator skewness
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kurt.list</code></td>
<td>
<p>Optional: A list of within cluster indicator kurtosis
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>secor</code></td>
<td>
<p>Optional: If 'random.cor = TRUE' then 'secor' determines the
standard error of the simulated within group correlation matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compactness</code></td>
<td>
<p>Optional: A vector of cluster compactness parameters. The
meaning of this option is explained Waller et al. (1999). Basically,
'compactness' allows users some control over cluster overlap without
changing indicator validities. See the example below for an illustration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sortMeans</code></td>
<td>
<p>Optional: A logical that determines whether the latent
means will be sorted by taxon. Default = TRUE</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The simulated data. The 1st column of 'data' denotes
cluster membership.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lmn</code></td>
<td>
<p>The cluster indicator means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fl</code></td>
<td>
<p>The
factor loading matrix as described in Waller, et al. 1999.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fs</code></td>
<td>
<p>The
unique values of the linearized factor scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nclus</code></td>
<td>
<p>Number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvar</code></td>
<td>
<p>Number of variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cor.list</code></td>
<td>
<p>The input within cluster correlation matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skew.list</code></td>
<td>
<p>The input within cluster indicator skewness values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kurt.list</code></td>
<td>
<p>The input within cluster indicator kurtosis values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clus.size</code></td>
<td>
<p>The number of observations in each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta2</code></td>
<td>
<p>Vector of indicator validities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The random number
seed.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Niels Waller
</p>


<h3>References</h3>

<p>Fleishman, A. I (1978). A method for simulating non-normal
distributions. <em>Psychometrika, 43</em>, 521-532.
</p>
<p>Olvera Astivia, O. L. &amp; Zumbo, B. D. (2018). On the solution 
multiplicity of the Fleishman method and its impact in 
simulation studies. <em>British Journal of Mathematical and Statistical Psychology, 71</em>
(3), 437-458. 
</p>
<p>Vale, D. C., &amp; Maurelli, V. A. (1983). Simulating multivariate nonnormal
distributions. <em>Psychometrika, 48</em>, 465-471.
</p>
<p>Waller, N. G., Underhill, J. M., &amp; Kaiser, H. A. (1999).  A method for
generating simulated plasmodes and artificial test clusters with
user-defined shape, size, and orientation. <em>Multivariate Behavioral
Research, 34</em>, 123-142.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Example 1
## Simulating Fisher's Iris data
# The original data were reported in: 
# Fisher, R. A. (1936) The use of multiple measurements in taxonomic
#     problems. Annals of Eugenics, 7, Part II, 179-188.
#
# This example includes 3 clusters. Each cluster represents
# an Iris species: Setosa, Versicolor, and Virginica.
# On each species, four variables were measured: Sepal Length, 
# Sepal Width, Petal Length, and Petal Width.
#
# The within species (cluster) correlations of the flower
# indicators are as follows:
#
# Iris Type 1: 
#      [,1]  [,2]  [,3]  [,4]
# [1,] 1.000 0.743 0.267 0.178
# [2,] 0.743 1.000 0.278 0.233
# [3,] 0.267 0.278 1.000 0.332
# [4,] 0.178 0.233 0.332 1.000
#
# Iris Type 2
#      [,1]  [,2]  [,3]  [,4]
# [1,] 1.000 0.526 0.754 0.546
# [2,] 0.526 1.000 0.561 0.664
# [3,] 0.754 0.561 1.000 0.787
# [4,] 0.546 0.664 0.787 1.000
#
# Iris Type 3
#      [,1]  [,2]  [,3]  [,4]
# [1,] 1.000 0.457 0.864 0.281
# [2,] 0.457 1.000 0.401 0.538
# [3,] 0.864 0.401 1.000 0.322
# [4,] 0.281 0.538 0.322 1.000
#
# 'monte' expects a list of correlation matrices
# 

#create a list of within species correlations
data(iris)
cormat &lt;- cm &lt;- lapply(split(iris[,1:4], iris[,5]), cor)
 
# create a list of within species indicator 
# skewness and kurtosis
 sk.lst &lt;- list(c(0.120,  0.041,  0.106,  1.254),                     
                c(0.105, -0.363, -0.607, -0.031),
                c(0.118,  0.366,  0.549, -0.129) )
              
              
 kt.lst &lt;- list(c(-0.253, 0.955,  1.022,  1.719),
                c(-0.533,-0.366,  0.048, -0.410),
                c( 0.033, 0.706, -0.154, -0.602) )    


#Generate a new sample of iris data
my.iris &lt;- monte(seed=123, nvar = 4, nclus = 3, cor.list = cormat, 
                clus.size = c(50, 50, 50),
                eta2=c(0.619, 0.401, 0.941, 0.929), 
                random.cor = FALSE,
                skew.list = sk.lst, 
                kurt.list = kt.lst, 
                secor = .3, compactness=c(1, 1, 1),
                sortMeans = TRUE)


summary(my.iris)
plot(my.iris)

# Now generate a new data set with the sample indicator validities 
# as before but with different cluster compactness values.

my.iris2&lt;-monte(seed = 123, nvar = 4, nclus = 3, 
               cor.list = cormat, clus.size = c(50, 50, 50),
               eta2 = c(0.619, 0.401, 0.941, 0.929), random.cor = FALSE,
               skew.list = sk.lst ,kurt.list = kt.lst, 
               secor = .3,
               compactness=c(2, .5, .5), 
               sortMeans = TRUE)


summary(my.iris2)

# Notice that cluster 1 has been blow up whereas clusters 2 and 3 have been shrunk.
plot(my.iris2)


### Now compare your original results with the actual 
## Fisher iris data
library(lattice)
data(iris)
super.sym &lt;- trellis.par.get("superpose.symbol")
splom(~iris[1:4], groups = Species, data = iris,
      #panel = panel.superpose,
      key = list(title = "Three Varieties of Iris",
                 columns = 3, 
                 points = list(pch = super.sym$pch[1:3],
                 col = super.sym$col[1:3]),
                 text = list(c("Setosa", "Versicolor", "Virginica"))))


############### EXAMPLE 2 ##################################

## Example 2
## Simulating data for Taxometric
## Monte Carlo Studies.
##
## In this four part example we will 
## generate two group mixtures 
## (Complement and Taxon groups)
## under four conditions.
##
## In all conditions 
## base rate (BR) = .20
## 3 indicators
## indicator validities = .50 
## (This means that 50 percent of the total
## variance is due to the mixture.)
##
##
## Condition 1:
## All variables have a slight degree
## of skewness (.10) and kurtosis (.10).
## Within group correlations = 0.00.
##
##
##
## Condition 2:
## In this conditon we generate data in which the 
## complement and taxon distributions differ in shape.
## In the complement group all indicators have 
## skewness values of 1.75 and kurtosis values of 3.75.
## In the taxon group all indicators have skewness values
## of .50 and kurtosis values of 0.
## As in the previous condition, all within group
## correlations (nuisance covariance) are 0.00.
##
##
## Conditon 3:
## In this condition we retain all previous 
## characteristics except that the within group
## indicator correlations now equal .80
## (they can differ between groups).
##
##
## Conditon 4:
## In this final condition we retain
## all previous data characteristics except that 
## the variances of the indicators in the complement 
## class are now 5 times the indicator variances
## in the taxon class (while maintaining indicator skewness, 
## kurtosis, correlations, etc.).
 

##----------------------------


library(lattice)


############################
##      Condition 1  
############################
in.nvar &lt;- 3  ##Number of variables
in.nclus &lt;-2  ##Number of taxa
in.seed &lt;- 123                
BR &lt;- .20     ## Base rate of higher taxon

## Within taxon indicator skew and kurtosis
in.skew.list &lt;- list(c(.1, .1, .1),c(.1, .1, .1)) 
in.kurt.list &lt;- list(c(.1, .1, .1),c(.1, .1, .1))          

## Indicator validities
in.eta2 &lt;- c(.50, .50, .50)

## Groups sizes for Population
BigN &lt;- 100000
in.clus.size &lt;- c(BigN*(1-BR), BR * BigN) 
 
## Generate Population of scores with "monte"
sample.data &lt;- monte(seed = in.seed, 
                nvar=in.nvar, 
                nclus = in.nclus, 
                clus.size = in.clus.size, 
                eta2 = in.eta2, 
                skew.list = in.skew.list, 
                kurt.list = in.kurt.list)
               
          
output &lt;- summary(sample.data)

z &lt;- data.frame(sample.data$data[sample(1:BigN, 600, replace=FALSE),])
z[,2:4] &lt;- scale(z[,2:4])
names(z) &lt;- c("id","v1","v2","v3")

#trellis.device()
trellis.par.set( col.whitebg() )
print(
 cloud(v3 ~ v1 * v2,
       groups = as.factor(id),data=z, 
       subpanel = panel.superpose,
       zlim=c(-4, 4),
       xlim=c(-4, 4),
       ylim=c(-4, 4),
       main="",
       screen = list(z = 20, x = -70)),
   position=c(.1, .5, .5, 1), more = TRUE)
               
                 

############################
##      Condition 2  
############################

## Within taxon indicator skew and kurtosis
in.skew.list &lt;- list(c(1.75, 1.75, 1.75),c(.50, .50, .50)) 
in.kurt.list &lt;- list(c(3.75, 3.75, 3.75),c(0, 0, 0))          

## Generate Population of scores with "monte"
sample.data &lt;- monte(seed = in.seed, 
               nvar = in.nvar, 
               nclus = in.nclus, 
               clus.size = in.clus.size, 
               eta2 = in.eta2, 
               skew.list = in.skew.list, 
               kurt.list = in.kurt.list)
               
          
output &lt;- summary(sample.data)

z &lt;- data.frame(sample.data$data[sample(1:BigN, 600, replace=FALSE),])
z[,2:4] &lt;- scale(z[, 2:4])
names(z) &lt;-c("id", "v1","v2", "v3")

print(
 cloud(v3 ~ v1 * v2,
       groups = as.factor(id), data = z, 
       subpanel = panel.superpose,
       zlim = c(-4, 4),
       xlim = c(-4, 4),
       ylim = c(-4, 4),
       main="",
       screen = list(z = 20, x = -70)),
       position = c(.5, .5, 1, 1), more = TRUE)
               
                 
############################
##      Condition 3  
############################ 

## Set within group correlations to .80
cormat &lt;- matrix(.80, 3, 3)
diag(cormat) &lt;- rep(1, 3)
in.cor.list &lt;- list(cormat, cormat)

## Generate Population of scores with "monte"
sample.data &lt;- monte(seed = in.seed, 
               nvar = in.nvar, 
               nclus = in.nclus, 
               clus.size = in.clus.size, 
               eta2 = in.eta2, 
               skew.list = in.skew.list, 
               kurt.list = in.kurt.list,
               cor.list = in.cor.list)
               
output &lt;- summary(sample.data)

z &lt;- data.frame(sample.data$data[sample(1:BigN, 600, 
                replace = FALSE), ])
z[,2:4] &lt;- scale(z[, 2:4])
names(z) &lt;- c("id", "v1", "v2", "v3")

##trellis.device()
##trellis.par.set( col.whitebg() )
print(
  cloud(v3 ~ v1 * v2,
       groups = as.factor(id),data=z, 
       subpanel = panel.superpose,
       zlim = c(-4, 4),
       xlim = c(-4, 4),
       ylim = c(-4, 4),
       main="",
       screen = list(z = 20, x = -70)),
position = c(.1, .0, .5, .5), more = TRUE)
                                

############################
##      Condition 4  
############################

## Change compactness so that variance of
## complement indicators is 5 times
## greater than variance of taxon indicators
                     
 v &lt;-  ( 2 * sqrt(5))/(1 + sqrt(5)) 
 in.compactness &lt;- c(v, 2-v)   
 
## Generate Population of scores with "monte"
sample.data &lt;- monte(seed = in.seed, 
               nvar = in.nvar, 
               nclus = in.nclus, 
               clus.size = in.clus.size, 
               eta2 = in.eta2, 
               skew.list = in.skew.list, 
               kurt.list = in.kurt.list,
               cor.list = in.cor.list,
               compactness = in.compactness)
               
output &lt;- summary(sample.data)

z &lt;- data.frame(sample.data$data[sample(1:BigN, 600, replace = FALSE), ])
z[, 2:4] &lt;- scale(z[, 2:4])
names(z) &lt;- c("id", "v1", "v2", "v3")
print(
  cloud(v3 ~ v1 * v2,
       groups = as.factor(id),data=z, 
       subpanel = panel.superpose,
       zlim = c(-4, 4),
       xlim = c(-4, 4),
       ylim = c(-4, 4),
       main="",
       screen = list(z = 20, x = -70)),
 position = c(.5, .0, 1, .5), more = TRUE)

</code></pre>


</div>