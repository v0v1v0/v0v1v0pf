<div class="container">

<table style="width: 100%;"><tr>
<td>feNmlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fixed effects nonlinear maximum likelihood models</h2>

<h3>Description</h3>

<p>This function estimates maximum likelihood models (e.g., Poisson or Logit) with non-linear
in parameters right-hand-sides and is efficient to handle any number of fixed effects.
If you do not use non-linear in parameters right-hand-side, use <code>femlm</code> or <code>feglm</code>
instead (their design is simpler).
</p>


<h3>Usage</h3>

<pre><code class="language-R">feNmlm(
  fml,
  data,
  family = c("poisson", "negbin", "logit", "gaussian"),
  NL.fml,
  vcov,
  fixef,
  fixef.rm = "perfect",
  NL.start,
  lower,
  upper,
  NL.start.init,
  offset,
  subset,
  split,
  fsplit,
  split.keep,
  split.drop,
  cluster,
  se,
  ssc,
  panel.id,
  start = 0,
  jacobian.method = "simple",
  useHessian = TRUE,
  hessian.args = NULL,
  opt.control = list(),
  nthreads = getFixest_nthreads(),
  lean = FALSE,
  verbose = 0,
  theta.init,
  fixef.tol = 1e-05,
  fixef.iter = 10000,
  deriv.tol = 1e-04,
  deriv.iter = 1000,
  warn = TRUE,
  notes = getFixest_notes(),
  combine.quick,
  mem.clean = FALSE,
  only.env = FALSE,
  only.coef = FALSE,
  data.save = FALSE,
  env,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fml</code></td>
<td>
<p>A formula. This formula gives the linear formula to be estimated
(it is similar to a <code>lm</code> formula), for example: <code>fml = z~x+y</code>. To include
fixed-effects variables, insert them in this formula using a pipe
(e.g. <code>fml = z~x+y|fixef_1+fixef_2</code>). To include a non-linear in parameters element,
you must use the argment <code>NL.fml</code>. Multiple estimations can be performed at once:
for multiple dep. vars, wrap them in <code>c()</code>: ex <code>c(y1, y2)</code>. For multiple indep.
vars, use the stepwise functions: ex <code>x1 + csw(x2, x3)</code>. This leads to 6 estimation
<code>fml = c(y1, y2) ~ x1 + cw0(x2, x3)</code>. See details. Square brackets starting with a
dot can be used to call global variables: <code>y.[i] ~ x.[1:2]</code> will lead to
<code>y3 ~ x1 + x2</code> if <code>i</code> is equal to 3 in the current environment (see details in <code>xpd</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model.
The variables of the non-linear right hand side of the formula are identified
with this <code>data.frame</code> names. Can also be a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Character scalar. It should provide the family. The possible values
are "poisson" (Poisson model with log-link, the default), "negbin" (Negative Binomial
model with log-link), "logit" (LOGIT model with log-link), "gaussian" (Gaussian model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.fml</code></td>
<td>
<p>A formula. If provided, this formula represents the non-linear part of
the right hand side (RHS). Note that contrary to the <code>fml</code> argument, the
coefficients must explicitly appear in this formula. For instance, it can be
<code>~a*log(b*x + c*x^3)</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are the coefficients to be estimated.
Note that only the RHS of the formula is to be provided, and NOT the left hand side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character
scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The
VCOV types implemented are: "iid", "hetero" (or "HC1"), "cluster", "twoway",
"NW" (or "newey_west"), "DK" (or "driscoll_kraay"), and "conley". It also accepts
object from <code>vcov_cluster</code>, <code>vcov_NW</code>, <code>NW</code>,
<code>vcov_DK</code>, <code>DK</code>, <code>vcov_conley</code> and
<code>conley</code>. It also accepts covariance matrices computed externally.
Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation
in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef</code></td>
<td>
<p>Character vector. The names of variables to be used as fixed-effects.
These variables should contain the identifier of each observation (e.g., think of it
as a panel identifier). Note that the recommended way to include fixed-effects is to
insert them directly in the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.rm</code></td>
<td>
<p>Can be equal to "perfect" (default), "singleton", "both" or "none".
Controls which observations are to be removed. If "perfect", then observations
having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations)
will be removed. If "singleton", all observations for which a fixed-effect appears
only once will be removed. Note, importantly, that singletons are removed in just one pass,
there is no recursivity implemented. The meaning of "both" and "none" is direct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.start</code></td>
<td>
<p>(For NL models only) A list of starting values for the non-linear parameters.
ALL the parameters are to be named and given a staring value.
Example: <code>NL.start=list(a=1,b=5,c=0)</code>. Though, there is an exception: if all
parameters are to be given the same starting value, you can use a numeric scalar.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>(For NL models only) A list. The lower bound for each of the non-linear
parameters that requires one. Example: <code>lower=list(b=0,c=0)</code>. Beware, if the estimated
parameter is at his lower bound, then asymptotic theory cannot be applied and the
standard-error of the parameter cannot be estimated because the gradient will
not be null. In other words, when at its upper/lower bound, the parameter is
considered as 'fixed'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>(For NL models only) A list. The upper bound for each of the non-linear
parameters that requires one. Example: <code>upper=list(a=10,c=50)</code>. Beware, if the
estimated parameter is at his upper bound, then asymptotic theory cannot be applied
and the standard-error of the parameter cannot be estimated because the gradient
will not be null. In other words, when at its upper/lower bound, the parameter
is considered as 'fixed'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.start.init</code></td>
<td>
<p>(For NL models only) Numeric scalar. If the argument <code>NL.start</code>
is not provided, or only partially filled (i.e. there remain non-linear parameters
with no starting value), then the starting value of all remaining non-linear parameters
is set to <code>NL.start.init</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A formula or a numeric vector. An offset can be added to the estimation.
If equal to a formula, it should be of the form (for example) <code>~0.5*x**2</code>. This
offset is linearly added to the elements of the main formula 'fml'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>A vector (logical or numeric) or a one-sided formula. If provided,
then the estimation will be performed only on the observations defined by this argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>split = ~var</code>) or a vector.
If provided, the sample is split according to the variable and one estimation is performed
for each value of that variable. If you also want to include the estimation for the
full sample, use the argument <code>fsplit</code> instead. You can use the special operators
<code style="white-space: pre;">⁠%keep%⁠</code> and <code style="white-space: pre;">⁠%drop%⁠</code> to select only a subset of values for which to split the
sample. E.g. <code>split = ~var %keep% c("v1", "v2")</code> will split the sample only according
to the values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the
argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value,
you can trigger a regular expression evaluation by adding a <code>'@'</code> first,
as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code> or
<code>"v2"</code> (of course you need to know regexes!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fsplit</code></td>
<td>
<p>A one sided formula representing a variable (eg <code>fsplit = ~var</code>) or a vector.
If provided, the sample is split according to the variable and one estimation is performed
for each value of that variable. This argument is the same as <code>split</code> but also includes the
full sample as the first estimation. You can use the special operators <code style="white-space: pre;">⁠%keep%⁠</code> and <code style="white-space: pre;">⁠%drop%⁠</code>
to select only a subset of values for which to split the sample.
E.g. <code>fsplit = ~var %keep% c("v1", "v2")</code> will split the sample only according to the
values <code>v1</code> and <code>v2</code> of the variable <code>var</code>; it is equivalent to supplying the
argument <code>split.keep = c("v1", "v2")</code>. By default there is partial matching on each value,
you can trigger a regular expression evaluation by adding an <code>'@'</code> first,
as in: <code>~var %drop% "@^v[12]"</code> which will drop values starting with <code>"v1"</code>
or <code>"v2"</code> (of course you need to know regexes!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.keep</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied.
If provided, then the sample will be split only on the values of <code>split.keep</code>.
The values in <code>split.keep</code> will be partially matched to the values of <code>split</code>.
To enable regular expressions, you need to add an <code>'@'</code> first.
For example <code>split.keep = c("v1", "@other|var")</code> will keep only the value
in <code>split</code> partially matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.drop</code></td>
<td>
<p>A character vector. Only used when <code>split</code>, or <code>fsplit</code>, is supplied.
If provided, then the sample will be split only on the values that are not in <code>split.drop</code>.
The values in <code>split.drop</code> will be partially matched to the values of <code>split</code>.
To enable regular expressions, you need to add an <code>'@'</code> first. For example
<code>split.drop = c("v1", "@other|var")</code> will drop only the value in <code>split</code> partially
matched by <code>"v1"</code> or the values containing <code>"other"</code> or <code>"var"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested).
Can be either a list of vectors, a character vector of variable names, a formula or
an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code>
contained in the data.frame <code>base</code> used for the estimation. All the following
<code>cluster</code> arguments are valid and do the same thing:
<code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>.
If the two variables were used as fixed-effects in the estimation, you can leave it
blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was
the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with
the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed:
“standard”, “hetero”, “cluster”, “twoway”, “threeway”
or “fourway”? By default if there are clusters in the estimation:
<code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated,
you should use <code>vcov</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code>ssc</code>. Represents
how the degree of freedom correction should be done.You must use the function <code>ssc</code>
for this argument. The arguments and defaults of the function <code>ssc</code> are:
<code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>,
<code>t.df = "min"</code>, <code style="white-space: pre;">⁠fixef.force_exact=FALSE)⁠</code>. See the help of the function <code>ssc</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula
(e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2
(e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables
separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables
with <code>^</code> only inside formulas (see the dedicated section in <code>feols</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Starting values for the coefficients in the linear part (for the non-linear
part, use NL.start). Can be: i) a numeric of length 1 (e.g. <code>start = 0</code>, the default),
ii) a numeric vector of the exact same length as the number of variables, or iii) a
named vector of any length (the names will be used to initialize the appropriate coefficients).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jacobian.method</code></td>
<td>
<p>(For NL models only) Character scalar. Provides the method
used to numerically compute the Jacobian of the non-linear part.
Can be either <code>"simple"</code> or <code>"Richardson"</code>. Default is <code>"simple"</code>.
See the help of <code>jacobian</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useHessian</code></td>
<td>
<p>Logical. Should the Hessian be computed in the optimization stage?
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian.args</code></td>
<td>
<p>List of arguments to be passed to function <code>genD</code>.
Defaults is missing. Only used with the presence of <code>NL.fml</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.control</code></td>
<td>
<p>List of elements to be passed to the optimization method <code>nlminb</code>.
See the help page of <code>nlminb</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to,
the maximum number of threads; b) 0: meaning all available threads will be used;
c) a number strictly between 0 and 1 which represents the fraction of all threads to use.
The default is to use 50% of all threads. You can set permanently the number
of threads used within this package using the function <code>setFixest_nthreads</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed
from the returned result: this will save memory but will block the possibility to
use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to
obtain the appropriate standard-errors at estimation time, since obtaining different
SEs won't be possible afterwards.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Integer, default is 0. It represents the level of information that
should be reported during the optimisation process. If <code>verbose=0</code>:
nothing is reported. If <code>verbose=1</code>: the value of the coefficients and the
likelihood are reported. If <code>verbose=2</code>: <code>1</code> + information on the computing time of
the null model, the fixed-effects coefficients and the hessian are reported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.init</code></td>
<td>
<p>Positive numeric scalar. The starting value of the dispersion
parameter if <code>family="negbin"</code>. By default, the algorithm uses as a starting value
the theta obtained from the model with only the intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>.
It corresponds to the maximum absolute difference allowed between two coefficients
of successive iterations. Argument <code>fixef.tol</code> cannot be lower
than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically
controlled by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm
(only in use for 2+ fixed-effects). Default is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects derivatives. Defaults to <code>1e-4</code>.
It corresponds to the maximum absolute difference allowed between two coefficients of
successive iterations. Argument <code>deriv.tol</code> cannot be lower than <code>10000*.Machine$double.eps</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deriv.iter</code></td>
<td>
<p>Maximum number of iterations in the algorithm to obtain the derivative
of the fixed-effects (only in use for 2+ fixed-effects). Default is 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed
(concerns warnings relating to convergence state).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notes</code></td>
<td>
<p>Logical. By default, two notes are displayed: when NAs are removed
(to show additional information) and when some observations are removed because
of only 0 (or 0/1) outcomes in a fixed-effect setup (in Poisson/Neg. Bin./Logit models).
To avoid displaying these messages, you can set <code>notes = FALSE</code>. You can
remove these messages permanently by using <code>setFixest_notes(FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them
into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>.
The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>.
Because pasting variables is a costly operation, the internal algorithm may use a
numerical trick to hasten the process. The cost of doing so is that you lose the labels.
If you are interested in getting the value of the fixed-effects coefficients
after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is
equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code>
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is
large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as
much as possible and <code>gc</code> is run before each substantial C++ section in the internal
code to avoid memory issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.env</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only
the environment used to make the estimation is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.coef</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then only the estimated
coefficients are returned. Note that the length of the vector returned is always
the length of the number of coefficients to be estimated: this means that the
variables found to be collinear are returned with an NA value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.save</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, the data used for
the estimation is saved within the returned object. Hence later calls to predict(),
vcov(), etc..., will be consistent even if the original data has been modified
in the meantime.
This is especially useful for estimations within loops, where the data changes
at each iteration, such that postprocessing can be done outside the loop without issue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>(Advanced users.) A <code>fixest</code> environment created by a <code>fixest</code> estimation
with <code>only.env = TRUE</code>. Default is missing. If provided, the data from this environment
will be used to perform the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function estimates maximum likelihood models where the conditional expectations
are as follows:
</p>
<p>Gaussian likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=X\beta</code>
</p>

<p>Poisson and Negative Binomial likelihoods:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\exp(X\beta)</code>
</p>

<p>where in the Negative Binomial there is the parameter <code class="reqn">\theta</code> used to
model the variance as <code class="reqn">\mu+\mu^2/\theta</code>, with <code class="reqn">\mu</code> the
conditional expectation.
Logit likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\frac{\exp(X\beta)}{1+\exp(X\beta)}</code>
</p>

<p>When there are one or more fixed-effects, the conditional expectation can be written as:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X) = h(X\beta+\sum_{k}\sum_{m}\gamma_{m}^{k}\times C_{im}^{k}),</code>
</p>

<p>where <code class="reqn">h(.)</code> is the function corresponding to the likelihood function as shown before.
<code class="reqn">C^k</code> is the matrix associated to fixed-effect dimension <code class="reqn">k</code> such that <code class="reqn">C^k_{im}</code>
is equal to 1 if observation <code class="reqn">i</code> is of category <code class="reqn">m</code> in the
fixed-effect dimension <code class="reqn">k</code> and 0 otherwise.
</p>
<p>When there are non linear in parameters functions, we can schematically split
the set of regressors in two:
</p>
<p style="text-align: center;"><code class="reqn">f(X,\beta)=X^1\beta^1 + g(X^2,\beta^2)</code>
</p>

<p>with first a linear term and then a non linear part expressed by the function g. That is,
we add a non-linear term to the linear terms (which are <code class="reqn">X*beta</code> and
the fixed-effects coefficients). It is always better (more efficient) to put
into the argument <code>NL.fml</code> only the non-linear in parameter terms, and
add all linear terms in the <code>fml</code> argument.
</p>
<p>To estimate only a non-linear formula without even the intercept, you must
exclude the intercept from the linear formula by using, e.g., <code>fml = z~0</code>.
</p>
<p>The over-dispersion parameter of the Negative Binomial family, theta,
is capped at 10,000. If theta reaches this high value, it means that there is no overdispersion.
</p>


<h3>Value</h3>

<p>A <code>fixest</code> object. Note that <code>fixest</code> objects contain many elements and most of them
are for internal use, they are presented here only for information. To access them,
it is safer to use the user-level methods (e.g. <code>vcov.fixest</code>, <code>resid.fixest</code>,
etc) or functions (like for instance <code>fitstat</code> to access any fit statistic).
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>The named vector of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors,
z-values and p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>The loglikelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>Number of iterations of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs</code></td>
<td>
<p>The number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nparams</code></td>
<td>
<p>The number of parameters of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fml_all</code></td>
<td>
<p>A list containing different parts of the formula. Always contain
the linear formula. Then, if relevant: <code>fixef</code>: the fixed-effects; <code>NL</code>: the non linear
part of the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll_null</code></td>
<td>
<p>Log-likelihood of the null model (i.e. with the intercept only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo_r2</code></td>
<td>
<p>The adjusted pseudo R2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>The convergence message from the optimization procedures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected
predictor (i.e. fitted.values) obtained by the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>The fitted values are the expected value of the dependent variable
for the fitted model: that is <code class="reqn">E(Y|X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.iid</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The ML family that was used for the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The original data set used when calling the function. Only available when
the estimation was called with <code>data.save = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>The offset formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.fml</code></td>
<td>
<p>The nonlinear formula of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Whether the coefficients were upper or lower bounded. – This can only be
the case when a non-linear formula is included and the arguments 'lower' or 'upper'
are provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isBounded</code></td>
<td>
<p>The logical vector that gives for each coefficient whether it was
bounded or not. This can only be the case when a non-linear formula is included
and the arguments 'lower' or 'upper' are provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef_vars</code></td>
<td>
<p>The names of each fixed-effect dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef_id</code></td>
<td>
<p>The list (of length the number of fixed-effects) of the
fixed-effects identifiers for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef_sizes</code></td>
<td>
<p>The size of each fixed-effect (i.e. the number of unique
identifier for each fixed-effect dimension).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs_selection</code></td>
<td>
<p>(When relevant.) List containing vectors of integers. It
represents the sequential selection of observation vis a vis the original data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef_removed</code></td>
<td>
<p>In the case there were fixed-effects and some observations
were removed because of only 0/1 outcome within a fixed-effect, it gives the
list (for each fixed-effect dimension) of the fixed-effect identifiers that were removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>In the case of a negative binomial estimation: the overdispersion parameter.</p>
</td>
</tr>
</table>
<p>@seealso
See also <code>summary.fixest</code> to see the results with the appropriate standard-errors,
<code>fixef.fixest</code> to extract the fixed-effects coefficients, and the function <code>etable</code>
to visualize the results of multiple estimations.
</p>
<p>And other estimation methods: <code>feols</code>, <code>femlm</code>, <code>feglm</code>,
<code>fepois</code>, <code>fenegbin</code>.
</p>


<h3>Lagging variables</h3>

<p>To use leads/lags of variables in the estimation, you can: i) either provide the argument
<code>panel.id</code>, ii) either set your data set as a panel with the function
<code>panel</code>, <code>f</code> and <code>d</code>.
</p>
<p>You can provide several leads/lags/differences at once: e.g. if your formula is equal to
<code>f(y) ~ l(x, -1:1)</code>, it means that the dependent variable is equal to the lead of <code>y</code>,
and you will have as explanatory variables the lead of <code>x1</code>, <code>x1</code> and the lag of <code>x1</code>.
See the examples in function <code>l</code> for more details.
</p>


<h3>Interactions</h3>

<p>You can interact a numeric variable with a "factor-like" variable by using
<code>i(factor_var, continuous_var, ref)</code>, where <code>continuous_var</code> will be interacted with
each value of <code>factor_var</code> and the argument <code>ref</code> is a value of <code>factor_var</code>
taken as a reference (optional).
</p>
<p>Using this specific way to create interactions leads to a different display of the
interacted values in <code>etable</code>. See examples.
</p>
<p>It is important to note that <em>if you do not care about the standard-errors of
the interactions</em>, then you can add interactions in the fixed-effects part of the formula,
it will be incomparably faster (using the syntax <code>factor_var[continuous_var]</code>, as explained
in the section “Varying slopes”).
</p>
<p>The function <code>i</code> has in fact more arguments, please see details in its associated help page.
</p>


<h3>On standard-errors</h3>

<p>Standard-errors can be computed in different ways, you can use the arguments <code>se</code> and <code>ssc</code>
in <code>summary.fixest</code> to define how to compute them. By default, in the presence
of fixed-effects, standard-errors are automatically clustered.
</p>
<p>The following vignette: <a href="https://lrberge.github.io/fixest/articles/standard_errors.html">On standard-errors</a> describes in details how the standard-errors are computed in
<code>fixest</code> and how you can replicate standard-errors from other software.
</p>
<p>You can use the functions <code>setFixest_vcov</code> and <code>setFixest_ssc</code> to
permanently set the way the standard-errors are computed.
</p>


<h3>Multiple estimations</h3>

<p>Multiple estimations can be performed at once, they just have to be specified in the formula.
Multiple estimations yield a <code>fixest_multi</code> object which is ‘kind of’ a list of
all the results but includes specific methods to access the results in a handy way.
Please have a look at the dedicated vignette:
<a href="https://lrberge.github.io/fixest/articles/multiple_estimations.html">Multiple estimations</a>.
</p>
<p>To include multiple dependent variables, wrap them in <code>c()</code> (<code>list()</code> also works).
For instance <code>fml = c(y1, y2) ~ x1</code> would estimate the model <code>fml = y1 ~ x1</code> and
then the model <code>fml = y2 ~ x1</code>.
</p>
<p>To include multiple independent variables, you need to use the stepwise functions.
There are 4 stepwise functions: <code>sw</code>, <code>sw0</code>, <code>csw</code>, <code>csw0</code>, and <code>mvsw</code>. Of course <code>sw</code>
stands for stepwise, and <code>csw</code> for cumulative stepwise. Finally <code>mvsw</code> is a bit special,
it stands for multiverse stepwise. Let's explain that.
Assume you have the following formula: <code>fml = y ~ x1 + sw(x2, x3)</code>.
The stepwise function <code>sw</code> will estimate the following two models: <code>y ~ x1 + x2</code> and
<code>y ~ x1 + x3</code>. That is, each element in <code>sw()</code> is sequentially, and separately,
added to the formula. Would have you used <code>sw0</code> in lieu of <code>sw</code>, then the model
<code>y ~ x1</code> would also have been estimated. The <code>0</code> in the name means that the model
without any stepwise element also needs to be estimated.
The prefix <code>c</code> means cumulative: each stepwise element is added to the next. That is,
<code>fml = y ~ x1 + csw(x2, x3)</code> would lead to the following models <code>y ~ x1 + x2</code> and
<code>y ~ x1 + x2 + x3</code>. The <code>0</code> has the same meaning and would also lead to the model without
the stepwise elements to be estimated: in other words, <code>fml = y ~ x1 + csw0(x2, x3)</code>
leads to the following three models: <code>y ~ x1</code>, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x2 + x3</code>.
Finally <code>mvsw</code> will add, in a stepwise fashion all possible combinations of the variables
in its arguments. For example <code>mvsw(x1, x2, x3)</code> is equivalent to
<code>sw0(x1, x2, x3, x1 + x2, x1 + x3, x2 + x3, x1 + x2 + x3)</code>. The number of models
to estimate grows at a factorial rate: so be cautious!
</p>
<p>Multiple independent variables can be combined with multiple dependent variables, as in
<code>fml = c(y1, y2) ~ cw(x1, x2, x3)</code> which would lead to 6 estimations. Multiple
estimations can also be combined to split samples (with the arguments <code>split</code>, <code>fsplit</code>).
</p>
<p>You can also add fixed-effects in a stepwise fashion. Note that you cannot perform
stepwise estimations on the IV part of the formula (<code>feols</code> only).
</p>
<p>If NAs are present in the sample, to avoid too many messages, only NA removal
concerning the variables common to all estimations is reported.
</p>
<p>A note on performance. The feature of multiple estimations has been highly optimized for
<code>feols</code>, in particular in the presence of fixed-effects. It is faster to estimate
multiple models using the formula rather than with a loop. For non-<code>feols</code> models using
the formula is roughly similar to using a loop performance-wise.
</p>


<h3>Argument sliding</h3>

<p>When the data set has been set up globally using
<code>setFixest_estimation</code><code>(data = data_set)</code>, the argument <code>vcov</code> can be used implicitly.
This means that calls such as <code>feols(y ~ x, "HC1")</code>, or <code>feols(y ~ x, ~id)</code>, are valid:
i) the data is automatically deduced from the global settings, and ii) the <code>vcov</code>
is deduced to be the second argument.
</p>


<h3>Piping</h3>

<p>Although the argument 'data' is placed in second position, the data can be piped to the
estimation functions. For example, with R &gt;= 4.1, <code>mtcars |&gt; feols(mpg ~ cyl)</code> works as
<code>feols(mpg ~ cyl, mtcars)</code>.
</p>


<h3>Tricks to estimate multiple LHS</h3>

<p>To use multiple dependent variables in <code>fixest</code> estimations, you need to include them
in a vector: like in <code>c(y1, y2, y3)</code>.
</p>
<p>First, if names are stored in a vector, they can readily be inserted in a formula to
perform multiple estimations using the dot square bracket operator. For instance if
<code>my_lhs = c("y1", "y2")</code>, calling <code>fixest</code> with, say <code>feols(.[my_lhs] ~ x1, etc)</code> is
equivalent to using <code>feols(c(y1, y2) ~ x1, etc)</code>. Beware that this is a special feature
unique to the <em>left-hand-side</em> of <code>fixest</code> estimations (the default behavior of the DSB
operator is to aggregate with sums, see <code>xpd</code>).
</p>
<p>Second, you can use a regular expression to grep the left-hand-sides on the fly. When the
<code>..("regex")</code> feature is used naked on the LHS, the variables grepped are inserted into
<code>c()</code>. For example <code style="white-space: pre;">⁠..("Pe") ~ Sepal.Length, iris⁠</code> is equivalent to
<code style="white-space: pre;">⁠c(Petal.Length, Petal.Width) ~ Sepal.Length, iris⁠</code>. Beware that this is a
special feature unique to the <em>left-hand-side</em> of <code>fixest</code> estimations
(the default behavior of <code>..("regex")</code> is to aggregate with sums, see <code>xpd</code>).
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once,
or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use
<code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example:
<code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the
value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way:
<code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in
character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the
character form is important to avoid a formula parsing error. Double quotes must be used. Note
that the character string that is nested will be parsed with the function <code>dsb</code>, and thus it
will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>,
to expand with commas–the content can then be used within functions. For instance:
<code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then
<code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting
is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create
<code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code>dsb</code>,
which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is
replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">⁠x = "" ; xpd(y ~ .[x])⁠</code> leads to
<code>y ~ 1</code>.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, "Efficient estimation of maximum likelihood models with
multiple fixed-effects: the R package FENmlm." CREA Discussion Papers,
13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf"></a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, "OLS with multiple high dimensional category variables",
Computational Statistics &amp; Data Analysis 66 pp. 8–18
</p>
<p>On the unconditionnal Negative Binomial model:
</p>
<p>Allison, Paul D and Waterman, Richard P, 2002, "Fixed-Effects Negative
Binomial Regression Models", Sociological Methodology 32(1) pp. 247–265
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# This section covers only non-linear in parameters examples
# For linear relationships: use femlm or feglm instead

# Generating data for a simple example
set.seed(1)
n = 100
x = rnorm(n, 1, 5)**2
y = rnorm(n, -1, 5)**2
z1 = rpois(n, x*y) + rpois(n, 2)
base = data.frame(x, y, z1)

# Estimating a 'linear' relation:
est1_L = femlm(z1 ~ log(x) + log(y), base)
# Estimating the same 'linear' relation using a 'non-linear' call
est1_NL = feNmlm(z1 ~ 1, base, NL.fml = ~a*log(x)+b*log(y), NL.start = list(a=0, b=0))
# we compare the estimates with the function esttable (they are identical)
etable(est1_L, est1_NL)

# Now generating a non-linear relation (E(z2) = x + y + 1):
z2 = rpois(n, x + y) + rpois(n, 1)
base$z2 = z2

# Estimation using this non-linear form
est2_NL = feNmlm(z2 ~ 0, base, NL.fml = ~log(a*x + b*y),
               NL.start = 2, lower = list(a=0, b=0))
# we can't estimate this relation linearily
# =&gt; closest we can do:
est2_L = femlm(z2 ~ log(x) + log(y), base)

# Difference between the two models:
etable(est2_L, est2_NL)

# Plotting the fits:
plot(x, z2, pch = 18)
points(x, fitted(est2_L), col = 2, pch = 1)
points(x, fitted(est2_NL), col = 4, pch = 2)


</code></pre>


</div>