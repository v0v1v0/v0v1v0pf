<div class="container">

<table style="width: 100%;"><tr>
<td>fetch_hold</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fetches the Hold Status UI Element Supplied</h2>

<h3>Description</h3>

<p>When some buttons are clicked they will change the state of the
system, but other UI components will not detect that change correctly. So those
triggers are put on hold. This will fetch hold status for a specified inputId
</p>


<h3>Usage</h3>

<pre><code class="language-R">fetch_hold(state, inputId = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>module state with all of the current ui elements populated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputId</code></td>
<td>
<p>The input ID of the UI element that was put on hold</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Boolean value with the hold status
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Within shiny both session and input variables will exist, 
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# For this example we also need a state variable
state = sess_res$state

# This sets a hold on the specified inputID. This is normally done in 
# your XX_fetch_state() function.
state = set_hold(state, inputId = "select_dw_views")

# This will fetch the hold status of the specified inputID. 
fetch_hold(state, inputId = "select_dw_views")

# This will remove the hold and is normally done in one of the UI outputs
# with a priority set to ensure it happens after the rest of the UI has
# refreshed.
state = remove_hold(state, session, inputId = "select_dw_views")
</code></pre>


</div>