<div class="container">

<table style="width: 100%;"><tr>
<td>future_apply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply Functions Over Array Margins via Futures</h2>

<h3>Description</h3>

<p><code>future_apply()</code> implements <code>base::apply()</code> using future with perfect
replication of results, regardless of future backend used.
It returns a vector or array or list of values obtained by applying a
function to margins of an array or matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">future_apply(
  X,
  MARGIN,
  FUN,
  ...,
  simplify = TRUE,
  future.envir = parent.frame(),
  future.stdout = TRUE,
  future.conditions = "condition",
  future.globals = TRUE,
  future.packages = NULL,
  future.seed = FALSE,
  future.scheduling = 1,
  future.chunk.size = NULL,
  future.label = "future_apply-%d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an array, including a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MARGIN</code></td>
<td>
<p>A vector giving the subscripts which the function will be
applied over. For example, for a matrix <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows and columns.
Where <code>X</code> has named dimnames, it can be a character vector selecting
dimension names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function taking at least one argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>a logical indicating whether results should be simplified
if possible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.envir</code></td>
<td>
<p>An environment passed as argument <code>envir</code> to
<code>future::future()</code> as-is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.stdout</code></td>
<td>
<p>If <code>TRUE</code> (default), then the standard output of the
underlying futures is captured, and re-outputted as soon as possible.
If <code>FALSE</code>, any output is silenced (by sinking it to the null device
as it is outputted).
If <code>NA</code> (not recommended), output is <em>not</em> intercepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.conditions</code></td>
<td>
<p>A character string of conditions classes to be
captured and relayed.  The default is the same as the <code>condition</code>
argument of <code>future::Future()</code>.
To not intercept conditions, use <code>conditions = character(0L)</code>.
Errors are always relayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.globals</code></td>
<td>
<p>A logical, a character vector, or a named list for
controlling how globals are handled. For details, see below section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the R environment evaluating the future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven),
or a list of <code>length(X)</code> with pre-generated random seeds.
For details, see below section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.scheduling</code></td>
<td>
<p>Average number of futures ("chunks") per worker.
If <code>0.0</code>, then a single future is used to process all elements
of <code>X</code>.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures
(if there are enough elements in <code>X</code>).
If <code>Inf</code> or <code>FALSE</code>, then one future per element of
<code>X</code> is used.
Only used if <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.chunk.size</code></td>
<td>
<p>The average number of elements per future ("chunk").
If <code>Inf</code>, then all elements are processed in a single future.
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.label</code></td>
<td>
<p>If a character string, then each future is assigned
a label <code>sprintf(future.label, chunk_idx)</code>.  If TRUE, then the
same as <code>future.label = "future_lapply-%d"</code>.  If FALSE, no labels
are assigned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) Additional arguments passed to <code>FUN()</code>, except
<code style="white-space: pre;">⁠future.*⁠</code> arguments, which are passed on to <code>future_lapply()</code> used
internally.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a vector or array or list of values obtained by applying a
function to margins of an array or matrix.
See <code>base::apply()</code> for details.
</p>


<h3>Author(s)</h3>

<p>The implementations of <code>future_apply()</code> is adopted from the source code
of the corresponding base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function, which is licensed under GPL (&gt;= 2)
with 'The R Core Team' as the copyright holder.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ---------------------------------------------------------
## apply()
## ---------------------------------------------------------
X &lt;- matrix(c(1:4, 1, 6:8), nrow = 2L)

Y0 &lt;- apply(X, MARGIN = 1L, FUN = table)
Y1 &lt;- future_apply(X, MARGIN = 1L, FUN = table)
print(Y1)
stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME

Y0 &lt;- apply(X, MARGIN = 1L, FUN = stats::quantile)
Y1 &lt;- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
print(Y1)
stopifnot(all.equal(Y1, Y0))


## ---------------------------------------------------------
## Parallel Random Number Generation
## ---------------------------------------------------------

## Regardless of the future plan, the number of workers, and
## where they are, the random numbers produced are identical

X &lt;- matrix(c(1:4, 1, 6:8), nrow = 2L)

plan(multisession)
set.seed(0xBEEF)
Y1 &lt;- future_apply(X, MARGIN = 1L, FUN = sample, future.seed = TRUE)
print(Y1)

plan(sequential)
set.seed(0xBEEF)
Y2 &lt;- future_apply(X, MARGIN = 1L, FUN = sample, future.seed = TRUE)
print(Y2)

stopifnot(all.equal(Y1, Y2))



</code></pre>


</div>