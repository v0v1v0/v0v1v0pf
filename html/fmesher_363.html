<div class="container">

<table style="width: 100%;"><tr>
<td>fm_segm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make a spatial segment object</h2>

<h3>Description</h3>

<p>Make a spatial segment object
</p>


<h3>Usage</h3>

<pre><code class="language-R">fm_segm(...)

## Default S3 method:
fm_segm(loc = NULL, idx = NULL, grp = NULL, is.bnd = TRUE, crs = NULL, ...)

## S3 method for class 'fm_segm'
fm_segm(..., grp = NULL, grp.default = 0L, is.bnd = NULL)

## S3 method for class 'fm_segm_list'
fm_segm(x, grp = NULL, grp.default = 0L, ...)

fm_segm_join(x, grp = NULL, grp.default = 0L, is.bnd = NULL)

fm_segm_split(x, grp = NULL, grp.default = 0L)

## S3 method for class 'inla.mesh.segment'
fm_segm(..., grp.default = 0)

## S3 method for class 'inla.mesh'
fm_segm(x, ...)

## S3 method for class 'fm_mesh_2d'
fm_segm(x, boundary = TRUE, grp = NULL, ...)

fm_is_bnd(x)

fm_is_bnd(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Passed on to submethods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>Matrix of point locations, or <code>SpatialPoints</code>, or <code>sf</code>/<code>sfc</code> point
object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idx</code></td>
<td>
<p>Segment index sequence vector or index pair matrix.  The indices
refer to the rows of <code>loc</code>.  If <code>loc==NULL</code>, the indices will be
interpreted as indices into the point specification supplied to
<code>fm_rcdt_2d()</code>.  If <code>is.bnd==TRUE</code>, defaults to linking
all the points in <code>loc</code>, as <code>c(1:nrow(loc),1L)</code>, otherwise
<code>1:nrow(loc)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grp</code></td>
<td>
<p>When joining segments, use these group labels for segments
instead of the original group labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>is.bnd</code></td>
<td>
<p><code>TRUE</code> if the segments are boundary segments, otherwise
<code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>An optional <code>fm_crs()</code>, <code>sf::st_crs()</code> or <code>sp::CRS()</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grp.default</code></td>
<td>
<p>If <code>grp.default</code> is <code>NULL</code>, use these group labels for segments
with NULL group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Mesh to extract segments from</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>logical; if <code>TRUE</code>, extract the boundary segments,
otherwise interior constrain segments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>logical</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>fm_segm</code> or <code>fm_segm_list</code> object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>fm_segm(fm_segm)</code>: Join multiple <code>fm_segm</code> objects into a single <code>fm_segm</code>
object. If <code>is.bnd</code> is non-NULL, it overrides the input segment information.
Otherwise, it checks if the inputs are consistent.
</p>
</li>
<li> <p><code>fm_segm(fm_segm_list)</code>: Join <code>fm_segm</code> objects from a <code>fm_segm_list</code> into
a single <code>fm_segm</code> object. Equivalent to <code>fm_segm_join(x)</code>
</p>
</li>
<li> <p><code>fm_segm(fm_mesh_2d)</code>: Extract the boundary or interior segments of a 2d mesh.
If <code>grp</code> is non-NULL, extracts only segments matching the matching the set
of groups given by <code>grp</code>.
</p>
</li>
</ul>
<h3>Functions</h3>


<ul>
<li> <p><code>fm_segm()</code>: Create a new <code>fm_segm</code> object.
</p>
</li>
<li> <p><code>fm_segm_join()</code>: Join multiple <code>fm_segm</code> objects into a single <code>fm_segm</code>
object. If <code>is.bnd</code> is non-NULL, it overrides the segment information.
Otherwise it checks for consistency.
</p>
</li>
<li> <p><code>fm_segm_split()</code>: Split an <code>fm_segm</code> object by <code>grp</code> into an <code>fm_segm_list</code>
object, optionally keeping only some groups.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other object creation and conversion: 
<code>fm_as_fm()</code>,
<code>fm_as_lattice_2d()</code>,
<code>fm_as_mesh_1d()</code>,
<code>fm_as_mesh_2d()</code>,
<code>fm_as_segm()</code>,
<code>fm_as_sfc()</code>,
<code>fm_as_tensor()</code>,
<code>fm_lattice_2d()</code>,
<code>fm_mesh_1d()</code>,
<code>fm_mesh_2d()</code>,
<code>fm_simplify()</code>,
<code>fm_tensor()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = FALSE)
fm_segm(rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1)), is.bnd = TRUE)

fm_segm_join(fmexample$boundary_fm)

fm_segm(fmexample$mesh, boundary = TRUE)
fm_segm(fmexample$mesh, boundary = FALSE)

</code></pre>


</div>