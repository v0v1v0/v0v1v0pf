<div class="container">

<table style="width: 100%;"><tr>
<td>metric.DTW</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>DTW: Dynamic time warping</h2>

<h3>Description</h3>

<p>Computes distances time warping for functional data
</p>


<h3>Usage</h3>

<pre><code class="language-R">metric.DTW(fdata1, fdata2 = NULL, p = 2, w = min(ncol(fdata1), ncol(fdata2)))

metric.WDTW(
  fdata1,
  fdata2 = NULL,
  p = 2,
  w = min(ncol(fdata1), ncol(fdata2)),
  wmax = 1,
  g = 0.05
)

metric.TWED(fdata1, fdata2 = NULL, p = 2, lambda = 1, nu = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdata1</code></td>
<td>
<p>Functional data 1 or curve 1. If <code>fdata</code> class, the dimension of <code>fdata1$data</code> object is (<code>n1</code> x <code>m</code>), where <code>n1</code> is the number of curves and <code>m</code> are the points observed in each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fdata2</code></td>
<td>
<p>Functional data 2 or curve 2. If <code>fdata</code> class, the dimension of <code>fdata2$data</code> object is (<code>n2</code> x <code>m</code>), where <code>n2</code> is the number of curves and <code>m</code> are the points observed in each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Lp norm, by default it uses <code>p = 2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Vector of weights with length <code>m</code>, If <code>w = 1</code> approximates the metric Lp by Simpson's rule. By default it uses <code>w = 1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wmax</code></td>
<td>
<p><code>numeric</code> maximum value of weight, (1 by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p><code>numeric</code> <code>g=0</code> (constant), <code>0.05</code> (linear) by default, 0.25 <code>sigmoid</code>, 3 two weight values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p><code>numeric</code> lambda value (0 by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p><code>numeric</code> constant value, (0 by default)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Three optins:
</p>

<ul>
<li>
<p> DTW: Dynamic time warping
</p>
</li>
<li>
<p> WDTW: Weight Dynamic time warping
</p>
</li>
<li>
<p> TWED: twed   
</p>
</li>
</ul>
<h3>Value</h3>

<p>DTW matrix
</p>


<h3>Author(s)</h3>

<p>Manuel Febrero-Bande, Manuel Oviedo de la Fuente <a href="mailto:manuel.oviedo@udc.es">manuel.oviedo@udc.es</a>
</p>


<h3>References</h3>

<p>Jeong, Y. S., Jeong, M. K., &amp; Omitaomu, O. A. (2011). Weighted dynamic time warping for 
time series classification. <em>Pattern Recognition</em>, 44(9), 2231-2240
</p>


<h3>See Also</h3>

<p>See also  <code>semimetric.basis</code> and <code>semimetric.NPFDA</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(tecator)
metric.DTW(tecator$absorp.fdata[1:4,])
ab=tecator[[1]]
D1=fda.usc:::DTW(ab$data[1,],ab$data[2,],p=2)
aa1=fda.usc:::findPath(D1$D)
D2=fda.usc:::DTW(ab$data[1,],ab$data[2,],p=2,w=5)
aa2=fda.usc:::findPath(D2$D)
D3=fda.usc:::WDTW(ab$data[1,],ab$data[2,],p=2,g=0.05) 
aa3=fda.usc:::findPath(D3$D)
D4=fda.usc:::TWED(ab$data[1,],ab$data[2,],p=2,lambda=0,nu=0)
aa4=fda.usc:::findPath(D4$D)
par(mfrow=c(2,2))
plot(c(ab[1:2]))
segments(ab$argvals[aa1[,1]],ab[1]$data[aa1[,1]],ab$argvals[aa1[,2]],ab[2]$data[aa1[,2]])
plot(c(ab[1:2]))
segments(ab$argvals[aa2[,1]],ab[1]$data[aa2[,1]],ab$argvals[aa2[,2]],ab[2]$data[aa2[,2]],col=2)
plot(c(ab[1:2]))
segments(ab$argvals[aa3[,1]],ab[1]$data[aa3[,1]],ab$argvals[aa3[,2]],ab[2]$data[aa3[,2]],col=3)
plot(c(ab[1:2]))
segments(ab$argvals[aa4[,1]],ab[1]$data[aa4[,1]],ab$argvals[aa4[,2]],ab[2]$data[aa4[,2]],col=4)

## End(Not run)

</code></pre>


</div>