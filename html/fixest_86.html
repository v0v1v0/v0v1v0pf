<div class="container">

<table style="width: 100%;"><tr>
<td>lag.formula</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lags a variable using a formula</h2>

<h3>Description</h3>

<p>Lags a variable using panel id + time identifiers in a formula.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'formula'
lag(
  x,
  k = 1,
  data,
  time.step = NULL,
  fill = NA,
  duplicate.method = c("none", "first"),
  ...
)

lag_fml(
  x,
  k = 1,
  data,
  time.step = NULL,
  fill = NA,
  duplicate.method = c("none", "first"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A formula of the type <code>var ~ id + time</code> where <code>var</code> is the variable to be lagged,
<code>id</code> is a variable representing the panel id, and <code>time</code> is the time variable of the panel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>An integer giving the number of lags. Default is 1. For leads,
just use a negative number.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Optional, the data.frame in which to evaluate the formula. If not provided,
variables will be fetched in the current environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.step</code></td>
<td>
<p>The method to compute the lags, default is <code>NULL</code> (which means
automatically set). Can be equal to: <code>"unitary"</code>, <code>"consecutive"</code>, <code>"within.consecutive"</code>,
or to a number. If <code>"unitary"</code>, then the largest common divisor between consecutive
time periods is used (typically if the time variable represents years, it will be 1).
This method can apply only to integer (or convertible to integer) variables.
If <code>"consecutive"</code>, then the time variable can be of any type: two successive
time periods represent a lag of 1. If <code>"witihn.consecutive"</code> then <strong>within a given id</strong>,
two successive time periods represent a lag of 1. Finally, if the time variable is numeric,
you can provide your own numeric time step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>Scalar. How to fill the observations without defined lead/lag values.
Default is <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>duplicate.method</code></td>
<td>
<p>If several observations have the same id and time values,
then the notion of lag is not defined for them. If <code>duplicate.method = "none"</code> (default)
and duplicate values are found, this leads to an error. You can use
<code>duplicate.method = "first"</code> so that the first occurrence of identical id/time
observations will be used as lag.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a vector of the same type and length as the variable to be lagged in the formula.
</p>


<h3>Functions</h3>


<ul><li> <p><code>lag_fml()</code>: Lags a variable using a formula syntax
</p>
</li></ul>
<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>Alternatively, the function <code>panel</code> changes a <code>data.frame</code> into a panel from which
the functions <code>l</code> and <code>f</code> (creating leads and lags) can be called. Otherwise you can set
the panel 'live' during the estimation using the argument <code>panel.id</code> (see for example in
the function <code>feols</code>).
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simple example with an unbalanced panel
base = data.frame(id = rep(1:2, each = 4),
                  time = c(1, 2, 3, 4, 1, 4, 6, 9), x = 1:8)

base$lag1 = lag(x~id+time,  1, base) # lag 1
base$lead1 = lag(x~id+time, -1, base) # lead 1
base$lag2_fill0 = lag(x~id+time, 2, base, fill = 0)
# with time.step = "consecutive"
base$lag1_consecutive = lag(x~id+time, 1, base, time.step = "consecutive")
#   =&gt; works for indiv. 2 because 9 (resp. 6) is consecutive to 6 (resp. 4)
base$lag1_within.consecutive = lag(x~id+time, 1, base, time.step = "within")
#   =&gt; now two consecutive years within each indiv is one lag

print(base)

# Argument time.step = "consecutive" is
# mostly useful when the time variable is not a number:
# e.g. c("1991q1", "1991q2", "1991q3") etc

# with duplicates
base_dup = data.frame(id = rep(1:2, each = 4),
                      time = c(1, 1, 1, 2, 1, 2, 2, 3), x = 1:8)

# Error because of duplicate values for (id, time)
try(lag(x~id+time, 1, base_dup))


# Error is bypassed, lag corresponds to first occurence of (id, time)
lag(x~id+time, 1, base_dup, duplicate.method = "first")


# Playing with time steps
base = data.frame(id = rep(1:2, each = 4),
                  time = c(1, 2, 3, 4, 1, 4, 6, 9), x = 1:8)

# time step: 0.5 (here equivalent to lag of 1)
lag(x~id+time, 2, base, time.step = 0.5)

# Error: wrong time step
try(lag(x~id+time, 2, base, time.step = 7))

# Adding NAs + unsorted IDs
base = data.frame(id = rep(1:2, each = 4),
                  time = c(4, NA, 3, 1, 2, NA, 1, 3), x = 1:8)

base$lag1 = lag(x~id+time, 1, base)
base$lag1_within = lag(x~id+time, 1, base, time.step = "w")
base_bis = base[order(base$id, base$time),]

print(base_bis)

# You can create variables without specifying the data within data.table:
if(require("data.table")){
  base = data.table(id = rep(1:2, each = 3), year = 1990 + rep(1:3, 2), x = 1:6)
  base[, x.l1 := lag(x~id+year, 1)]
}



</code></pre>


</div>