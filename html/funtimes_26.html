<div class="container">

<table style="width: 100%;"><tr>
<td>purity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Clustering Purity</h2>

<h3>Description</h3>

<p>Calculate the purity of the clustering results. For example, see
Schaeffer et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class="language-R">purity(classes, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>classes</code></td>
<td>
<p>a vector with labels of true classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>a vector with labels of assigned clusters for which purity is to
be tested. Should be of the same length as <code>classes</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Following Manning et al. (2008),
each cluster is assigned to the class which is most frequent in the cluster, then
</p>
<p style="text-align: center;"><code class="reqn">Purity(\Omega,C) = \frac{1}{N}\sum_{k}\max_{j}|\omega_k\cap c_j|,</code>
</p>

<p>where  <code class="reqn">\Omega=\{\omega_1,\ldots,\omega_K \}</code> is the set of identified
clusters and <code class="reqn">C=\{c_1,\ldots,c_J\}</code> is the set of classes. That is, within
each class <code class="reqn">j=1,\ldots,J</code> find the size of the most populous cluster from
the <code class="reqn">K-j</code> unassigned clusters. Then, sum together the <code class="reqn">\min(K,J)</code> sizes
found and divide by <code class="reqn">N</code>,
where <code class="reqn">N</code> = <code>length(classes)</code> = <code>length(clusters)</code>.
</p>
<p>If <code class="reqn">\max_{j}|\omega_k\cap c_j|</code> is not unique for some <code class="reqn">j</code>,
it is assigned to the class which the second maximum is the smallest, to
maximize the <code class="reqn">Purity</code> (see ‘Examples’).
</p>
<p>The number of unique elements
in <code>classes</code> and <code>clusters</code> may differ.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>pur</code></td>
<td>
<p>purity value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out</code></td>
<td>
<p>table with <code class="reqn">\min(K,J)</code> = <code>min(length(unique(classes)), 
length(unique(clusters)))</code> rows and the following columns:
<code>ClassLabels</code>, <code>ClusterLabels</code>, and <code>ClusterSize</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Vyacheslav Lyubchich
</p>


<h3>References</h3>

<p>Manning CD, Raghavan P, Schutze H (2008).
<em>Introduction to Information Retrieval</em>.
Cambridge University Press, New York.<br><br> Schaeffer ED, Testa JM, Gel YR, Lyubchich V (2016).
“On information criteria for dynamic spatio-temporal clustering.”
In Banerjee A, Ding W, Dy JG, Lyubchich V, Rhines A (eds.), <em>The 6th International Workshop on Climate Informatics: CI2016</em>, 5–8.
<a href="https://doi.org/10.5065/D6K072N6">doi:10.5065/D6K072N6</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Fix seed for reproducible simulations:
# RNGkind(sample.kind = "Rounding") #run this line to have same seed across R versions &gt; R 3.6.0
set.seed(1)

##### Example 1
#Create some classes and cluster labels:
classes &lt;- rep(LETTERS[1:3], each = 5)
clusters &lt;- sample(letters[1:5], length(classes), replace = TRUE)

#From the table below:
# - cluster 'b' corresponds to class A;
# - either of the clusters 'd' and 'e' can correspond to class B,
#   however, 'e' should be chosen, because cluster 'd' also highly 
#   intersects with Class C. Thus,
# - cluster 'd' corresponds to class C.
table(classes, clusters)
##       clusters
##classes a b c d e
##      A 0 3 1 0 1
##      B 1 0 0 2 2
##      C 1 2 0 2 0

#The function does this choice automatically:
purity(classes, clusters)

#Sample output:
##$pur
##[1] 0.4666667
##
##$out
##  ClassLabels ClusterLabels ClusterSize
##1           A             b           3
##2           B             e           2
##3           C             d           2


##### Example 2
#The labels can be also numeric:
classes &lt;- rep(1:5, each = 3)
clusters &lt;- sample(1:3, length(classes), replace = TRUE)
purity(classes, clusters)

</code></pre>


</div>