<div class="container">

<table style="width: 100%;"><tr>
<td>demean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Centers a set of variables around a set of factors</h2>

<h3>Description</h3>

<p>User-level access to internal demeaning algorithm of <code>fixest</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">demean(
  X,
  f,
  slope.vars,
  slope.flag,
  data,
  weights,
  nthreads = getFixest_nthreads(),
  notes = getFixest_notes(),
  iter = 2000,
  tol = 1e-06,
  fixef.reorder = TRUE,
  fixef.algo = NULL,
  na.rm = TRUE,
  as.matrix = is.atomic(X),
  im_confident = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A matrix, vector, data.frame or a list OR a formula OR a <code>feols</code> estimation. If equal
to a formula, then the argument <code>data</code> is required, and it must be of the type:
<code>x1 + x2 ~ f1 + fe2</code> with on the LHS the variables to be centered, and on the RHS the factors
used for centering. Note that you can use variables with varying slopes with the syntax
<code>fe[v1, v2]</code> (see details in <code>feols</code>). If a <code>feols</code> estimation, all variables (LHS+RHS) are
demeaned and then returned (only if it was estimated with fixed-effects). Otherwise, it must
represent the data to be centered. Of course the number of observations of that data must be the
same as the factors used for centering (argument <code>f</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A matrix, vector, data.frame or list. The factors used to center the variables in
argument <code>X</code>. Matrices will be coerced using <code>as.data.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope.vars</code></td>
<td>
<p>A vector, matrix or list representing the variables with varying slopes.
Matrices will be coerced using <code>as.data.frame</code>. Note that if this argument is used it MUST be in
conjunction with the argument <code>slope.flag</code> that maps the factors to which the varying slopes are
attached. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slope.flag</code></td>
<td>
<p>An integer vector of the same length as the number of variables in <code>f</code> (the
factors used for centering). It indicates for each factor the number of variables with varying
slopes to which it is associated. Positive values mean that the raw factor should also be
included in the centering, negative values that it should be excluded. Sorry it's complicated...
but see the examples it may get clearer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing all variables in the argument <code>X</code>. Only used if <code>X</code> is a
formula, in which case <code>data</code> is mandatory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Vector, can be missing or NULL. If present, it must contain the same number of
observations as in <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>Number of threads to be used. By default it is equal to <code>getFixest_nthreads()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notes</code></td>
<td>
<p>Logical, whether to display a message when NA values are removed. By default it is
equal to <code>getFixest_notes()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations, default is 2000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Stopping criterion of the algorithm. Default is <code>1e-6</code>. The algorithm stops when the
maximum absolute increase in the coefficients values is lower than <code>tol</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.reorder</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether to reorder the fixed-effects by
frequencies before feeding them into the algorithm. If <code>FALSE</code>, the original fixed-effects order
provided by the user is maintained. In general, reordering leads to faster and more precise
performance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.algo</code></td>
<td>
<p><code>NULL</code> (default) or an object of class <code>demeaning_algo</code> obtained with
the function <code>demeaning_algo</code>. If <code>NULL</code>, it falls to the defaults of <code>demeaning_algo</code>.
This arguments controls the settings of the demeaning algorithm.
Only play with it if the convergence is slow, i.e. look at the slot <code style="white-space: pre;">⁠$iterations⁠</code>, and if any is
over 50, it may be worth playing around with it. Please read the documentation of the
function <code>demeaning_algo</code>. Be aware that there is no clear guidance on how to change the
settings, it's more a matter of try-and-see.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If <code>TRUE</code> and the input data contains any NA value,
then any observation with NA will be discarded leading to an output with less observations than
the input. If <code>FALSE</code>, if NAs are present the output will also be filled with NAs for each NA
observation in input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.matrix</code></td>
<td>
<p>Logical, if <code>TRUE</code> a matrix is returned, if <code>FALSE</code> it will be a data.frame.
The default depends on the input, if atomic then a matrix will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>im_confident</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. FOR EXPERT USERS ONLY! This argument allows to
skip some of the preprocessing of the arguments given in input. If <code>TRUE</code>, then <code>X</code> MUST be a
numeric vector/matrix/list (not a formula!), <code>f</code> MUST be a list, <code>slope.vars</code> MUST be a list,
<code>slope.vars</code> MUST be consistent with <code>slope.flag</code>, and <code>weights</code>, if given, MUST be numeric (not
integer!). Further there MUST be not any NA value, and the number of observations of each
element MUST be consistent. Non compliance to these rules may simply lead your R session to
break.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a data.frame of the same number of columns as the number of variables to be centered.
</p>
<p>If <code>na.rm = TRUE</code>, then the number of rows is equal to the number of rows in input minus the
number of NA values (contained in <code>X</code>, <code>f</code>, <code>slope.vars</code> or <code>weights</code>). The default is to have
an output of the same number of observations as the input (filled with NAs where appropriate).
</p>
<p>A matrix can be returned if <code>as.matrix = TRUE</code>.
</p>


<h3>Varying slopes</h3>

<p>You can add variables with varying slopes in the fixed-effect part of the formula.
The syntax is as follows: <code>fixef_var[var1, var2]</code>. Here the variables var1 and var2 will
be with varying slopes (one slope per value in fixef_var) and the fixed-effect
fixef_var will also be added.
</p>
<p>To add only the variables with varying slopes and not the fixed-effect,
use double square brackets: <code>fixef_var[[var1, var2]]</code>.
</p>
<p>In other words:
</p>

<ul>
<li> <p><code>fixef_var[var1, var2]</code> is equivalent to <code>fixef_var + fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li>
<li> <p><code>fixef_var[[var1, var2]]</code> is equivalent to <code>fixef_var[[var1]] + fixef_var[[var2]]</code>
</p>
</li>
</ul>
<p>In general, for convergence reasons, it is recommended to always add the fixed-effect and
avoid using only the variable with varying slope (i.e. use single square brackets).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Illustration of the FWL theorem
data(trade)

base = trade
base$ln_dist = log(base$dist_km)
base$ln_euros = log(base$Euros)

# We center the two variables ln_dist and ln_euros
#  on the factors Origin and Destination
X_demean = demean(X = base[, c("ln_dist", "ln_euros")],
                  f = base[, c("Origin", "Destination")])
base[, c("ln_dist_dm", "ln_euros_dm")] = X_demean

est = feols(ln_euros_dm ~ ln_dist_dm, base)
est_fe = feols(ln_euros ~ ln_dist | Origin + Destination, base)

# The results are the same as if we used the two factors
# as fixed-effects
etable(est, est_fe, se = "st")

#
# Variables with varying slopes
#

# You can center on factors but also on variables with varying slopes

# Let's have an illustration
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

#
# We center y and x1 on species and x2 * species

# using a formula
base_dm = demean(y + x1 ~ species[x2], data = base)

# using vectors
base_dm_bis = demean(X = base[, c("y", "x1")], f = base$species,
                     slope.vars = base$x2, slope.flag = 1)

# Let's look at the equivalences
res_vs_1 = feols(y ~ x1 + species + x2:species, base)
res_vs_2 = feols(y ~ x1, base_dm)
res_vs_3 = feols(y ~ x1, base_dm_bis)

# only the small sample adj. differ in the SEs
etable(res_vs_1, res_vs_2, res_vs_3, keep = "x1")

#
# center on x2 * species and on another FE

base$fe = rep(1:5, 10)

# using a formula =&gt; double square brackets!
base_dm = demean(y + x1 ~ fe + species[[x2]], data = base)

# using vectors =&gt; note slope.flag!
base_dm_bis = demean(X = base[, c("y", "x1")], f = base[, c("fe", "species")],
                     slope.vars = base$x2, slope.flag = c(0, -1))

# Explanations slope.flag = c(0, -1):
# - the first 0: the first factor (fe) is associated to no variable
# - the "-1":
#    * |-1| = 1: the second factor (species) is associated to ONE variable
#    *   -1 &lt; 0: the second factor should not be included as such

# Let's look at the equivalences
res_vs_1 = feols(y ~ x1 + i(fe) + x2:species, base)
res_vs_2 = feols(y ~ x1, base_dm)
res_vs_3 = feols(y ~ x1, base_dm_bis)

# only the small sample adj. differ in the SEs
etable(res_vs_1, res_vs_2, res_vs_3, keep = "x1")




</code></pre>


</div>