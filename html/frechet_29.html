<div class="container">

<table style="width: 100%;"><tr>
<td>NetFIntegral</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Fréchet integrals of network</h2>

<h3>Description</h3>

<p>Calculating generalized Fréchet integrals of networks (equipped with Frobenius norm of adjacency matrices with zero diagonal elements and non negative off diagonal elements.)
</p>


<h3>Usage</h3>

<pre><code class="language-R">NetFIntegral(phi, t_out, X, U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>An eigenfunction along which we want to project the network</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_out</code></td>
<td>
<p>Support of <code>phi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A three dimensional array of dimension <code>length(t_out) x m x m</code>, where <code>X[i,,]</code> is an <code>m x m</code> network adjacency matrix. The diagonal elements of adjacency matrices are zero and the off diagonal entries lie between zero and <code>U</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Upper bound of off-diagonal entries</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of the following:
</p>
<table><tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>An adjacency matrix which corresponds to the Fréchet integral of <code>X</code> along <code>phi</code></p>
</td>
</tr></table>
<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2020). Functional models for time‐varying random objects. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 82(2), 275-327.</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(5)
n &lt;- 100
N &lt;- 50
t_out &lt;- seq(0,1,length.out = N)
library(mpoly)
p2 &lt;- as.function(mpoly::jacobi(2,4,3),silent=TRUE)
p4 &lt;- as.function(mpoly::jacobi(4,4,3),silent=TRUE)
p6 &lt;- as.function(mpoly::jacobi(6,4,3),silent=TRUE)

# first three eigenfunctions
phi1 &lt;- function(t){
p2(2*t-1)*t^(1.5)*(1-t)^2 / (integrate(function(x) p2(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}
phi2 &lt;- function(t){
p4(2*t-1)*t^(1.5)*(1-t)^2 / (integrate(function(x) p4(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}
phi3 &lt;- function(t){
p6(2*t-1)*t^(1.5)*(1-t)^2 / (integrate(function(x) p6(2*x-1)^2*x^(3)*(1-x)^4,0,1))$value^(1/2)
}

# random component of adjacency matrices
P12 &lt;- 0.1 ## edge between compunities
Score &lt;- matrix(runif(n*4), nrow = n)
# edge within first community
P1_vec &lt;- 0.5 + 0.4*Score[,1] %*% t(phi1(t_out)) + 0.1*Score[,2] %*% t(phi3(t_out)) 
# edge within second community
P2_vec &lt;- 0.5 + 0.3*Score[,3] %*% t(phi2(t_out)) + 0.1*Score[,4] %*% t(phi3(t_out)) 

# create Network edge matrix
N_net1 &lt;- 5 # first community number
N_net2 &lt;- 5 # second community number

# I: four dimension array of n x n matrix of squared distances between the time point u 
# of the ith process and process and the time point v of the jth object process,
# e.g.: I[i,j,u,v] &lt;- d_F^2(X_i(u) X_j(v)).
I &lt;- array(0, dim = c(n,n,N,N))
for(u in 1:N){
  for(v in 1:N){
   #frobenius norm between two adjcent matrix
    I[,,u,v] &lt;- outer(P1_vec[,u], P1_vec[,v], function(a1, a2) (a1-a2)^2*(N_net1^2-N_net1)) +
      outer(P2_vec[,u], P2_vec[,v], function(a1, a2) (a1-a2)^2*(N_net2^2-N_net2))
  }
}


# check ObjCov work
Cov_result &lt;- ObjCov(t_out, I, 3, smooth=FALSE)
Cov_result$lambda  # 0.266 0.15 0.04

# sum((Cov_result$phi[,1] - phi1(t_out))^2) / sum(phi1(t_out)^2)
# sum((Cov_result$phi[,2] - phi2(t_out))^2) / sum(phi2(t_out)^2)
# sum((Cov_result$phi[,3] - phi3(t_out))^2) / sum(phi3(t_out)^2)

# e.g. subj 2
subj &lt;- 2
# X_mat is the network for varying times with X[i,,] is the adjacency matrices 
# for the ith time point
X_mat &lt;- array(0, c(N,(N_net1+N_net2), (N_net1+N_net2)))
for(i in 1:N){
  # edge between communities is P12
  Mat &lt;- matrix(P12, nrow = (N_net1+N_net2), ncol = (N_net1+N_net2)) 
  # edge within the first communitiy is P1
  Mat[1:N_net1, 1:N_net1] &lt;- P1_vec[subj, i] 
  # edge within the second community is P2
  Mat[(N_net1+1):(N_net1+N_net2), (N_net1+1):(N_net1+N_net2)] &lt;- P2_vec[subj, i] 
  diag(Mat) &lt;- 0 #diagonal element is 0
  X_mat[i,,] &lt;- Mat
}
# output the functional principal network(adjacency matrice) of the second eigenfunction
NetFIntegral(Cov_result$phi[,2], t_out, X_mat, 2)

</code></pre>


</div>