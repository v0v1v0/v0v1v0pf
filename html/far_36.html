<div class="container">

<table style="width: 100%;"><tr>
<td>simul.farx</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> FARX(1) process simulation</h2>

<h3>Description</h3>

<p>Simulation of functional data with exogenous variables using a
Gram-Schmidt basis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simul.farx(m=12,n=100,base=base.simul.far(24,5),
  base.exo=base.simul.far(24,5),
  d.a=matrix(c(0.5,0),nrow=1,ncol=2),
  alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
  d.rho=diag(c(0.45,0.90,0.34,0.45)),
  alpha=diag(c(0.5,0.23,0.018)),
  d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
  cst1=0.05)
theoretical.coef(m=12,base=base.simul.far(24,5),
  base.exo=NULL,
  d.rho=diag(c(0.45,0.90,0.34,0.45)),
  d.a=NULL,
  d.rho.exo=NULL,
  alpha=diag(c(0.5,0.23,0.018)),
  alpha.conj=NULL,
  cst1=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p> Integer. Number of discretization points. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> Integer. Number of observations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p> A functional basis expressed as a matrix, as the matrix
created by <code>base.simul.far</code> or with
<code>orthonormalization</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base.exo</code></td>
<td>
<p> A functional basis expressed as a matrix, as the matrix
created by <code>base.simul.far</code> or with
<code>orthonormalization</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.rho</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.a</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.rho.exo</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p> Numerical matrix. Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.conj</code></td>
<td>
<p> Numerical matrix.  Part of the linear operator in the
Gram-Schmidt basis (see details for more informations). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cst1</code></td>
<td>
<p> Numeric. Perturbation coefficient on the linear
operator. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>simul.farx</code> function simulates a FARX(1) process with one
endogeneous variable, one exogeneous variable and a strong white
noise. To do so, the function uses the fact that a FARX(1) model can
be seen as a FAR(1) model in a wider space. Therefore, the method is
very similar to the one used by the function <code>simul.far</code>.
</p>
<p>The simulation is realized in two steps.
</p>
<p>First step, the function compute a FAR(1) process <code class="reqn">T_n</code> in a
functional space (that we call in the sequel H) using a simple
equation and the given parameters. <code class="reqn">T_n</code> is of the form
<code class="reqn">(T_{1n},T_{2n})</code> where <code class="reqn">T_{1n}</code> and
<code class="reqn">T_{2n}</code> are respectively the endogeneous and the exogeneous
parts of the process.
</p>
<p>Second step, the process <code class="reqn">T_n</code> is projected in the canonical
basis using the <code>base</code> and <code>base.exo</code> linear projectors to
give the endogeneous (<code class="reqn">X_n</code>) and the exogeneous
(<code class="reqn">Z_n</code>) variables respectively. 
</p>
<p>Those two basis need to be orthonormal and wide enought. In the
contrary, the function use the <code>orthonormalization</code>
function to make it so. Notice that the size of this matrix
corresponds to the dimension of the "modelization space" H (let's call
it <code class="reqn">m_2=m1_2+m2_2</code>). Of course, the larger <code>m2</code>
the better the functionnal approximation is. Whatever, keep in mind
that <code>m2</code>=2<code>m</code> is a good compromise, in order to avoid the
memory limits.
</p>
<p>In H, the linear operator <code class="reqn">\rho</code> is expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    d.rho.mod &amp; \code{d.a} \cr%
    0 &amp; d.rho.exo.mod%
    \end{array}\right)%
  </code>
</p>

<p>Where d.rho.mod and d.rho.exo.mod are modified version of the provided
<code>d.rho</code> and <code>d.rho.exo</code> respectively to avoid 0 on their
diagonal. More precisely, the 0 on their diaginals are replaced by:
</p>
<p style="text-align: center;"><code class="reqn">\left(\varepsilon_{k+1}, \varepsilon_{k+2}, \ldots, %
    \varepsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i}=\frac{\code{cst1}}{i^2}+%
    \frac{1-\code{cst1}}{e^i}</code>
</p>

<p>and k is the position in the <code>d.rho</code> or <code>d.r.ho.exo</code>
diagonal.
</p>
<p>In H, <code class="reqn">C^T</code>, the covariance operator of <code class="reqn">T_n</code>, is
defined by:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    alpha.mod &amp; alpha.conj.mod \cr%
    t(alpha.conj.mod) &amp; alpha.exo%
    \end{array}\right)%
  </code>
</p>

<p>Where alpha.mod and alpha.exo.mod are modified versions of
<code class="reqn">m1_2 * </code><code>alpha</code> and <code class="reqn">m2_2 * </code><code>alpha.conj</code> respectively to avoid 0 on their diagonal. More
precisely, the 0 on their diaginals are replaced by:
</p>
<p style="text-align: center;"><code class="reqn">\left(\epsilon_{k+1}, \epsilon_{k+2}, \ldots, %
    \epsilon_{\code{m2b}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_{i}=\frac{\code{cst1}}{i}</code>
</p>

<p>alpha.exo is a matrix representation of the covariance operator of
<code class="reqn">T_{2n}</code> and is obtained by inverting the following relation:
</p>
<p style="text-align: center;"><code class="reqn">alpha.conj.mod = d.rho.exo.mod * alpha.conj.mod * t(d.rho.mod) +%
    d.rho.exo.mod * mod.alpha * t(\code{d.a})</code>
</p>

<p>The <code>theoretical.coef</code> function is provided to help the user
making comparison. Calling this function with the same parameters that
where used in a simulation (realized with <code>simul.farx</code> or
<code>simul.far</code>), we obtain the parameters used internaly by the
function to make the simulation. Those values can therefore be
compared to those obtained with the estimation function <code>far</code>
(examples are provided below).
</p>


<h3>Value</h3>

<p>A <code>fdata</code> object containing two variables ("X" the endogeous
variable, and "Z" the exogeneous variable) which is a FARX(1) process
of length <code>n</code> with <code>p</code> discretization points.
</p>


<h3>Note</h3>

<p>To simulate <code class="reqn">T_n</code>, the function creates a white noise
<code class="reqn">E_n</code> having the following covariance operator:
</p>
<p style="text-align: center;"><code class="reqn">C^T - \rho * C^T * t({\rho})</code>
</p>

<p>where t(.) is the transposition operator.
<code class="reqn">T_n</code> is the computed using the equation:
</p>
<p style="text-align: center;"><code class="reqn">T_{n+1} = \rho * T_n + E_n</code>
</p>



<h3>Author(s)</h3>

<p> J. Damon, S. Guillas </p>


<h3>See Also</h3>

 <p><code>simul.far.sde</code>, <code>simul.far.wiener</code>,
<code>simul.far</code>, <code>simul.wiener</code>.  </p>


<h3>Examples</h3>

<pre><code class="language-R">  # Simulation of a FARX process
  data1 &lt;- simul.farx(m=10,n=400,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Modelisation of the FARX process (joined and separate)
  model1 &lt;- far(data1,k=4,joined=TRUE)
  model2 &lt;- far(data1,k=c(3,1),joined=FALSE)

  # Calculation of the theoretical coefficients
  coef.theo &lt;- theoretical.coef(m=10,base=base.simul.far(20,5),
                base.exo=base.simul.far(20,5),
                d.a=matrix(c(0.5,0),nrow=1,ncol=2),
                alpha.conj=matrix(c(0.2,0),nrow=1,ncol=2),
                d.rho=diag(c(0.45,0.90,0.34,0.45)),
                alpha=diag(c(0.5,0.23,0.018)),
                d.rho.exo=diag(c(0.45,0.90,0.34,0.45)),
                cst1=0.0)

  # Joined coefficient
  round(coef(model1),2)
  coef.theo$rho.T

  # Separate coefficient
  round(coef(model2),2)
  coef.theo$rho.X.Z
</code></pre>


</div>