<div class="container">

<table style="width: 100%;"><tr>
<td>summary.fixest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Summary of a <code>fixest</code> object. Computes different types of standard errors.</h2>

<h3>Description</h3>

<p>This function is similar to <code>print.fixest</code>. It provides the table of coefficients along with
other information on the fit of the estimation. It can compute different types of standard
errors. The new variance covariance matrix is an object returned.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'fixest'
summary(
  object,
  vcov = NULL,
  cluster = NULL,
  ssc = NULL,
  .vcov = NULL,
  stage = NULL,
  lean = FALSE,
  agg = NULL,
  forceCovariance = FALSE,
  se = NULL,
  keepBounded = FALSE,
  n = 1000,
  vcov_fix = TRUE,
  nthreads = getFixest_nthreads(),
  ...
)

## S3 method for class 'fixest_list'
summary(
  object,
  se,
  cluster,
  ssc = getFixest_ssc(),
  .vcov,
  stage = 2,
  lean = FALSE,
  n,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>fixest</code> object. Obtained using the functions <code>femlm</code>, <code>feols</code> or <code>feglm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character
scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The
VCOV types implemented are: "iid", "hetero" (or "HC1"), "cluster", "twoway",
"NW" (or "newey_west"), "DK" (or "driscoll_kraay"), and "conley". It also accepts
object from <code>vcov_cluster</code>, <code>vcov_NW</code>, <code>NW</code>,
<code>vcov_DK</code>, <code>DK</code>, <code>vcov_conley</code> and
<code>conley</code>. It also accepts covariance matrices computed externally.
Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation
in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested).
Can be either a list of vectors, a character vector of variable names, a formula or
an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code>
contained in the data.frame <code>base</code> used for the estimation. All the following
<code>cluster</code> arguments are valid and do the same thing:
<code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>.
If the two variables were used as fixed-effects in the estimation, you can leave it
blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was
the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with
the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code>ssc</code>. Represents
how the degree of freedom correction should be done.You must use the function <code>ssc</code>
for this argument. The arguments and defaults of the function <code>ssc</code> are:
<code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>,
<code>t.df = "min"</code>, <code style="white-space: pre;">⁠fixef.force_exact=FALSE)⁠</code>. See the help of the function <code>ssc</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.vcov</code></td>
<td>
<p>A user provided covariance matrix or a function computing this matrix. If a
matrix, it must be a square matrix of the same number of rows as the number
of variables estimated. If a function, it must return the previously mentioned matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stage</code></td>
<td>
<p>Can be equal to <code>2</code> (default), <code>1</code>, <code>1:2</code> or <code>2:1</code>. Only used if the object
is an IV estimation: defines the stage to which <code>summary</code> should be applied. If <code>stage = 1</code>
and there are multiple endogenous regressors or if <code>stage</code> is of length 2, then an
object of class <code>fixest_multi</code> is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Used to reduce the (memory) size of the summary object.
If <code>TRUE</code>, then all objects of length N (the number of observations) are removed
from the result. Note that some <code>fixest</code> methods may consequently not work when applied
to the summary.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agg</code></td>
<td>
<p>A character scalar describing the variable names to be aggregated,
it is pattern-based. For <code>sunab</code> estimations, the following keywords work: "att",
"period", "cohort" and <code>FALSE</code> (to have full disaggregation). All variables that
match the pattern will be aggregated. It must be of the form <code>"(root)"</code>, the parentheses
must be there and the resulting variable name will be <code>"root"</code>. You can add another
root with parentheses: <code>"(root1)regex(root2)"</code>, in which case the resulting
name is <code>"root1::root2"</code>. To name the resulting variable differently you can pass
a named vector: <code>c("name" = "pattern")</code> or <code>c("name" = "pattern(root2)")</code>. It's a
bit intricate sorry, please see the examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forceCovariance</code></td>
<td>
<p>(Advanced users.) Logical, default is <code>FALSE</code>. In the peculiar case
where the obtained Hessian is not invertible (usually because of collinearity of
some variables), use this option to force the covariance matrix, by using a generalized
inverse of the Hessian. This can be useful to spot where possible problems come from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed:
“standard”, “hetero”, “cluster”, “twoway”, “threeway”
or “fourway”? By default if there are clusters in the estimation:
<code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated,
you should use <code>vcov</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepBounded</code></td>
<td>
<p>(Advanced users – <code>feNmlm</code> with non-linear part and bounded
coefficients only.) Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then the bounded coefficients
(if any) are treated as unrestricted coefficients and their S.E. is computed (otherwise
it is not).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer, default is 1000. Number of coefficients to display when the print method
is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_fix</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If the VCOV ends up not being
positive definite, whether to "fix" it using an eigenvalue decomposition
(a la Cameron, Gelbach &amp; Miller 2011).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than, or equal to,
the maximum number of threads; b) 0: meaning all available threads will be used;
c) a number strictly between 0 and 1 which represents the fraction of all threads to use.
The default is to use 50% of all threads. You can set permanently the number
of threads used within this package using the function <code>setFixest_nthreads</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Only used if the argument <code>.vcov</code> is provided and is a function: extra arguments
to be passed to that function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a <code>fixest</code> object with:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cov.scaled</code></td>
<td>
<p>The new variance-covariance matrix (computed according to the argument <code>se</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>The new standard-errors (computed according to the argument <code>se</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeftable</code></td>
<td>
<p>The table of coefficients with the new standard errors.</p>
</td>
</tr>
</table>
<h3>Compatibility with <span class="pkg">sandwich</span> package</h3>

<p>The VCOVs from <code>sandwich</code> can be used with <code>feols</code>, <code>feglm</code> and <code>fepois</code> estimations.
If you want to have a <code>sandwich</code> VCOV when using <code>summary.fixest</code>, you can use
the argument <code>vcov</code> to specify the VCOV function to use (see examples).
Note that if you do so and you use a formula in the <code>cluster</code> argument, an innocuous
warning can pop up if you used several non-numeric fixed-effects in the estimation
(this is due to the function <code>expand.model.frame</code> used in <code>sandwich</code>).
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>See also the main estimation functions <code>femlm</code>, <code>feols</code> or <code>feglm</code>.
Use <code>fixef.fixest</code> to extract the fixed-effects coefficients, and the function <code>etable</code>
to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Load trade data
data(trade)

# We estimate the effect of distance on trade (with 3 fixed-effects)
est_pois = fepois(Euros ~ log(dist_km)|Origin+Destination+Product, trade)

# Comparing different types of standard errors
sum_standard = summary(est_pois, vcov = "iid")
sum_hetero   = summary(est_pois, vcov = "hetero")
sum_oneway   = summary(est_pois, vcov = "cluster")
sum_twoway   = summary(est_pois, vcov = "twoway")

etable(sum_standard, sum_hetero, sum_oneway, sum_twoway)

# Alternative ways to cluster the SE:
summary(est_pois, vcov = cluster ~ Product + Origin)
summary(est_pois, vcov = ~Product + Origin)
summary(est_pois, cluster = ~Product + Origin)

# You can interact the clustering variables "live" using the var1 ^ var2 syntax.#'
summary(est_pois, vcov = ~Destination^Product)

#
# Newey-West and Driscoll-Kraay SEs
#

data(base_did)
# Simple estimation on a panel
est = feols(y ~ x1, base_did)

# --
# Newey-West
# Use the syntax NW ~ unit + time
summary(est, NW ~ id + period)

# Now take a lag of 3:
summary(est, NW(3) ~ id + period)

# --
# Driscoll-Kraay
# Use the syntax DK ~ time
summary(est, DK ~ period)

# Now take a lag of 3:
summary(est, DK(3) ~ period)

#--
# Implicit deductions
# When the estimation is done with a panel.id, you don't need to
# specify these values.

est_panel = feols(y ~ x1, base_did, panel.id = ~id + period)

# Both methods, NM and DK, now work automatically
summary(est_panel, "NW")
summary(est_panel, "DK")

#
# VCOVs robust to spatial correlation
#

data(quakes)
est_geo = feols(depth ~ mag, quakes)

# --
# Conley
# Use the syntax: conley(cutoff) ~ lat + lon
# with lat/lon the latitude/longitude variable names in the data set
summary(est_geo, conley(100) ~ lat + long)

# Change the cutoff, and how the distance is computed
summary(est_geo, conley(200, distance = "spherical") ~ lat + long)

# --
# Implicit deduction
# By default the latitude and longitude are directly fetched in the data based
# on pattern matching. So you don't have to specify them.
# Further an automatic cutoff is computed by default.

# The following works
summary(est_geo, "conley")



#
# Compatibility with sandwich
#

# You can use the VCOVs from sandwich by using the argument .vcov:
library(sandwich)
summary(est_pois, .vcov = vcovCL, cluster = trade[, c("Destination", "Product")])


</code></pre>


</div>