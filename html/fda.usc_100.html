<div class="container">

<table style="width: 100%;"><tr>
<td>fdata2pls</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Partial least squares components for functional data.</h2>

<h3>Description</h3>

<p>Compute penalized partial least squares (PLS) components for functional
data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fdata2pls(fdataobj, y, ncomp = 2, lambda = 0, P = c(0, 0, 1), norm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdataobj</code></td>
<td>
<p><code>fdata</code> class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Scalar response with length <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncomp</code></td>
<td>
<p>The number of components to include in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Amount of penalization. Default value is 0, i.e. no
penalization is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P</code></td>
<td>
<p>If P is a vector: coefficients to define the penalty matrix object.
By default <code class="reqn">P=c(0,0,1)</code> penalizes the second derivative (curvature) or
acceleration.  If P is a matrix: the penalty matrix object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm</code></td>
<td>
<p>If <code>TRUE</code> the <code>fdataobj</code> are centered and scaled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>norm=TRUE</code>, computes the PLS by
<code>NIPALS</code> algorithm and the Degrees of Freedom using the Krylov
representation of PLS, see Kraemer and Sugiyama (2011).<br> 
If <code>norm=FALSE</code>, computes the PLS by Orthogonal Scores Algorithm and
the Degrees of Freedom are the number of components <code>ncomp</code>, see
Martens and Naes (1989).
</p>


<h3>Value</h3>

<p><code>fdata2pls</code> function return: 
</p>

<ul>
<li> <p>df degree of freedom
</p>
</li>
<li> <p>rotation <code>fdata</code> class object. 
</p>
</li>
<li> <p>x Is true the value of the rotated data (the centred data multiplied by the rotation matrix) is returned.
</p>
</li>
<li> <p>fdataobj.cen The centered <code>fdataobj</code> object. 
</p>
</li>
<li> <p>mean mean of <code>fdataobj</code>. 
</p>
</li>
<li> <p>lVector of index of principal components. 
</p>
</li>
<li> <p>C The matched call.
</p>
</li>
<li> <p>lambda Amount of penalization. 
</p>
</li>
<li> <p>P Penalty matrix.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Manuel Febrero-Bande, Manuel Oviedo de la Fuente  <a href="mailto:manuel.oviedo@usc.es">manuel.oviedo@usc.es</a>
</p>


<h3>References</h3>

<p>Kraemer, N., Sugiyama M. (2011). <em>The Degrees of Freedom of
Partial Least Squares Regression</em>. Journal of the American Statistical
Association. Volume 106, 697-705.
</p>
<p>Febrero-Bande, M., Oviedo de la Fuente, M. (2012).  <em>Statistical
Computing in Functional Data Analysis: The R Package fda.usc.</em> Journal of
Statistical Software, 51(4), 1-28. <a href="https://www.jstatsoft.org/v51/i04/">https://www.jstatsoft.org/v51/i04/</a>
</p>
<p>Martens, H., Naes, T. (1989) <em>Multivariate calibration.</em> Chichester:
Wiley.
</p>


<h3>See Also</h3>

<p>Used in:
<code>fregre.pls</code>, <code>fregre.pls.cv</code>.
Alternative method: <code>fdata2pc</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
n= 500;tt= seq(0,1,len=101)
x0&lt;-rproc2fdata(n,tt,sigma="wiener")
x1&lt;-rproc2fdata(n,tt,sigma=0.1)
x&lt;-x0*3+x1
beta = tt*sin(2*pi*tt)^2
fbeta = fdata(beta,tt)
y&lt;-inprod.fdata(x,fbeta)+rnorm(n,sd=0.1)
pls1=fdata2pls(x,y)
pls1$call
summary(pls1)
pls1$l
norm.fdata(pls1$rotation)

## End(Not run)
</code></pre>


</div>