<div class="container">

<table style="width: 100%;"><tr>
<td>future_map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a function to each element of a vector via futures</h2>

<h3>Description</h3>

<p>These functions work exactly the same as <code>purrr::map()</code> and its variants, but
allow you to map in parallel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">future_map(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_chr(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_dbl(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_int(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_lgl(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_raw(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_dfr(
  .x,
  .f,
  ...,
  .id = NULL,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_map_dfc(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)

future_walk(
  .x,
  .f,
  ...,
  .options = furrr_options(),
  .env_globals = parent.frame(),
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.x</code></td>
<td>
<p>A list or atomic vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li>
<p> For a single argument function, use <code>.</code>
</p>
</li>
<li>
<p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li>
<p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li>
</ul>
<p>This syntax allows you to create very compact anonymous functions.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to the mapped function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.options</code></td>
<td>
<p>The <code>future</code> specific options to use with the workers. This
must be the result from a call to <code>furrr_options()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.env_globals</code></td>
<td>
<p>The environment to look for globals required by <code>.x</code> and
<code>...</code>. Globals required by <code>.f</code> are looked up in the function environment
of <code>.f</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.progress</code></td>
<td>
<p>A single logical. Should a progress bar be displayed?
Only works with multisession, multicore, and multiprocess futures. Note
that if a multicore/multisession future falls back to sequential, then
a progress bar will not be displayed.
</p>
<p><strong>Warning:</strong> The <code>.progress</code> argument will be deprecated and removed
in a future version of furrr in favor of using the more robust
<a href="https://CRAN.R-project.org/package=progressr">progressr</a>
package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.id</code></td>
<td>
<p>Either a string or <code>NULL</code>. If a string, the output will contain
a variable with that name, storing either the name (if <code>.x</code> is named) or
the index (if <code>.x</code> is unnamed) of the input. If <code>NULL</code>, the default, no
variable will be created.
</p>
<p>Only applies to <code style="white-space: pre;">⁠_dfr⁠</code> variant.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>All functions return a vector the same length as <code>.x</code>.
</p>

<ul>
<li> <p><code>future_map()</code> returns a list
</p>
</li>
<li> <p><code>future_map_lgl()</code> a logical vector
</p>
</li>
<li> <p><code>future_map_int()</code> an integer vector
</p>
</li>
<li> <p><code>future_map_dbl()</code> a double vector
</p>
</li>
<li> <p><code>future_map_chr()</code> a character vector
</p>
</li>
</ul>
<p>The output of <code>.f</code> will be automatically typed upwards, e.g. logical -&gt;
integer -&gt; double -&gt; character.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(magrittr)
plan(multisession, workers = 2)

1:10 %&gt;%
  future_map(rnorm, n = 10, .options = furrr_options(seed = 123)) %&gt;%
  future_map_dbl(mean)

# If each element of the output is a data frame, use
# `future_map_dfr()` to row-bind them together:
mtcars %&gt;%
  split(.$cyl) %&gt;%
  future_map(~ lm(mpg ~ wt, data = .x)) %&gt;%
  future_map_dfr(~ as.data.frame(t(as.matrix(coef(.)))))


# You can be explicit about what gets exported to the workers.
# To see this, use multisession (not multicore as the forked workers
# still have access to this environment)
plan(multisession)
x &lt;- 1
y &lt;- 2

# This will fail, y is not exported (no black magic occurs)
try(future_map(1, ~y, .options = furrr_options(globals = "x")))

# y is exported
future_map(1, ~y, .options = furrr_options(globals = "y"))


</code></pre>


</div>