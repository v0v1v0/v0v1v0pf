<div class="container">

<table style="width: 100%;"><tr>
<td>bootstrapCI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to compute bootstrap confidence intervals</h2>

<h3>Description</h3>

<p>The model is fitted on bootstrapped samples of the data to compute bootstrapped 
coefficient estimates. To determine the optimal stopping iteration an inner bootstrap 
is run within each bootstrap fold. 
As estimation by boosting shrinks the coefficient estimates towards zero, 
to bootstrap confidence intervals are biased towards zero.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bootstrapCI(
  object,
  which = NULL,
  resampling_fun_outer = NULL,
  resampling_fun_inner = NULL,
  B_outer = 100,
  B_inner = 25,
  type_inner = c("bootstrap", "kfold", "subsampling"),
  levels = c(0.05, 0.95),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a fitted model object of class <code>FDboost</code>, 
for which the confidence intervals should be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>a subset of base-learners to take into account for 
computing confidence intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling_fun_outer</code></td>
<td>
<p>function for the outer resampling procedure.
<code>resampling_fun_outer</code> must be a function with arguments <code>object</code>
and <code>fun</code>, where <code>object</code> corresponds to the fitted 
<code>FDboost</code> object and <code>fun</code> is passed to the <code>fun</code>
argument of the resampling function (see examples).
If <code>NULL</code>, <code>applyFolds</code> is used with 100-fold boostrap.
Further arguments to <code>applyFolds</code> can be passed via <code>...</code>.
Although the function can be defined very flexible, it is recommended 
to use <code>applyFolds</code> and, in particular, not <code>cvrisk</code>, 
as in this case, weights of the inner and outer 
fold will interact, probably causing the inner 
resampling to crash. For bootstrapped confidence intervals
the outer function should usually be a bootstrap type of resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resampling_fun_inner</code></td>
<td>
<p>function for the inner resampling procudure,
which determines the optimal stopping iteration in each fold of the
outer resampling procedure. Should be a function with one argument
<code>object</code> for the fitted <code>FDboost</code> object. 
If <code>NULL</code>, <code>cvrisk</code> is used with 25-fold bootstrap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_outer</code></td>
<td>
<p>Number of resampling folds in the outer loop.
Argument is overwritten, when a custom <code>resampling_fun_outer</code>
is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B_inner</code></td>
<td>
<p>Number of resampling folds in the inner loop.
Argument is overwritten, when a custom <code>resampling_fun_inner</code>
is supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type_inner</code></td>
<td>
<p>character argument for specifying the cross-validation method for
the inner resampling level. Default is <code>"bootstrap"</code>. Currently  
bootstrap, k-fold cross-validation and subsampling are implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>the confidence levels required. If NULL, the 
raw results are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, information will be printed in the console</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to <code>applyFolds</code> if
the default for <code>resampling_fun_outer</code> is used</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the elements <code>raw_results</code>, the 
<code>quantiles</code> and <code>mstops</code>. 
In <code>raw_results</code> and <code>quantiles</code>, each baselearner
selected with <code>which</code> in turn corresponds to a list
element. The quantiles are given as vector, matrix or list of
matrices depending on the nature of the effect. In case of functional
effects the list element in<code>quantiles</code> is a <code>length(levels)</code> times
<code>length(effect)</code> matrix, i.e. the rows correspond to the quantiles.
In case of coefficient surfaces, <code>quantiles</code> comprises a list of matrices,
where each list element corresponds to a quantile.
</p>


<h3>Note</h3>

<p>Note that parallelization can be achieved by defining
the <code>resampling_fun_outer</code> or <code>_inner</code> accordingly.
See, e.g., <code>cvrisk</code> on how to parallelize resampling
functions or the examples below. Also note that by defining
a custum inner or outer resampling function the respective
argument <code>B_inner</code> or <code>B_outer</code> is ignored.
For models with complex baselearners, e.g., created by combining
several baselearners with the Kronecker or row-wise tensor product,
it is also recommended to use <code>levels = NULL</code> in order to
let the function return the raw results and then manually compute
confidence intervals.
If a baselearner is not selected in any fold, the function
treats its effect as constantly zero.
</p>


<h3>Author(s)</h3>

<p>David Ruegamer, Sarah Brockhaus
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(require(refund)){
#########
# model with linear functional effect, use bsignal()
# Y(t) = f(t) + \int X1(s)\beta(s,t)ds + eps
set.seed(2121)
data1 &lt;- pffrSim(scenario = "ff", n = 40)
data1$X1 &lt;- scale(data1$X1, scale = FALSE)
dat_list &lt;- as.list(data1)
dat_list$t &lt;- attr(data1, "yindex")
dat_list$s &lt;- attr(data1, "xindex")

## model fit by FDboost 
m1 &lt;- FDboost(Y ~ 1 + bsignal(x = X1, s = s, knots = 8, df = 3), 
              timeformula = ~ bbs(t, knots = 8), data = dat_list)

}
              
             
# a short toy example with to few folds  
# and up to 200 boosting iterations 
bootCIs &lt;- bootstrapCI(m1[200], B_inner = 2, B_outer = 5) 

# look at stopping iterations
bootCIs$mstops

# plot bootstrapped coefficient estimates
plot(bootCIs, ask = FALSE)


my_inner_fun &lt;- function(object){ 
cvrisk(object, folds = cvLong(id = object$id, weights = 
model.weights(object), B = 2) # 10-fold for inner resampling
) 
}


bootCIs &lt;- bootstrapCI(m1, resampling_fun_inner = my_inner_fun, 
                       B_outer = 5) # small B_outer to speed up


## We can also use the ... argument to parallelize the applyFolds
## function in the outer resampling 


bootCIs &lt;- bootstrapCI(m1, B_inner = 5, B_outer = 3)


## Now let's parallelize the outer resampling and use 
## crossvalidation instead of bootstrap for the inner resampling

my_inner_fun &lt;- function(object){ 
cvrisk(object, folds = cvLong(id = object$id, weights = 
model.weights(object), type = "kfold", # use CV
B = 5, # 5-fold for inner resampling
)) # use five cores
}

# use applyFolds for outer function to avoid messing up weights
my_outer_fun &lt;- function(object, fun){
applyFolds(object = object,
folds = cv(rep(1, length(unique(object$id))), 
type = "bootstrap", B = 10), fun = fun) # parallelize on 10 cores
}


bootCIs &lt;- bootstrapCI(m1, resampling_fun_inner = my_inner_fun,
                       resampling_fun_outer = my_outer_fun,
                       B_inner = 5, B_outer = 10) 


######## Example for scalar-on-function-regression with bsignal() 
data("fuelSubset", package = "FDboost")

## center the functional covariates per observed wavelength
fuelSubset$UVVIS &lt;- scale(fuelSubset$UVVIS, scale = FALSE)
fuelSubset$NIR &lt;- scale(fuelSubset$NIR, scale = FALSE)

## to make mboost:::df2lambda() happy (all design matrix entries &lt; 10)
## reduce range of argvals to [0,1] to get smaller integration weights
fuelSubset$uvvis.lambda &lt;- with(fuelSubset, (uvvis.lambda - min(uvvis.lambda)) /
(max(uvvis.lambda) - min(uvvis.lambda) ))
fuelSubset$nir.lambda &lt;- with(fuelSubset, (nir.lambda - min(nir.lambda)) /
(max(nir.lambda) - min(nir.lambda) ))

## model fit with scalar response and two functional linear effects 
## include no intercept as all base-learners are centered around 0    

mod2 &lt;- FDboost(heatan ~ bsignal(UVVIS, uvvis.lambda, knots = 40, df = 4, check.ident = FALSE) 
               + bsignal(NIR, nir.lambda, knots = 40, df=4, check.ident = FALSE), 
               timeformula = NULL, data = fuelSubset) 



# takes some time, because of defaults: B_outer = 100, B_inner = 25
bootCIs &lt;- bootstrapCI(mod2, B_outer = 10, B_inner = 5)
           # in practice, rather set B_outer = 1000



</code></pre>


</div>