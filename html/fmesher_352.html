<div class="container">

<table style="width: 100%;"><tr>
<td>fm_raw_basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Basis functions for mesh manifolds</h2>

<h3>Description</h3>

<p>Calculate basis functions on <code>fm_mesh_1d()</code> or <code>fm_mesh_2d()</code>,
without necessarily matching the default function space of the given mesh
object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fm_raw_basis(
  mesh,
  type = "b.spline",
  n = 3,
  degree = 2,
  knot.placement = "uniform.area",
  rot.inv = TRUE,
  boundary = "free",
  free.clamped = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>An <code>fm_mesh_1d()</code> or <code>fm_mesh_2d()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p><code>b.spline</code> (default) for B-spline basis functions,
<code>sph.harm</code> for spherical harmonics (available only for meshes on the
sphere)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>For B-splines, the number of basis functions in each direction (for
1d meshes <code>n</code> must be a scalar, and for planar 2d meshes a 2-vector).
For spherical harmonics, <code>n</code> is the maximal harmonic order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>degree</code></td>
<td>
<p>Degree of B-spline polynomials.  See
<code>fm_mesh_1d()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knot.placement</code></td>
<td>
<p>For B-splines on the sphere, controls the latitudinal
placements of knots. <code>"uniform.area"</code> (default) gives uniform spacing
in <code>sin(latitude)</code>, <code>"uniform.latitude"</code> gives uniform spacing in
latitudes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rot.inv</code></td>
<td>
<p>For spherical harmonics on a sphere, <code>rot.inv=TRUE</code>
gives the rotationally invariant subset of basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>Boundary specification, default is free boundaries.  See
<code>fm_mesh_1d()</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>free.clamped</code></td>
<td>
<p>If <code>TRUE</code> and <code>boundary</code> is <code>"free"</code>, the
boundary basis functions are clamped to 0/1 at the interval boundary by
repeating the boundary knots. See
<code>fm_mesh_1d()</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Unused</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A matrix with evaluated basis function
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>fm_mesh_1d()</code>, <code>fm_mesh_2d()</code>, <code>fm_basis()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
loc &lt;- rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1))
mesh &lt;- fm_mesh_2d(loc, max.edge = 0.15)
basis &lt;- fm_raw_basis(mesh, n = c(4, 5))

proj &lt;- fm_evaluator(mesh, dims = c(10, 10))
image(proj$x, proj$y, fm_evaluate(proj, basis[, 7]), asp = 1)

if (interactive() &amp;&amp; require("rgl")) {
  plot_rgl(mesh, col = basis[, 7], draw.edges = FALSE, draw.vertices = FALSE)
}


</code></pre>


</div>