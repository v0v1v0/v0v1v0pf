<div class="container">

<table style="width: 100%;"><tr>
<td>fregre.gsam.vs</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variable Selection using Functional Additive Models</h2>

<h3>Description</h3>

<p>Computes functional GAM model between functional covariates
<code class="reqn">(X^1(t_1),\cdots,X^{q}(t_q))</code> and non functional covariates
<code class="reqn">(Z^1,...,Z^p)</code> with a scalar response <code class="reqn">Y</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fregre.gsam.vs(
  data = list(),
  y,
  include = "all",
  exclude = "none",
  family = gaussian(),
  weights = NULL,
  basis.x = NULL,
  numbasis.opt = FALSE,
  kbs,
  dcor.min = 0.1,
  alpha = 0.05,
  par.model,
  xydist,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>List that containing the variables in the model. 
"df" element is a data.frame containing the response and scalar covariates 
(numeric and factors variables are allowed). Functional covariates of class
<code>fdata</code> or <code>fd</code> are included as named components in the <code>data</code> list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Caracter string with the name of the scalar response variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include</code></td>
<td>
<p>vector with the name of variables to use. By default <code>"all"</code>, all variables are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude</code></td>
<td>
<p>vector with the name of variables to not use. By default  <code>"none"</code>, no variable is deleted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code>family</code> for details of family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis.x</code></td>
<td>
<p>Basis parameter options
</p>

<ul>
<li>
<p><code>list</code> (recomended)  List of basis for functional covariates,
see same argument in <code>fregre.glm</code>. By default, 
the function uses a basis of 3 PC to represent each functional covariate. 
</p>
</li>
<li>
<p><code>vector</code> (by default) Vector with two parameters:
</p>

<ol>
<li>
<p> Type of basis. By default <code>basis.x[1]="pc"</code>, principal
component basis is used  for each functional covariate included in the model.
Other options <code>"pls"</code> and <code>"bspline"</code>.  
</p>
</li>
<li>
<p> Maximum number of  basis elements <code>numbasis</code>  to be used.
By default, <code>basis.x[2]=3</code>. 
</p>
</li>
</ol>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numbasis.opt</code></td>
<td>
<p>Logical, if <code>FALSE</code> by default, for each functional 
covariate included in the model, the function uses all basis elements. 
Otherwise, the function selects the significant coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kbs</code></td>
<td>
<p>The dimension of the basis used to represent the smooth term. The default 
depends on the number of variables that the smooth is a function of.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dcor.min</code></td>
<td>
<p>Threshold for a variable to be entered into the model. X is discarded 
if the distance correlation <code class="reqn">R(X,e)&lt; dcor.min</code> (e is the residual of previous steps).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Alpha value for testing the independence among covariate X and residual
e in previous steps. By default is <code>0.05</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.model</code></td>
<td>
<p>Model parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xydist</code></td>
<td>
<p>List with the inner distance matrices of each variable (all potential 
covariates and the response).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Interactive Tracing and Debugging of Call.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is an extension of the functional generalized spectral additive 
regression models: <code>fregre.gsam</code> where the <code class="reqn">E[Y|X,Z]</code> is related to the 
linear prediction <code class="reqn">\eta</code> via a link function <code class="reqn">g(\cdot)</code> with integrated 
smoothness estimation by the smooth functions <code class="reqn">f(\cdot)</code>. 
</p>
<p style="text-align: center;"><code class="reqn">E[Y|X,Z])=\eta=g^{-1}(\alpha+\sum_{i=1}^{p}f_{i}(Z^{i})+\sum_{k=1}^{q}\sum_{j=1}^{k_q}{f_{j}^{k}(\xi_j^k)})</code>
</p>

<p>where <code class="reqn">\xi_j^k</code> is the coefficient of the basis  function expansion of 
<code class="reqn">X^k</code>, (in PCA analysis <code class="reqn">\xi_j^k</code> is the score of the <code class="reqn">j</code>-functional
PC of <code class="reqn">X^k</code>.
</p>
<p>The smooth functions <code class="reqn">f(\cdot)</code> can be added to the right hand side of the formula
to specify that the linear predictor depends on smooth functions of predictors using smooth 
terms <code>s</code> and <code>te</code> as in  <code>gam</code> (or linear functionals of 
these as <code class="reqn">Z\beta</code> and <code class="reqn">\big&lt;X(t),\beta\big&gt;</code> in <code>fregre.glm</code>).
</p>


<h3>Value</h3>

<p>Return an object corresponding to the estimated additive mdoel using 
the selected variables (ame output as the<code>fregre.gsam</code> function) and the following elements:
</p>

<ul>
<li>
<p><code>gof</code>, the goodness of fit for each step of VS algorithm.
</p>
</li>
<li>
<p><code>i.predictor</code>, <code>vector</code> with 1 if the variable is selected, 0 otherwise.
</p>
</li>
<li>
<p><code>ipredictor</code>, <code>vector</code> with the name of selected variables (in order of selection)
</p>
</li>
<li>
<p><code>dcor</code>, the value of distance correlation for each potential covariate and the residual of the model in each step.
</p>
</li>
</ul>
<h3>Note</h3>

<p>If the formula only contains a non functional explanatory variables (multivariate covariates),
the function compute a standard  <code>gam</code> procedure.
</p>


<h3>Author(s)</h3>

<p>Manuel Feb-Bande, Manuel Oviedo de la Fuente
<a href="mailto:manuel.oviedo@udc.es">manuel.oviedo@udc.es</a>
</p>


<h3>References</h3>

<p>Febrero-Bande, M., Gonz\'alez-Manteiga, W. and Oviedo de la
Fuente, M. Variable selection in functional additive regression models,
(2018).  Computational Statistics, 1-19. DOI: <a href="https://doi.org/10.1007/s00180-018-0844-5">doi:10.1007/s00180-018-0844-5</a>
</p>


<h3>See Also</h3>

<p>See Also as:  <code>predict.fregre.gsam</code> and <code>summary.gam</code>.
Alternative methods: <code>fregre.glm</code>, <code>fregre.gsam</code>
and <code>fregre.gkam</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run:  
data(tecator)
x=tecator$absorp.fdata
x1 &lt;- fdata.deriv(x)
x2 &lt;- fdata.deriv(x,nderiv=2)
y=tecator$y$Fat
xcat0 &lt;- cut(rnorm(length(y)),4) 
xcat1 &lt;- cut(tecator$y$Protein,4)
xcat2 &lt;- cut(tecator$y$Water,4)
ind &lt;- 1:165
dat &lt;- data.frame("Fat"=y, x1$data, xcat1, xcat2)
ldat &lt;- ldata("df"=dat[ind,],"x"=x[ind,],"x1"=x1[ind,],"x2"=x2[ind,])
# 3 functionals (x,x1,x2), 3 factors (xcat0, xcat1, xcat2)
# and 100 scalars (impact poitns of x1) 

# Time consuming
res.gam0 &lt;- fregre.gsam.vs(data=ldat,y="Fat"
            ,exclude="x2",numbasis.opt=T) # All the covariates
summary(res.gam0)
res.gam0$ipredictors

res.gam1 &lt;- fregre.gsam.vs(data=ldat,y="Fat") # All the covariates
summary(res.gam1)
res.gam1$ipredictors

covar &lt;- c("xcat0","xcat1","xcat2","x","x1","x2")
res.gam2 &lt;- fregre.gsam.vs(data=ldat, y="Fat", include=covar)
summary(res.gam2)
res.gam2$ipredictors 
res.gam2$i.predictor

res.gam3 &lt;- fregre.gsam.vs(data=ldat,y="Fat",
            basis.x=c("type.basis"="pc","numbasis"=10))
summary(res.gam3)
res.gam3$ipredictors

res.gam4 &lt;- fregre.gsam.vs(data=ldat,y="Fat",include=c("x","x1","x2"),
basis.x=c("type.basis"="pc","numbasis"=5),numbasis.opt=T)
summary(res.gam4)
res.gam4$ipredictors
lpc &lt;- list("x"=create.pc.basis(ldat$x,1:4)
           ,"x1"=create.pc.basis(ldat$x1,1:3)
           ,"x2"=create.pc.basis(ldat$x2,1:12))
res.gam5 &lt;- fregre.gsam.vs(data=ldat,y="Fat",basis.x=lpc)
summary(res.gam5)
res.gam6 &lt;- fregre.gsam.vs(data=ldat,y="Fat",basis.x=lpc,numbasis.opt=T)
summary(res.gam6)
bsp &lt;- create.fourier.basis(ldat$x$rangeval,7)
lbsp &lt;- list("x"=bsp,"x1"=bsp,"x2"=bsp)
res.gam7 &lt;- fregre.gsam.vs(data=ldat,y="Fat",basis.x=lbsp,kbs=4)
summary(res.gam7)
# Prediction like fregre.gsam() 
newldat &lt;- ldata("df"=dat[-ind,],"x"=x[-ind,],"x1"=x1[-ind,],
                "x2"=x2[-ind,])
pred.gam1 &lt;- predict(res.gam1,newldat)
pred.gam2 &lt;- predict(res.gam2,newldat)
pred.gam3 &lt;- predict(res.gam3,newldat)
pred.gam4 &lt;- predict(res.gam4,newldat)
pred.gam5 &lt;- predict(res.gam5,newldat)
pred.gam6 &lt;- predict(res.gam6,newldat)
pred.gam7 &lt;- predict(res.gam7,newldat)
plot(dat[-ind,"Fat"],pred.gam1)
points(dat[-ind,"Fat"],pred.gam2,col=2)
points(dat[-ind,"Fat"],pred.gam3,col=3)
points(dat[-ind,"Fat"],pred.gam4,col=4)
points(dat[-ind,"Fat"],pred.gam5,col=5)
points(dat[-ind,"Fat"],pred.gam6,col=6)
points(dat[-ind,"Fat"],pred.gam7,col=7)
pred2meas(newldat$df$Fat,pred.gam1)
pred2meas(newldat$df$Fat,pred.gam2)
pred2meas(newldat$df$Fat,pred.gam3)
pred2meas(newldat$df$Fat,pred.gam4)
pred2meas(newldat$df$Fat,pred.gam5)
pred2meas(newldat$df$Fat,pred.gam6)
pred2meas(newldat$df$Fat,pred.gam7)

## End(Not run)
</code></pre>


</div>