<div class="container">

<table style="width: 100%;"><tr>
<td>set_date</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>set date</h2>

<h3>Description</h3>

<p>set dates manually or automatically
</p>


<h3>Usage</h3>

<pre><code class="language-R">set_date(.data, ..., date_fn = lubridate::ymd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>dataframe</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>tidyselect</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>date_fn</code></td>
<td>
<p>a function to convert to a date object</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>note: can be called without any <code>...</code> arguments and instead automatically determines which character columns
are actually dates, then proceeds to set them. It checks for the date specified in <code>date_fn</code> and also <code>ymd_hms</code>.
On auto detect mode, it sets <code>ymd_hms</code> output to ymd dates instead of datetimes with hms. This is because of the common occurrence
of trying to extract a <code>ymd</code> date from an excel workbook, and having it come with extra 00:00:00. If you need a datetime, manually
supply the appropriate <a href="https://lubridate.tidyverse.org/">lubridate</a> function.
</p>
<p>Auto mode is experimental. Commonly detected error is a long character string of integers being interpreted as a date.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class="language-R">
tibble::tibble(date_col1 = c("20190101", "20170205"),
date_col2 = c("20201015", "20180909"),
not_date_col = c("a345", "b040")) -&gt; t1

t1

t1 %&gt;%
set_date()

t1 %&gt;%
set_date(date_col1)
</code></pre>


</div>