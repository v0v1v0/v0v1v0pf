<div class="container">

<table style="width: 100%;"><tr>
<td>funLBM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
The functional latent block model
</h2>

<h3>Description</h3>

<p>The funLBM algorithm, proposed by Bouveyron et al. (2018) &lt;doi:10.1111/rssc.12260&gt;, allows to simultaneously cluster the rows and the columns of one or more data matrix where each entry of the matrix is a (univariate or multivariate) function or a time series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">funLBM(X, K, L, maxit = 50, burn = 25, basis.name = "fourier", nbasis = 15,
        nbinit = 1, gibbs.it = 3, display = FALSE, init = "funFEM", mc.cores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>Univariate case: The data array (n x p x T) where each entry corresponds to the measure of one individual i, i=1,...,n, for a functional variable j, j=1,...,p, at point t, t=1,...,T.
Multivariate case: a list of data array as described hereinabove with one data array by variable.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>

<p>The number of row clusters,
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>

<p>The number of column clusters,
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>The maximum number of iterations of the SEM-Gibbs algorithm (default is 100),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>

<p>The number of of iterations of the burn-in period (default is 50),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis.name</code></td>
<td>

<p>The name ('fourier' or 'spline') of the basis functions used for the decomposition of the functions (default is 'fourier'),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>

<p>Number of the basis functions used for the decomposition of the functions (default is 15),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbinit</code></td>
<td>

<p>Number of initializations (default is 3),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gibbs.it</code></td>
<td>

<p>Number of Gibbs iterations (default is 3),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>display</code></td>
<td>

<p>Binary value. If TRUE, information about the iterations is displayed,
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>The type of initialization: 'random', 'kmeans' or 'funFEM'. Default is 'kmeans',
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mc.cores</code></td>
<td>

<p>The number of cores for parallel computing (default is 1),
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional parameters to provide to sub-functions.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The resulting object contains, in addition to call information:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>prms</code></td>
<td>
<p>A list containing all fited parameters for the best model (according to ICL)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>The dummy matrix of row clustering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>The dummy matrix of column clustering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_clust</code></td>
<td>
<p>The group memberships of rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_clust</code></td>
<td>
<p>The group memberships of columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allPrms</code></td>
<td>
<p>A list containing the fited parameters for all tested models</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>The log-likelihood of the best model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>icl</code></td>
<td>
<p>The value of ICL for the best model</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>C. Bouveyron, L. Bozzi, J. Jacques and F.-X. Jollois, The Functional Latent Block Model for the Co-Clustering of Electricity Consumption Curves, Journal of the Royal Statistical Society, Series C, 2018 (https://doi.org/10.1111/rssc.12260).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Univariate example: Co-clustering on simulated data
set.seed(12345)
X = simulateData(n = 30, p = 30, t = 15)
out = funLBM(X$data,K=4,L=3)

# Visualization of results
plot(out,type='blocks')
plot(out,type='proportions')
plot(out,type='means')

# Evaluating clustering results
ari(out$col_clust,X$col_clust)
ari(out$row_clust,X$row_clust)

## Multivariate example:
X = simulateData2(n = 50, p = 50, t = 15)
out = funLBM(list(X$data1,X$data2),K=4,L=3)

# Visualization of results
plot(out,type='blocks')
plot(out,type='proportions')
plot(out,type='means')

# Evaluating clustering results
ari(out$col_clust,X$col_clust)
ari(out$row_clust,X$row_clust)

## The following examples could take a few minutes to run
## and depend on the number of available CPU cores!

## Co-clustering on simulated data with parallel model selection
#X = simulateData(n = 30, p = 30, t = 15)
#out = funLBM(X$data,K=2:4,L=2:4,mc.cores = 4)

## Evaluating clustering results
#ari(out$col_clust,X$col_clust)
#ari(out$row_clust,X$row_clust)

## Co-clustering of Velib data
#data(Velib)
#out = funLBM(Velib$data,K=4,L=2)

## Visualization of results
#plot(out,type='blocks')
#plot(out,type='proportions')
#plot(out,type='means')

</code></pre>


</div>