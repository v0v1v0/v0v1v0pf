<div class="container">

<table style="width: 100%;"><tr>
<td>pairwiseRangemaps</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Pairwise intersection (and union) of range maps
</h2>

<h3>Description</h3>

<p>This function takes a set of rangemaps and returns a matrix containing the areas of their pairwise intersections; optionally, also their individual areas and/our their areas of pairwise unions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">pairwiseRangemaps(rangemaps, projection = NULL, diag = TRUE, unions = TRUE,
verbosity = 2, Ncpu = 1, nchunks = 1, subchunks = NULL,
filename = "rangemap_matrix.csv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rangemaps</code></td>
<td>

<p>a character vector of rangemap filenames, including the extension (e.g. ".shp" or ".gpkg"), and the folder paths if not in the woorking directory.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projection</code></td>
<td>

<p>DEPRECATED argument, previously required by function 'PBSmapping::importShapefile', which is now here replaced with 'terra::vect'. Will be ignored with a message if provided. Mind that area computations are more accurate with unprojected input maps (see ?terra::expanse).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag</code></td>
<td>

<p>logical, whether to fill the diagonal of the resulting matrix with the area of each rangemap. The default is TRUE, and it is also automatically set to TRUE (as it is necessary) if unions = TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unions</code></td>
<td>

<p>logical, whether to fill the upper triangle of the resulting matrix with the area of union of each pair of rangemaps. The default is TRUE. It is not as computationally intensive as the intersection, as it is calculated not with spatial but with algebraic operations within the matrix (union = area1 + area2 - intersection).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>

<p>integer number indicating the amount of progress messages to display.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ncpu</code></td>
<td>

<p>integer indicating the number of CPUs (central processing units) to employ if parallel computing is to be used. The default is 1 CPU, which implies no parallel computing, but you may want to increase this if you have many and/or large rangemaps and your machine has more cores that can be used simultaneously. You can find out the total number of cores in you machine with the <code>detectCores</code> function of the <span class="pkg">parallel</span> package; a usually wise option is to use all cores except one (i.e., Ncpu = parallel::detectCores()-1).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nchunks</code></td>
<td>

<p>either an integer indicating the number of chunks of rows in which to divide the results matrix for calculations, or character "decreasing" to indicate that the matrix should be divided into chunks of decreasing number of rows (as intersections are calculated in the lower triangle, rows further down the matrix have an increasing number of intersections to compute). Note, however, that rangemap size, not rangemap number, is the main determinant of computation time. The default is 1 (no division of the matrix) but, if you have many rangemaps, the process can get clogged. With chunks, each set of rows of the matrix is calculated and saved to disk, and the memory is cleaned before the next chunk begins.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subchunks</code></td>
<td>

<p>optional integer vector specifying which chunks to actually calculate. This is useful if a previous, time-consuming run of pairwiseRangemaps was interrupted (e.g. by a power outage) and you want to calculate only the remaining chunks.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>

<p>optional character vector indicating the name of the file to save the resulting matrix to.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This computation can be intensive and slow, especially if you have many and/or large rangemaps, due to the time needed for pairwise spatial operations between them. You can set nchunks="decreasing" for the matrix to be calculated in parts and the memory cleaned between one part and the next; and, if your computer has more than one core that you can use, you can increase 'Ncpu' to get parallel computing.
</p>


<h3>Value</h3>

<p>This function returns a square matrix containing, in the lower triangle, the area of the pair-wise intersections among the input 'rangemaps'; in the diagonal (if diag = TRUE or union = TRUE), the area of each rangemap; and in the upper triangle (if union = TRUE), the area of the pair-wise unions among the rangemaps.
</p>


<h3>Note</h3>

<p>This function previously used the <span class="pkg">PBSmapping</span> package to import and intersect the rangemaps and to calculate areas. Now it uses the <span class="pkg">terra</span> package instead. Mind that, after the implementation of spherical geometry, area computations are more accurate with unprojected input maps (see ?terra::expanse). Small differences can thus arise between the results of the previous version and the current version (from <span class="pkg">fuzzySim</span> 4.9.4).
</p>


<h3>Author(s)</h3>

<p>A. Marcia Barbosa
</p>


<h3>References</h3>

<p>Barbosa A.M. &amp; Estrada A. (2016) Calcular corotipos sin dividir el territorio en OGUs: una adaptacion de los indices de similitud para su utilizacion directa sobre areas de distribucion. In: Gomez Zotano J., Arias Garcia J., Olmedo Cobo J.A. &amp; Serrano Montes J.L. (eds.), Avances en Biogeografia. Areas de Distribucion: Entre Puentes y Barreras, pp. 157-163. Editorial Universidad de Granada &amp; Tundra Ediciones, Granada (Spain)
</p>


<h3>See Also</h3>

<p><code>rangemapSim</code>
</p>


</div>