<div class="container">

<table style="width: 100%;"><tr>
<td>simul.far</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> FAR(1) process simulation </h2>

<h3>Description</h3>

<p>Simulation of a FAR process using a Gram-Schmidt basis.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simul.far(m=12,
  n=100,
  base=base.simul.far(24, 5),
  d.rho=diag(c(0.45, 0.9, 0.34, 0.45)),
  alpha=diag(c(0.5, 0.23, 0.018)),
  cst1=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p> Integer. Number of discretization points. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p> Integer. Number of observations. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p> A functional basis expressed as a matrix, as the matrix
created by <code>base.simul.far</code> or with
<code>orthonormalization</code>.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d.rho</code></td>
<td>
<p> Numerical matrix. Expression of the first bloc of the
linear operator in the Gram-Schmidt basis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p> Numerical matrix. Expression of the first bloc of the
covariance operator in the Gram-Schmidt basis. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cst1</code></td>
<td>
<p> Numeric. Perturbation coefficient on the linear
operator. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function simulate a FAR(1) process with a strong white noise.
</p>
<p>The simulation is realized in two steps.
</p>
<p>First step, the function compute a FAR(1) process <code class="reqn">T_n</code> in a
functional space (that we call in the sequel H) using a simple
equation and the <code>d.rho</code>, <code>alpha</code> and <code>cst</code> parameters.
</p>
<p>Second step, the process <code class="reqn">T_n</code> is projected in the canonical
basis using the <code>base</code> linear projector. 
</p>
<p>The <code>base</code> basis need to be a orthonormal basis wide enought. In the 
contrary, the function use the <code>orthonormalization</code> function
to make it so. Notice that the size of this matrix corresponds to the
dimension of the "modelization space" H (let's call it
<code class="reqn">m_2</code>). Of course, the larger <code>m2</code> the better the
functionnal approximation is. Whatever, keep in mind that
<code>m2</code>=2<code>m</code> is a good compromise, in order to avoid the memory
limits.
</p>
<p>In H, the linear operator <code class="reqn">\rho</code> is expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    \code{d.rho} &amp; 0 \cr%
    0 &amp; eps.rho%
    \end{array}\right)%
  </code>
</p>

<p>Where <code>d.rho</code> is the matrix provided in the call, the two 0 are
in fact two blocks of 0, and eps.rho is a diagonal matrix having on
his diagonal the terms:
</p>
<p style="text-align: center;"><code class="reqn">\left(\varepsilon_{k+1}, \varepsilon_{k+2}, \ldots, %
    \varepsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\varepsilon_{i}=\frac{\code{cst1}}{i^2}+%
    \frac{1-\code{cst1}}{e^i}</code>
</p>

<p>and k is the length of the <code>d.rho</code> diagonal.
</p>
<p>The <code>d.rho</code> matrix can be viewed as the information and the
eps.rho matrix as a perturbation. In this logic, the norm of eps.rho
need to be smaller than the one of <code>d.rho</code>.
</p>
<p>In H, <code class="reqn">C^T</code>, the covariance operator of <code class="reqn">T_n</code>, is
defined by:
</p>
<p style="text-align: center;"><code class="reqn">
    \left(\begin{array}{cc}%
    m_2 * \code{alpha} &amp; 0 \cr%
    0 &amp; eps.alpha%
    \end{array}\right)%
  </code>
</p>

<p>Where <code>alpha</code> is the matrix provided in the call, the two 0 are
in fact two blocks of 0, and eps.alpha is a diagonal matrix having on
his diagonal the terms:
</p>
<p style="text-align: center;"><code class="reqn">\left(\epsilon_{k+1}, \epsilon_{k+2}, \ldots, %
    \epsilon_{\code{m2}}\right)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\epsilon_{i}=\frac{\code{cst1}}{i}</code>
</p>



<h3>Value</h3>

<p>A <code>fdata</code> object containing one variable ("var") which is a
FAR(1) process of length <code>n</code> with <code>p</code> discretization
points.
</p>


<h3>Note</h3>

<p>To simulate <code class="reqn">T_n</code>, the function creates a white noise
<code class="reqn">E_n</code> having the following covariance operator:
</p>
<p style="text-align: center;"><code class="reqn">C^T - \rho * C^T * t({\rho})</code>
</p>

<p>where t(.) is the transposition operator.
<code class="reqn">T_n</code> is the computed using the equation:
</p>
<p style="text-align: center;"><code class="reqn">T_{n+1} = \rho * T_n + E_n</code>
</p>



<h3>Author(s)</h3>

<p> J. Damon, S. Guillas </p>


<h3>See Also</h3>

 <p><code>simul.far.sde</code>, <code>simul.far.wiener</code>,
<code>simul.farx</code>, <code>simul.wiener</code>,
<code>base.simul.far</code>.  </p>


<h3>Examples</h3>

<pre><code class="language-R">  far1 &lt;- simul.far(m=64,n=100)
  summary(far1)
  print(far(far1,kn=4))
  par(mfrow=c(2,1))
  plot(far1,date=1)
  plot(select.fdata(far1,date=1:5),whole=TRUE,separator=TRUE)
</code></pre>


</div>