<div class="container">

<table style="width: 100%;"><tr>
<td>fdadbscan</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Performs density-based clustering for functional data with amplitude and
phase separation</h2>

<h3>Description</h3>

<p>This function extends <code>DBSCAN</code> to functional data. It includes the
possibility to separate amplitude and phase information.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fdadbscan(
  x,
  y,
  warping_class = c("affine", "dilation", "none", "shift", "srsf"),
  centroid_type = "mean",
  metric = c("l2", "pearson"),
  cluster_on_phase = FALSE,
  use_verbose = TRUE,
  warping_options = c(0.15, 0.15),
  maximum_number_of_iterations = 100L,
  number_of_threads = 1L,
  parallel_method = 0L,
  distance_relative_tolerance = 0.001,
  use_fence = FALSE,
  check_total_dissimilarity = TRUE,
  compute_overall_center = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector of length <code class="reqn">M</code> or a numeric matrix of shape
<code class="reqn">N \times M</code> or an object of class <code>funData::funData</code>. If a numeric
vector or matrix, it specifies the grid(s) of size <code class="reqn">M</code> on which each of
the <code class="reqn">N</code> curves have been observed. If an object of class
<code>funData::funData</code>, it contains the whole functional data set and the <code>y</code>
argument is not used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Either a numeric matrix of shape <code class="reqn">N \times M</code> or a numeric array
of shape <code class="reqn">N \times L \times M</code> or an object of class <code>fda::fd</code>. If a
numeric matrix or array, it specifies the <code class="reqn">N</code>-sample of
<code class="reqn">L</code>-dimensional curves observed on grids of size <code class="reqn">M</code>. If an object
of class <code>fda::fd</code>, it contains all the necessary information about the
functional data set to be able to evaluate it on user-defined grids.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warping_class</code></td>
<td>
<p>A string specifying the warping class Choices are
<code>"affine"</code>, <code>"dilation"</code>, <code>"none"</code>, <code>"shift"</code> or <code>"srsf"</code>. Defaults to
<code>"affine"</code>. The SRSF class is the only class which is boundary-preserving.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centroid_type</code></td>
<td>
<p>A string specifying the type of centroid to compute.
Choices are <code>"mean"</code>, <code>"median"</code> <code>"medoid"</code>, <code>"lowess"</code> or <code>"poly"</code>.
Defaults to <code>"mean"</code>. If LOWESS appproximation is chosen, the user can
append an integer between 0 and 100 as in <code>"lowess20"</code>. This number will be
used as the smoother span. This gives the proportion of points in the plot
which influence the smooth at each value. Larger values give more
smoothness. The default value is 10%. If polynomial approximation is
chosen, the user can append an positive integer as in <code>"poly3"</code>. This
number will be used as the degree of the polynomial model. The default
value is <code>4L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>A string specifying the metric used to compare curves. Choices
are <code>"l2"</code> or <code>"pearson"</code>. Defaults to <code>"l2"</code>. Used only when
<code>warping_class != "srsf"</code>. For the boundary-preserving warping class, the
L2 distance between the SRSFs of the original curves is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_on_phase</code></td>
<td>
<p>A boolean specifying whether clustering should be
based on phase variation or amplitude variation. Defaults to <code>FALSE</code> which
implies amplitude variation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_verbose</code></td>
<td>
<p>A boolean specifying whether the algorithm should output
details of the steps to the console. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warping_options</code></td>
<td>
<p>A numeric vector supplied as a helper to the chosen
<code>warping_class</code> to decide on warping parameter bounds. This is used only
when <code>warping_class != "srsf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maximum_number_of_iterations</code></td>
<td>
<p>An integer specifying the maximum number
of iterations before the algorithm stops if no other convergence criterion
was met. Defaults to <code>100L</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>number_of_threads</code></td>
<td>
<p>An integer value specifying the number of threads
used for parallelization. Defaults to <code>1L</code>. This is used only when
<code>warping_class != "srsf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel_method</code></td>
<td>
<p>An integer value specifying the type of desired
parallelization for template computation, If <code>0L</code>, templates are computed
in parallel. If <code>1L</code>, parallelization occurs within a single template
computation (only for the medoid method as of now). Defaults to <code>0L</code>. This
is used only when <code>warping_class != "srsf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance_relative_tolerance</code></td>
<td>
<p>A numeric value specifying a relative
tolerance on the distance update between two iterations. If all
observations have not sufficiently improved in that sense, the algorithm
stops. Defaults to <code>1e-3</code>. This is used only when <code>warping_class != "srsf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_fence</code></td>
<td>
<p>A boolean specifying whether the fence algorithm should be
used to robustify the algorithm against outliers. Defaults to <code>FALSE</code>. This
is used only when <code>warping_class != "srsf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_total_dissimilarity</code></td>
<td>
<p>A boolean specifying whether an additional
stopping criterion based on improvement of the total dissimilarity should
be used. Defaults to <code>TRUE</code>. This is used only when <code>warping_class != "srsf"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_overall_center</code></td>
<td>
<p>A boolean specifying whether the overall center
should be also computed. Defaults to <code>FALSE</code>. This is used only when
<code>warping_class != "srsf"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>caps</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#----------------------------------
# Extracts 15 out of the 30 simulated curves in `simulated30_sub` data set
idx &lt;- c(1:5, 11:15)
x &lt;- simulated30_sub$x[idx, ]
y &lt;- simulated30_sub$y[idx, , ]

#----------------------------------
# Runs an HAC with affine alignment, searching for 2 clusters
out &lt;- fdadbscan(
  x = x,
  y = y,
  warping_class = "affine"
)

#----------------------------------
# Then visualize the results
# Either with ggplot2 via ggplot2::autoplot(out)
# or using graphics::plot()
# You can visualize the original and aligned curves with:
plot(out, type = "amplitude")
# Or the estimated warping functions with:
plot(out, type = "phase")
</code></pre>


</div>