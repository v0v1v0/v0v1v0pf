<div class="container">

<table style="width: 100%;"><tr>
<td>estimkiener11</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation Functions with 5, 7 or 11 Quantiles</h2>

<h3>Description</h3>

<p>Several functions to estimate the parameters of asymmetric Kiener distributions 
with just 5, 7 or 11 quantiles.
</p>


<h3>Usage</h3>

<pre><code class="language-R">estimkiener11(x11, p11, ord = 7, maxk = 10)

estimkiener7(x7, p7, maxk = 10)

estimkiener5(x5, p5, maxk = 20, maxe = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>ord</code></td>
<td>
<p>integer. Option for probability selection and treatment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxk</code></td>
<td>
<p>numeric. Maximum value for k (kappa).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x5, x7, x11</code></td>
<td>
<p>vector of 5, 7 or 11 quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p5, p7, p11</code></td>
<td>
<p>vector of 5, 7 or 11 probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxe</code></td>
<td>
<p>numeric. Maximum value for abs(e) (epsilon).
Maximum is <code>maxe = 1</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions, called by <code>paramkienerX5</code>, <code>paramkienerX7</code>, 
<code>paramkienerX</code>, use 5, 7 or 11 probabilites and quantiles 
to estimate the parameters of Kiener distributions.   
</p>
<p><code>p5, x5</code> are obtained with functions <code>fiveprobs(X)</code> and <code>quantile(p5)</code>.  
</p>
<p><code>p7, x7</code> are obtained with functions <code>sevenprobs(X)</code> and <code>quantile(p7)</code>.  
</p>
<p><code>p11, x11</code> are obtained with functions <code>elevenprobs(X)</code> and <code>quantile(p11)</code>.
</p>
<p>The extraction of the 11 probabilities is controlled with the option <code>ord</code> 
which can take 12 integer values, <code>ord = 7</code> being the default. 
Small dataset should consider <code>ord = 5</code> and 
large dataset can consider <code>ord = 12</code>: 
</p>

<ol>
<li> <p><code>c(p1, 0.35, 0.50, 0.65, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.35, 0.50, 0.65, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.35, 0.50, 0.65, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.35, 0.50, 0.65, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.50, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.50, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
</ol>
<p><code>p5 = fiveprobs(X)</code> corresponds to <code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code>.
</p>
<p><code>p7 = sevenprobs(X)</code> corresponds to <code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code>.
</p>
<p>The above probabilities are then transfered to the <code>quantile</code> function 
whose parameter <code>type</code> can change significantly the extracted quantiles. 
Our experience is that <code>type = 6</code> is appropriate when <code>k &gt; 1.9</code> and 
<code>type = 5</code> is appropriate when <code>k &lt; 1.9</code>. 
Other types <code>type = 8</code> and <code>type = 9</code> can be considered as well. 
The other types should be ignored. 
(Note: when <code>k &lt; 1.5</code>, algorithm <code>algo = "reg"</code> returns better  
results).
</p>
<p>Parameter maxk controls the maximum allowed value for estimated parameter k. 
Reasonnable values are <code>maxk = 10, 15, 20</code>. Default is <code>maxk = 10</code> 
to be consistent with <code>regkienerLX</code>.
</p>


<h3>See Also</h3>

<p><code>elevenprobs</code>, <code>paramkienerX</code>, <code>quantile</code>,
<code>roundcoefk</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">    

require(timeSeries)

## Choose j in 1:16. Choose ord in 1:12 (7 is default)
j    &lt;- 5
ord  &lt;- 5
DS   &lt;- getDSdata()
p11  &lt;- elevenprobs(DS[[j]])
x11  &lt;- quantile(DS[[j]], probs = p11, na.rm = TRUE, names = TRUE, type = 6) 
round(estimkiener11(x11, p11, ord), 3)

## Compare the results obtained with the 12 different values of ord on stock j
compare &lt;- function(ord, x11, p11) {estimkiener11(x11, p11, ord)}
coefk   &lt;- t(sapply(1:12, compare, x11, p11)) 
rownames(coefk) &lt;- 1:12
mcoefk  &lt;- apply(coefk, 2, mean) # the mean of the 12 results above
roundcoefk(rbind(coefk, mcoefk), 13)


</code></pre>


</div>