<div class="container">

<table style="width: 100%;"><tr>
<td>flsa</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fused Lasso Signal Approximator</h2>

<h3>Description</h3>

<p>These functions are the main interface functions for calculating FLSA solutions
</p>


<h3>Usage</h3>

<pre><code class="language-R">flsa(y, lambda1=0, lambda2=NULL, connListObj = NULL, splitCheckSize=1e+09, 
    verbose=FALSE, thr = 1e-09, maxGrpNum=4*length(y))
flsaTopDown(y, lambda1=0, groups=1:length(y), lambda2=NULL)
flsaGetSolution(solObj, lambda1=0, lambda2=NULL, dim=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p> response variable; numeric </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda1</code></td>
<td>
<p> penalty parameter vector (non-negative) for the absolute values uf the coefficients; numeric </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda2</code></td>
<td>
<p> penalty parameter vector (non-negative) for the difference of certain coefficients; numeric </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p> Return solutions for which the given number of groups is present - solutions found exactly at the breakpoint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>connListObj</code></td>
<td>
<p>an object specifying which differences are to be penalized by lambda2. If NULL, then the dimensionalty of y is being used. If y is a vector, the differences of neighbouring coefficients are penalized. If y is a matrix, differences of neighbouring coefficients in 2 dimensions are being penalized. For more information see <code>connListObj</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>splitCheckSize</code></td>
<td>
<p>a parameter specifying from which size on, groups of variables are not being checked for breaking up; can be used to reduce computation time; may lead to inaccurate results</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solObj</code></td>
<td>
<p>Solution object as returned by FLSA if lambda2=NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>dimensions how the result should be formatted for a specific lambda. Used to format the 2-dimensional FLSA as a matrix in the response. For this, just include the dimensions of <code>y</code> as <code>dim</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>print status messages during fitting</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thr</code></td>
<td>
<p>the error threshold used in the algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxGrpNum</code></td>
<td>
<p>if every step of the algorithm, a group with a higher number is generated; this limits the number of steps the algorithm can take</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>flsa</code> is the main function for calculate a <code>flsa</code> fit. If lambda2=NULL, then it returns an object that encodes the whole solution path. Solutions for specific values of lambda1 and lambda2 can then be obtained by using <code>flsaGetSolution</code>.
</p>
<p><code>flsaTopDown</code> calculates the solution of the 1-dimensional FLSA, starting at large values of lambda2. If only solutions for large values of lambda2 are needed, this is more efficient.
</p>


<h3>Author(s)</h3>

<p>Holger Hoefling</p>


<h3>See Also</h3>

<p><code>connListObj</code></p>


<h3>Examples</h3>

<pre><code class="language-R">library(flsa)
# generate some artificial data, 1 and 2 dimensional
y &lt;- rnorm(100)
y2Dim = matrix(rnorm(100), ncol=10)

### apply function flsa and get solution directly
lambda2= 0:10/10
res &lt;- flsa(y, lambda2=lambda2)
res2Dim &lt;- flsa(y2Dim, lambda2=lambda2)

### apply the function and get the solution later
resSolObj &lt;- flsa(y, lambda2=NULL)
resSolObjTopDown &lt;- flsaTopDown(y)
resSolObj2Dim &lt;- flsa(y2Dim, lambda2=NULL)

res2 &lt;- flsaGetSolution(resSolObj, lambda2=lambda2)
### here note that the solution object does not store that the input was 2 dimensional
### therefore, res2Dim does not give out the solution as a 2 
### dimensional matrix (unlike the direct version above)
res2Dim2 &lt;- flsaGetSolution(resSolObj2Dim, lambda2=lambda2)

</code></pre>


</div>