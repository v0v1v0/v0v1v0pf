<div class="container">

<table style="width: 100%;"><tr>
<td>emfrail</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting semi-parametric shared frailty models with the EM algorithm</h2>

<h3>Description</h3>

<p>Fitting semi-parametric shared frailty models with the EM algorithm
</p>


<h3>Usage</h3>

<pre><code class="language-R">emfrail(formula, data, distribution = emfrail_dist(),
  control = emfrail_control(), model = FALSE, model.matrix = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula that contains on the left hand side an object of the type <code>Surv</code>
and on the right hand side a <code>+cluster(id)</code> statement. Two special statments may also be used:
<code>+strata()</code> for specifying a grouping column that will represent different strata and
<code>+terminal()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.frame</code> in which the formula argument can be evaluated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p>An object as created by <code>emfrail_dist</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>An object as created by <code>emfrail_control</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Logical. Should the model frame be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model.matrix</code></td>
<td>
<p>Logical. Should the model matrix be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments, currently used to warn about deprecated argument names</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>emfrail</code> function fits shared frailty models for processes which have intensity
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t) = z \lambda_0(t) \exp(\beta' \mathbf{x})</code>
</p>

<p>with a non-parametric (Breslow) baseline intensity <code class="reqn">\lambda_0(t)</code>. The outcome
(left hand side of the <code>formula</code>) must be a <code>Surv</code> object.
</p>
<p>If the object is <code>Surv(tstop, status)</code> then the usual failure time data is represented.
Gap-times between recurrent events are represented in the same way.
If the left hand side of the formula is created as <code>Surv(tstart, tstop, status)</code>, this may represent a number of things:
(a) recurrent events episodes in calendar time where a recurrent event episode starts at <code>tstart</code> and ends at <code>tstop</code>
(b) failure time data with time-dependent covariates where <code>tstop</code> is the time of a change in covariates or censoring
(<code>status = 0</code>) or an event time (<code>status = 1</code>) or (c) clustered failure time with left truncation, where
<code>tstart</code> is the individual's left truncation time. Unlike regular Cox models, a major distinction is that in case (c) the
distribution of the frailty must be considered conditional on survival up to the left truncation time.
</p>
<p>The <code>+cluster()</code> statement specified the column that determines the grouping (the observations that share the same frailty).
The <code>+strata()</code> statement specifies a column that determines different strata, for which different baseline hazards are calculated.
The <code>+terminal</code> specifies a column that contains an indicator for dependent censoring, and then performs a score test
</p>
<p>The <code>distribution</code> argument must be generated by a call to <code>emfrail_dist</code>. This determines the
frailty distribution, which may be one of gamma, positive stable or PVF (power-variance-function), and the starting
value for the maximum likelihood estimation. The PVF family
also includes a tuning parameter that differentiates between inverse Gaussian and compound Poisson distributions.
Note that, with univariate data (at most one event per individual, no clusters), only distributions with finite expectation
are identifiable. This means that the positive stable distribution should have a maximum likelihood on the edge of the parameter
space (<code class="reqn">theta = +\inf</code>, corresponding to a Cox model for independent observations).
</p>
<p>The <code>control</code> argument must be generated by a call to <code>emfrail_control</code>. Several parameters
may be adjusted that control the precision of the convergenge criteria or supress the calculation of different
quantities.
</p>


<h3>Value</h3>

<p>An object of class <code>emfrail</code> that contains the following fields:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>A named vector of the estimated regression coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hazard</code></td>
<td>
<p>The breslow estimate of the baseline hazard at each event time point, in chronological order</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>The variance-covariance matrix corresponding to the coefficients and hazard, assuming <code class="reqn">\theta</code> constant</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_adj</code></td>
<td>
<p>The variance-covariance matrx corresponding to the
coefficients and hazard, adjusted for the estimation of theta</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>logtheta</code></td>
<td>
<p>The logarithm of the point estimate of <code class="reqn">\theta</code>. For the gamma and
PVF family of distributions, this is the inverse of the estimated frailty variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var_logtheta</code></td>
<td>
<p>The variance of the estimated logarithm of <code class="reqn">\theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci_logtheta</code></td>
<td>
<p>The likelihood-based 95% confidence interval for the logarithm of <code class="reqn">\theta</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frail</code></td>
<td>
<p>The posterior (empirical Bayes) estimates of the frailty for each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>A list with two elements, cluster which is a vector that the sum of the
cumulative hazards from each cluster for a frailty value of 1, and
individual, which is a vector that contains the cumulative hazard corresponding to each row of the data,
multiplied by the corresponding frailty estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tev</code></td>
<td>
<p>The time points of the events in the data set, this is the same length as hazard</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nevents_id</code></td>
<td>
<p>The number of events for each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>A vector of length two with the log-likelihood of the starting Cox model
and the maximized log-likelihood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ca_test</code></td>
<td>
<p>The results of the Commenges-Andersen test for heterogeneity</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens_test</code></td>
<td>
<p>The results of the test for dependence between a recurrent event and a terminal event,
if the <code>+terminal()</code> statement is specified and the frailty distribution is gamma</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zph</code></td>
<td>
<p>The result of <code>cox.zph</code> called on a model with the estimated log-frailties as offset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula, distribution, control</code></td>
<td>
<p>The original arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nobs, fitted</code></td>
<td>
<p>Number of observations and fitted values (i.e. <code class="reqn">z \exp(\beta^T x)</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mf</code></td>
<td>
<p>The <code>model.frame</code>, if <code>model = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mm</code></td>
<td>
<p>The <code>model.matrix</code>, if <code>model.matrix = TRUE</code></p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Several options in the <code>control</code> arguemnt shorten the running time for <code>emfrail</code> significantly.
These are disabling the adjustemnt of the standard errors (<code>se_adj = FALSE</code>), disabling the likelihood-based confidence intervals (<code>lik_ci = FALSE</code>) or
disabling the score test for heterogeneity (<code>ca_test = FALSE</code>).
</p>
<p>The algorithm is detailed in the package vignette. For the gamma frailty,
the results should be identical with those from <code>coxph</code> with <code>ties = "breslow"</code>.
</p>


<h3>Author(s)</h3>

<p>Theodor Balan <a href="mailto:hello@tbalan.com">hello@tbalan.com</a>
</p>


<h3>References</h3>

<p>Balan TA, Putter H (2019) "frailtyEM: An R Package for Estimating Semiparametric Shared Frailty Models", <em>Journal of Statistical Software</em> <strong>90</strong>(7) 1-29. doi:10.18637/jss.v090.i07
</p>


<h3>See Also</h3>

<p><code>plot.emfrail</code> and <code>autoplot.emfrail</code> for plot functions directly available, <code>emfrail_pll</code> for calculating <code class="reqn">\widehat{L}(\theta)</code> at specific values of <code class="reqn">\theta</code>,
<code>summary.emfrail</code> for transforming the <code>emfrail</code> object into a more human-readable format and for
visualizing the frailty (empirical Bayes) estimates,
<code>predict.emfrail</code> for calculating and visalizing conditional and marginal survival and cumulative
hazard curves. <code>residuals.emfrail</code> for extracting martingale residuals and <code>logLik.emfrail</code> for extracting
the log-likelihood of the fitted model.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
m_gamma &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                   data =  rats)

# Inverse Gaussian distribution
m_ig &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                data =  rats,
                distribution = emfrail_dist(dist = "pvf"))

# for the PVF distribution with m = 0.75
m_pvf &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                 data =  rats,
                 distribution = emfrail_dist(dist = "pvf", pvfm = 0.75))

# for the positive stable distribution
m_ps &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                data =  rats,
                distribution = emfrail_dist(dist = "stable"))
## Not run: 
# Compare marginal log-likelihoods
models &lt;- list(m_gamma, m_ig, m_pvf, m_ps)

models
logliks &lt;- lapply(models, logLik)

names(logliks) &lt;- lapply(models,
                         function(x) with(x$distribution,
                                          ifelse(dist == "pvf",
                                                 paste(dist, "/", pvfm),
                                                 dist))
)

logliks

## End(Not run)

# Stratified analysis
## Not run: 
  m_strat &lt;- emfrail(formula = Surv(time, status) ~  rx + strata(sex) + cluster(litter),
                     data =  rats)

## End(Not run)


# Test for conditional proportional hazards (log-frailty as offset)
## Not run: 
m_gamma &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
  data =  rats, control = emfrail_control(zph = TRUE))
par(mfrow = c(1,2))
plot(m_gamma$zph)

## End(Not run)

# Draw the profile log-likelihood
## Not run: 
  fr_var &lt;- seq(from = 0.01, to = 1.4, length.out = 20)

  # For gamma the variance is 1/theta (see parametrizations)
  pll_gamma &lt;- emfrail_pll(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                           data =  rats,
                           values = 1/fr_var )
  plot(fr_var, pll_gamma,
       type = "l",
       xlab = "Frailty variance",
       ylab = "Profile log-likelihood")


  # Recurrent events
  mod_rec &lt;- emfrail(Surv(start, stop, status) ~ treatment + cluster(id), bladder1)
  # The warnings appear from the Surv object, they also appear in coxph.

  plot(mod_rec, type = "hist")

## End(Not run)

# Left truncation
## Not run: 
  # We simulate some data with truncation times
  set.seed(2018)
  nclus &lt;- 300
  nind &lt;- 5
  x &lt;- sample(c(0,1), nind * nclus, TRUE)
  u &lt;- rep(rgamma(nclus,1,1), each = 3)

  stime &lt;- rexp(nind * nclus, rate = u * exp(0.5 * x))

  status &lt;- ifelse(stime &gt; 5, 0, 1)
  stime[status == 0] &lt;- 5

  # truncate uniform between 0 and 2
  ltime &lt;- runif(nind * nclus, min = 0, max = 2)

  d &lt;- data.frame(id = rep(1:nclus, each = nind),
                  x = x,
                  stime = stime,
                  u = u,
                  ltime = ltime,
                  status = status)
  d_left &lt;- d[d$stime &gt; d$ltime,]

  mod &lt;- emfrail(Surv(stime, status)~ x + cluster(id), d)
  # This model ignores the left truncation, 0.378 frailty variance:
  mod_1 &lt;- emfrail(Surv(stime, status)~ x + cluster(id), d_left)

  # This model takes left truncation into account,
 # but it considers the distribution of the frailty unconditional on the truncation
 mod_2 &lt;- emfrail(Surv(ltime, stime, status)~ x + cluster(id), d_left)

  # This is identical with:
  mod_cox &lt;- coxph(Surv(ltime, stime, status)~ x + frailty(id), data = d_left)


  # The correct thing is to consider the distribution of the frailty given the truncation
  mod_3 &lt;- emfrail(Surv(ltime, stime, status)~ x + cluster(id), d_left,
                   distribution = emfrail_dist(left_truncation = TRUE))

  summary(mod_1)
  summary(mod_2)
  summary(mod_3)

## End(Not run)
</code></pre>


</div>