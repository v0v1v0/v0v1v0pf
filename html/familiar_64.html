<div class="container">

<table style="width: 100%;"><tr>
<td>create_randomised_groups</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create randomised groups Creates randomised groups, e.g. for tests that
depend on splitting (continuous) data into groups, such as the
Hosmer-Lemeshow test</h2>

<h3>Description</h3>

<p>The default fast mode is based on random sampling, whereas the slow mode is
based on probabilistic joining of adjacent groups. As the name suggests, fast
mode operates considerably more efficient.
</p>


<h3>Usage</h3>

<pre><code class="language-R">create_randomised_groups(
  x,
  y = NULL,
  sample_identifiers,
  n_max_groups = NULL,
  n_min_groups = NULL,
  n_min_y_in_group = NULL,
  n_groups_init = 30,
  fast_mode = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector with data used for sorting. Groups are formed based on
adjacent values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vector with markers, e.g. the events. Should be 0 or 1 (for an
event).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample_identifiers</code></td>
<td>
<p>data.table with sample_identifiers. If provide, a
list of grouped sample_identifiers will be returned, and integers
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_max_groups</code></td>
<td>
<p>Maximum number of groups that need to be formed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_min_groups</code></td>
<td>
<p>Minimum number of groups that need to be formed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_min_y_in_group</code></td>
<td>
<p>Minimum number of y=1 in each group for a valid
group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_groups_init</code></td>
<td>
<p>Number of initial groups (default: 30)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fast_mode</code></td>
<td>
<p>Enables fast randomised grouping mode (default: TRUE)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Creates randomised groups, e.g. for tests that depend on splitting
(continuous) data into groups, such as the Hosmer-Lemeshow test
</p>

<ul>
<li>
<p> Determine maximum number of groups: either 10 or number so that each group
has 5 events (if smaller).
</p>
</li>
<li>
<p> Determine minimum number of groups (half the maximum, or 2). Groups cannot
the exceed corresponding group size.
</p>
</li>
<li>
<p> Start with 50 very small groups.
</p>
</li>
<li>
<p> Iterate while the maximum number of groups has not been reached.
</p>

<ul>
<li>
<p> Selection probability is 1/n_j
</p>
</li>
<li>
<p> If a group exceeds the maximum group size, selection probability is 0.
</p>

<ul><li>
<p> Break if all groups have exceeded the maximum size.
</p>
</li></ul>
</li>
<li>
<p> Get cumulative probability and normalise by total.
</p>
</li>
<li>
<p> Draw random number between 0 and 1.
</p>
</li>
<li>
<p> Select the group which has a cumulative probability range that contains
the random number.
</p>
</li>
<li>
<p> Draw a random number to decide whether to join the group with right or
left adjacent group, and assign the group number to the adjacent group.
Probability depends on the size of adjacent groups. Smaller sizes have
greater probability of being joined. No joining with groups already
exceeding the maximum group size. If surrounded on both sides, force
selection probability for current group to 0. If joining is possible,
update group size, and selection probability for the new group.
</p>
</li>
</ul>
</li>
<li>
<p> Check that 5 events are present in each group. For each group with &lt; 5
events, try to join with neighbours.
</p>
</li>
<li>
<p> Start over if the number of groups is smaller than the minimum number.
</p>
</li>
</ul>
<h3>Value</h3>

<p>List of group sample ids or indices.
</p>


</div>