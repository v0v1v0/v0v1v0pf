<div class="container">

<table style="width: 100%;"><tr>
<td>n_unik</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prints the number of unique elements in a data set</h2>

<h3>Description</h3>

<p>This utility tool displays the number of unique elements in one or multiple data.frames
as well as their number of NA values.
</p>


<h3>Usage</h3>

<pre><code class="language-R">n_unik(x)

## S3 method for class 'vec_n_unik'
print(x, ...)

## S3 method for class 'list_n_unik'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A formula, with data set names on the LHS and variables on the RHS,
like <code>data1 + data2 ~ var1 + var2</code>. The following special variables are
admitted: <code>"."</code> to get default values, <code>".N"</code> for the number of observations, <code>".U"</code>
for the number of unique rows, <code>".NA"</code> for the number of rows with at least one NA.
Variables can be combined with <code>"^"</code>, e.g. <code>df~id^period</code>; use <code>id%^%period</code> to also
include the terms on both sides. Note that using <code>:</code> and <code>*</code>
is equivalent to <code>^</code> and <code style="white-space: pre;">⁠%^%⁠</code>. Sub select with <code>id[cond]</code>, when doing so <code>id</code>
is automatically included. Conditions can be chained, as in <code>id[cond1, cond2]</code>.
Use <code>NA(x, y)</code> in conditions instead of <code>is.na(x) | is.na(y)</code>. Use the <code style="white-space: pre;">⁠!!⁠</code>
operator to have both a condition and its opposite. To compare the keys
in two data sets, use <code>data1:data2</code>. If not a formula, <code>x</code> can be: a vector
(displays the # of unique values); a <code>data.frame</code> (default values are displayed),
or a "sum" of data sets like in <code>x = data1 + data2</code>, in that case it is equivalent
to <code>data1 + data2 ~ .</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a vector containing the number of unique values per element. If several
data sets were provided, a list is returned, as long as the number of data sets,
each element being a vector of unique values.
</p>


<h3>Special values and functions</h3>

<p>In the formula, you can use the following special values: <code>"."</code>, <code>".N"</code>, <code>".U"</code>, and <code>".NA"</code>.
</p>

<dl>
<dt><code>"."</code></dt>
<dd>
<p>Accesses the default values. If there is only one data set and the
data set is <em>not</em> a <code>data.table</code>, then the default is to display the number of
observations and the number of unique rows. If the data is a <code>data.table</code>, the number
of unique items in the key(s) is displayed instead of the number of unique rows
(if the table has keys of course). If there are two or more data sets, then the
default is to display the unique items for: a) the variables common across all data sets,
if there's less than 4, and b) if no variable is shown in a), the number of variables
common across at least two data sets, provided there are less than 5. If the data sets are
data tables, the keys are also displayed on top of the common variables. In any case, the
number of observations is always displayed.</p>
</dd>
<dt><code>".N"</code></dt>
<dd>
<p>Displays the number of observations.</p>
</dd>
<dt><code>".U"</code></dt>
<dd>
<p>Displays the number of unique rows.</p>
</dd>
<dt><code>".NA"</code></dt>
<dd>
<p>Displays the number of rows with at least one NA.</p>
</dd>
</dl>
<h3>The <code>NA</code> function</h3>

<p>The special function <code>NA</code> is an equivalent to <code>is.na</code> but can handle several variables.
For instance, <code>NA(x, y)</code> is equivalent to <code>is.na(x) | is.na(y)</code>. You can add as
many variables as you want as arguments. If no argument is provided, as in <code>NA()</code>,
it is identical to having all the variables of the data set as argument.
</p>


<h3>Combining variables</h3>

<p>Use the "hat", <code>"^"</code>, operator to combine several variables. For example <code>id^period</code>
will display the number of unique values of id x period combinations.
</p>
<p>Use the "super hat", <code>"%^%"</code>, operator to also include the terms on both sides.
For example, instead of writing <code>id + period + id^period</code>, you can simply write <code>id%^%period</code>.
</p>
<p>Alternatively, you can use <code>:</code> for <code>^</code> and <code>*</code> for <code style="white-space: pre;">⁠%^%⁠</code>.
</p>


<h3>Sub-selections</h3>

<p>To show the number of unique values for sub samples, simply use <code style="white-space: pre;">⁠[]⁠</code>.
For example, <code>id[x &gt; 10]</code> will display the number of unique <code>id</code> for which <code>x &gt; 10</code>.
</p>
<p>Simple square brackets lead to the inclusion of both the variable and its subset.
For example <code>id[x &gt; 10]</code> is equivalent to <code>id + id[x &gt; 10]</code>.
To include only the sub selection, use double square brackets, as in <code>id[[x &gt; 10]]</code>.
</p>
<p>You can add multiple sub selections at once, only separate them with a comma.
For example <code>id[x &gt; 10, NA(y)]</code> is equivalent to <code>id[x &gt; 10] + id[NA(y)]</code>.
</p>
<p>Use the double negative operator, i.e. <code style="white-space: pre;">⁠!!⁠</code>, to include both a condition and
its opposite at once. For example <code>id[!!x &gt; 10]</code> is equivalent to <code>id[x &gt; 10, !x &gt; 10]</code>.
Double negative operators can be chained, like in <code>id[!!cond1 &amp; !!cond2]</code>, then the
cardinal product of all double negatived conditions is returned.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data = base_did
data$x1.L1 = round(lag(x1~id+period, 1, data))

# By default, just the formatted number of observations
n_unik(data)

# Or the nber of unique elements of a vector
n_unik(data$id)

# number of unique id values and id x period pairs
n_unik(data ~.N + id + id^period)

# use the %^% operator to include the terms on the two sides at once
# =&gt; same as id*period
n_unik(data ~.N + id %^% period)

# using sub selection with []
n_unik(data ~.N + period[!NA(x1.L1)])

# to show only the sub selection: [[]]
n_unik(data ~.N + period[[!NA(x1.L1)]])

# you can have multiple values in [],
# just separate them with a comma
n_unik(data ~.N + period[!NA(x1.L1), x1 &gt; 7])

# to have both a condition and its opposite,
# use the !! operator
n_unik(data ~.N[!!NA(x1.L1)])

# the !! operator works within condition chains
n_unik(data ~.N[!!NA(x1.L1) &amp; !!x1 &gt; 7])

# Conditions can be distributed
n_unik(data ~ (id + period)[x1 &gt; 7])

#
# Several data sets
#

# Typical use case: merging
# Let's create two data sets and merge them

data(base_did)
base_main = base_did
base_extra = sample_df(base_main[, c("id", "period")], 100)
base_extra$id[1:10] = 111:120
base_extra$period[11:20] = 11:20
base_extra$z = rnorm(100)

# You can use db1:db2 to compare the common keys in two data sets
 n_unik(base_main:base_extra)

tmp = merge(base_main, base_extra, all.x = TRUE, by = c("id", "period"))

# You can show unique values for any variable, as before
n_unik(tmp + base_main + base_extra ~ id[!!NA(z)] + id^period)



</code></pre>


</div>