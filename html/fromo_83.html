<div class="container">

<table style="width: 100%;"><tr>
<td>cent_sums</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Centered sums; join and unjoined.</h2>

<h3>Description</h3>

<p>Compute, join, or unjoin centered sums.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cent_sums(v, max_order = 5L, na_rm = FALSE, wts = NULL,
  check_wts = FALSE, normalize_wts = TRUE)

join_cent_sums(ret1, ret2)

unjoin_cent_sums(ret3, ret2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_order</code></td>
<td>
<p>the maximum order of the centered moment to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>whether to remove NA, false by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wts</code></td>
<td>
<p>an optional vector of weights. Weights are ‘replication’
weights, meaning a value of 2 is shorthand for having two observations
with the corresponding <code>v</code> value. If <code>NULL</code>, corresponds to
equal unit weights, the default. Note that weights are typically only meaningfully defined
up to a multiplicative constant, meaning the units of weights are
immaterial, with the exception that methods which check for minimum df will,
in the weighted case, check against the sum of weights. For this reason,
weights less than 1 could cause <code>NA</code> to be returned unexpectedly due
to the minimum condition. When weights are <code>NA</code>, the same rules for checking <code>v</code>
are applied. That is, the observation will not contribute to the moment
if the weight is <code>NA</code> when <code>na_rm</code> is true. When there is no
checking, an <code>NA</code> value will cause the output to be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_wts</code></td>
<td>
<p>a boolean for whether the code shall check for negative
weights, and throw an error when they are found. Default false for speed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize_wts</code></td>
<td>
<p>a boolean for whether the weights should be
renormalized to have a mean value of 1. This mean is computed over elements
which contribute to the moments, so if <code>na_rm</code> is set, that means non-NA
elements of <code>wts</code> that correspond to non-NA elements of the data
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret1</code></td>
<td>
<p>an <code class="reqn">ord+1</code> vector as output by <code>cent_sums</code> consisting of
the count, the mean, then the k through ordth centered sum of some observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret2</code></td>
<td>
<p>an <code class="reqn">ord+1</code> vector as output by <code>cent_sums</code> consisting of
the count, the mean, then the k through ordth centered sum of some observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ret3</code></td>
<td>
<p>an <code class="reqn">ord+1</code> vector as output by <code>cent_sums</code> consisting of
the count, the mean, then the k through ordth centered sum of some observations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a vector the same size as the input consisting of the adjusted version of the input.
When there are not sufficient (non-nan) elements for the computation, <code>NaN</code> are returned.
</p>


<h3>Note</h3>

<p>The moment computations provided by fromo are 
numerically robust, but will often <em>not</em> provide the
same results as the 'standard' implementations,
due to differences in roundoff. We make every attempt to balance
speed and robustness. User assumes all risk from using
the fromo package.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Terriberry, T. "Computing Higher-Order Moments Online."
<a href="http://people.xiph.org/~tterribe/notes/homs.html">http://people.xiph.org/~tterribe/notes/homs.html</a>
</p>
<p>J. Bennett, et. al., "Numerically Stable, Single-Pass, 
Parallel Statistics Algorithms," Proceedings of IEEE
International Conference on Cluster Computing, 2009.
<a href="https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265">https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265</a>
</p>
<p>Cook, J. D. "Accurately computing running variance."
<a href="http://www.johndcook.com/standard_deviation.html">http://www.johndcook.com/standard_deviation.html</a>
</p>
<p>Cook, J. D. "Comparing three methods of computing 
standard deviation."
<a href="http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation">http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
 set.seed(1234)
 x1 &lt;- rnorm(1e3,mean=1)
 x2 &lt;- rnorm(1e3,mean=1)
 max_ord &lt;- 6L
 rs1 &lt;- cent_sums(x1,max_ord)
 rs2 &lt;- cent_sums(x2,max_ord)
 rs3 &lt;- cent_sums(c(x1,x2),max_ord)
 rs3alt &lt;- join_cent_sums(rs1,rs2)
 stopifnot(max(abs(rs3 - rs3alt)) &lt; 1e-7)
 rs1alt &lt;- unjoin_cent_sums(rs3,rs2)
 rs2alt &lt;- unjoin_cent_sums(rs3,rs1)
 stopifnot(max(abs(rs1 - rs1alt)) &lt; 1e-7)
 stopifnot(max(abs(rs2 - rs2alt)) &lt; 1e-7)

</code></pre>


</div>