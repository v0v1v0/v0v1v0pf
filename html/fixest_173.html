<div class="container">

<table style="width: 100%;"><tr>
<td>[.fixest_multi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subsets a fixest_multi object</h2>

<h3>Description</h3>

<p>Subsets a fixest_multi object using different keys.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'fixest_multi'
x[i, sample, lhs, rhs, fixef, iv, I, reorder = TRUE, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>fixest_multi</code> object, obtained from a <code>fixest</code> estimation leading to
multiple results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>An integer vector. Represents the estimations to extract.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sample</code></td>
<td>
<p>An integer vector, a logical scalar, or a character vector. It represents
the <code>sample</code> identifiers for which the results should be extracted. Only valid when the
<code>fixest</code> estimation was a split sample. You can use <code>.N</code> to refer to the last element.
If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>sample</code> to become
the rightmost key (just try it out).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lhs</code></td>
<td>
<p>An integer vector, a logical scalar, or a character vector. It represents
the left-hand-sides identifiers for which the results should be extracted. Only valid when
the <code>fixest</code> estimation contained multiple left-hand-sides. You can use <code>.N</code> to refer to
the last element. If logical, all elements are selected in both cases, but <code>FALSE</code>
leads <code>lhs</code> to become the rightmost key (just try it out).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>An integer vector or a logical scalar. It represents the right-hand-sides
identifiers for which the results should be extracted. Only valid when the <code>fixest</code>
estimation contained multiple right-hand-sides. You can use <code>.N</code> to refer to the last
element. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>rhs</code> to
become the rightmost key (just try it out).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef</code></td>
<td>
<p>An integer vector or a logical scalar. It represents the fixed-effects
identifiers for which the results should be extracted. Only valid when the <code>fixest</code>
estimation contained fixed-effects in a stepwise fashion. You can use <code>.N</code> to refer to the
last element. If logical, all elements are selected in both cases, but <code>FALSE</code> leads <code>fixef</code>
to become the rightmost key (just try it out).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iv</code></td>
<td>
<p>An integer vector or a logical scalar. It represent the stages of the IV. Note
that the length can be greater than 2 when there are multiple endogenous regressors (the
first stage corresponding to multiple estimations). Note that the order of the stages depends
on the <code>stage</code> argument from <code>summary.fixest</code>. If logical, all elements are selected in
both cases, but <code>FALSE</code> leads <code>iv</code> to become the rightmost key (just try it out).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>I</code></td>
<td>
<p>An integer vector. Represents the root element to extract.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reorder</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Indicates whether reordering of the results
should be performed depending on the user input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If the result contains only one estimation,
then if <code>drop = TRUE</code> it will be transformed into a <code>fixest</code> object (instead of <code>fixest_multi</code>).
Its default value can be modified with the function <code>setFixest_multi</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The order with we we use the keys matter. Every time a key <code>sample</code>, <code>lhs</code>, <code>rhs</code>,
<code>fixef</code> or <code>iv</code> is used, a reordering is performed to consider the leftmost-side key
to be the new root.
</p>
<p>Use logical keys to easily reorder. For example, say the object <code>res</code> contains a
multiple estimation with multiple left-hand-sides, right-hand-sides and fixed-effects.
By default the results are ordered as follows: <code>lhs</code>, <code>fixef</code>, <code>rhs</code>.
If you use <code>res[lhs = FALSE]</code>, then the new order is: <code>fixef</code>, <code>rhs</code>, <code>lhs</code>.
With <code>res[rhs = TRUE, lhs = FALSE]</code> it becomes: <code>rhs</code>, <code>fixef</code>, <code>lhs</code>. In both cases
you keep all estimations.
</p>


<h3>Value</h3>

<p>It returns a <code>fixest_multi</code> object. If there is only one estimation left in the object, then
the result is simplified into a <code>fixest</code> object only with <code>drop = TRUE</code>.
</p>


<h3>See Also</h3>

<p>The main fixest estimation functions: <code>feols</code>, <code>fepois</code>,
<code>fenegbin</code>, <code>feglm</code>, <code>feNmlm</code>. Tools for mutliple fixest
estimations: <code>summary.fixest_multi</code>, <code>print.fixest_multi</code>, <code>as.list.fixest_multi</code>,
<code>sub-sub-.fixest_multi</code>, <code>sub-.fixest_multi</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Estimation with multiple samples/LHS/RHS
aq = airquality[airquality$Month %in% 5:6, ]
est_split = feols(c(Ozone, Solar.R) ~ sw(poly(Wind, 2), poly(Temp, 2)),
                  aq, split = ~ Month)

# By default: sample is the root
etable(est_split)

# Let's reorder, by considering lhs the root
etable(est_split[lhs = 1:.N])

# Selecting only one LHS and RHS
etable(est_split[lhs = "Ozone", rhs = 1])

# Taking the first root (here sample = 5)
etable(est_split[I = 1])

# The first and last estimations
etable(est_split[i = c(1, .N)])

</code></pre>


</div>