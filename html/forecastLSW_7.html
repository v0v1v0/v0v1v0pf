<div class="container">

<table style="width: 100%;"><tr>
<td>forecastlpacf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Forecasts future values of the time series <code>x</code> <code>h</code>-steps ahead. (for the specified horizon <code>h</code>) using the lpacf to decide the dimension of the generalized Yule-Walker equations.
</h2>

<h3>Description</h3>

<p>This function forecasts a <code>x</code> time series <code>h</code>-steps
ahead. The time series is assumed to be locally stationary
(actualy locally stationary wavelet) and uses a local prediction
method. The function makes use of the localized partial autocorrelation
function to decide the order of the local Yule-Walker equations
used in the forecast.
</p>


<h3>Usage</h3>

<pre><code class="language-R">forecastlpacf(x,h=1,regularize=TRUE,lag.max=max(10,2*h),forecast.type=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vector containing time series to generate forecasts for.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Integer. Maximum prediction horizon. Forecasts will be given for 
one to <code>h</code> time steps ahead. Currently, for <code>dforecastlpacf</code>
<code>h</code> is hard-coded to be 1. If you want to forecast further
ahead for differenced data then you will have to difference the time
series manually and supply it to <code>forecastlpacf</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regularize</code></td>
<td>

<p>Logical.  If <code>regularize=TRUE</code> then the Yule-Walker matrix is regularized
before prediction using the method from Xie et al. (2007).
If <code>regularize=FALSE</code> then no regularization takes place.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.max</code></td>
<td>
<p>Maximum lag that the <code>lpacf</code> is calculated to.
If this is set too low, i.e. the automated estimation of the
dimension of the Yule-Walker matrix is equal to <code>max.lag</code>,
then the function will print a warning message.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forecast.type</code></td>
<td>

<p>Options are <code>fixed</code>, <code>recursive</code> or <code>extend</code>, see details for further information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Other parameters to be passed to the periodogram and lacv (local autocovariance) estimation, e.g. <code>filter.number</code> and <code>family</code> detailing the wavelet to be used.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function calculates the wavelet periodogram followed by the lacv and
<code>lpacf</code>. 
NOTE: Often when local (windowed) estimates are created one assigns the
estimated value to the central point in the window.
This is NOT the approach we take here when calculating the lacv and
<code>lpacf</code>.
Instead we operate a rear facing window where the estimate is assigned to the
final point in the window.
</p>
<p>The lpacf is used to decide the dimension of the local Yule-Walker equations used for forecasting.
The periodogram is then smoothed using a running mean smoother,
and then to get forecast lacv estimates.
The Yule-Walker equations give the forecast mean for <code>h</code> steps ahead.
The standard deviation of the forecasts is also returned.
</p>
<p>When we are trying to forecast <code>h</code> steps ahead we use the lpacf to decide how many values (<code>p</code>) we should use for prediction.  The original method of Fryzlewicz et al. (2003) decides on <code>p</code> and then does a <code>h</code> step ahead forecast only using the <code>p</code> last values.  This is what <code>forecast.type='fixed'</code> does, regardless of the size of <code>p</code> in relation to <code>h</code>.  Note that the left hand side of the Yule-Walker matrix is fixed and only the right hand size (the forecast lacv) is changing.  Thus the size of <code>h</code> is not explicitly taken into account, there is just an inflated variance in the lacv estimate.
One other option is to use the intermediate forecast values as if they were observed and perform a recursive forecast - this is what <code>forecast.type='recursive'</code> does.  Here everything in the Yule-Walker equations is different for each forecast value.
</p>
<p>A third option is to use <code>forecast.type='fixed'</code> when <code>p</code> is greater or equal to <code>h</code> but then when we are trying to forecast beyond this we extend the Yule-Walker equations to be the same dimension as the forecast horizon.  Thus using <code>h</code> previous values instead of <code>p</code>.  This is what <code>forecast.type='extend'</code> does.
</p>
<p>The method closest to the stationary world is <code>forecast.type='recursive'</code>.
</p>
<p>The <code>dforecastlpacf</code> internally differences the time series
and then performs the local forecasting as in <code>forecastlpacf</code>
but only for one-step ahead. The advantage is that subsequent plotting
routines can nicely show the original time series, with the forecasts
on the original (not differenced) scale with the forecast and appropriate
confidence interval.
</p>


<h3>Value</h3>

<p>An object of class <code>forecastlpacf</code> which is a list
with the following components.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>Returns time series forecasts from one to <code>h</code>-steps ahead.
When <code>h</code> is greater than one multiple predictions are returned in this
vector. In this case, item in position <code>n</code> corresponds to <code>n</code> steps ahead. For example, if <code>h=2</code> then this vector will contain two elements.
The first one corresponds to the prediction one-step-head and the second entry
to the two-steps-ahead prediction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>std.err</code></td>
<td>
<p>Returns the prediction error, which can be used for assessing the prediction intervals. Item <code>n</code> corresponds to the prediction <code>n</code>-steps ahead, as for the <code>mean</code> component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lpacf</code></td>
<td>
<p>Returns the estimated local partial autocovariance function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ci</code></td>
<td>
<p>The confidence interval on lpacf which was used used for the automatic calculation of p</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binwidth</code></td>
<td>
<p>The automatic bandwidth used for the running mean smoother</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Returns the automatic choice of p - the dimension of the generalized Yule-Walker equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The supplied original time series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>Differencing that was applied to the input series before forecasting.
For <code>forecastlpacf</code> this is <code>d=0</code>. For differencing once see
the function <code>dforecastlpacf</code> which returns
<code>d=1</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>R. Killick
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>
<p>Fryzlewicz, P., Van Bellegem, S. and von Sachs, R. (2003) Forecasting
non-stationary time series by wavelet process modelling.
<em>Annals of the Institute of Statistical Mathematics</em>,
<b>55</b>, 737-764.
</p>
<p>Nason, G.P., von Sachs, R., Kroisandt, G. (2000) Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum.
<em>J. Roy. Statist. Soc. B</em>, <b>62</b>, 271-292.
</p>
<p>Xi, Y., Yu, J., Ranneby, B. (2007) Forecasting Using Locally Stationary Wavelet Processes.
</p>


<h3>See Also</h3>

<p><code>lpacf</code>, <code>forecastpanel</code>,
<code>plot.forecastlpacf</code>,
<code>print.forecastlpacf</code>,
<code>summary.forecastlpacf</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># first generate some non-stationary data we want to forecast
set.seed(1)
x=tvar2sim()

#predict 1-step ahead using Daubechies wavelets with 2 vanishing moments, although 
#other choices for the wavelet family and filter are possible (including Haar)
pred&lt;-forecastlpacf(x,h=1,filter.number=2,family="DaubExPhase",forecast.type='recursive')

#pred$mean gives the predicted value, while pred$std.err gives the prediction error
</code></pre>


</div>