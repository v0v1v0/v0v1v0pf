<div class="container">

<table style="width: 100%;"><tr>
<td>running_centered</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compare data to moments computed over a sliding window.</h2>

<h3>Description</h3>

<p>Computes moments over a sliding window, then adjusts the data accordingly, centering, or scaling,
or z-scoring, and so on.
</p>


<h3>Usage</h3>

<pre><code class="language-R">running_centered(v, window = NULL, wts = NULL, na_rm = FALSE,
  min_df = 0L, used_df = 1, lookahead = 0L, restart_period = 100L,
  check_wts = FALSE, normalize_wts = FALSE)

running_scaled(v, window = NULL, wts = NULL, na_rm = FALSE, min_df = 0L,
  used_df = 1, lookahead = 0L, restart_period = 100L, check_wts = FALSE,
  normalize_wts = TRUE)

running_zscored(v, window = NULL, wts = NULL, na_rm = FALSE,
  min_df = 0L, used_df = 1, lookahead = 0L, restart_period = 100L,
  check_wts = FALSE, normalize_wts = TRUE)

running_sharpe(v, window = NULL, wts = NULL, na_rm = FALSE,
  compute_se = FALSE, min_df = 0L, used_df = 1, restart_period = 100L,
  check_wts = FALSE, normalize_wts = TRUE)

running_tstat(v, window = NULL, wts = NULL, na_rm = FALSE, min_df = 0L,
  used_df = 1, restart_period = 100L, check_wts = FALSE,
  normalize_wts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>the window size. if given as finite integer or double, passed through.
If <code>NULL</code>, <code>NA_integer_</code>, <code>NA_real_</code> or <code>Inf</code> are given, equivalent
to an infinite window size. If negative, an error will be thrown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wts</code></td>
<td>
<p>an optional vector of weights. Weights are ‘replication’
weights, meaning a value of 2 is shorthand for having two observations
with the corresponding <code>v</code> value. If <code>NULL</code>, corresponds to
equal unit weights, the default. Note that weights are typically only meaningfully defined
up to a multiplicative constant, meaning the units of weights are
immaterial, with the exception that methods which check for minimum df will,
in the weighted case, check against the sum of weights. For this reason,
weights less than 1 could cause <code>NA</code> to be returned unexpectedly due
to the minimum condition. When weights are <code>NA</code>, the same rules for checking <code>v</code>
are applied. That is, the observation will not contribute to the moment
if the weight is <code>NA</code> when <code>na_rm</code> is true. When there is no
checking, an <code>NA</code> value will cause the output to be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>whether to remove NA, false by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_df</code></td>
<td>
<p>the minimum df to return a value, otherwise <code>NaN</code> is returned.
This can be used to prevent <em>e.g.</em> Z-scores from being computed on only 3
observations. Defaults to zero, meaning no restriction, which can result in 
infinite Z-scores during the burn-in period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>used_df</code></td>
<td>
<p>the number of degrees of freedom consumed, used in the denominator
of the centered moments computation. These are subtracted from the number of
observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lookahead</code></td>
<td>
<p>for some of the operations, the value is compared to 
mean and standard deviation possibly using 'future' or 'past' information
by means of a non-zero lookahead. Positive values mean data are taken from
the future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restart_period</code></td>
<td>
<p>the recompute period. because subtraction of elements can cause
loss of precision, the computation of moments is restarted periodically based on 
this parameter. Larger values mean fewer restarts and faster, though less accurate
results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_wts</code></td>
<td>
<p>a boolean for whether the code shall check for negative
weights, and throw an error when they are found. Default false for speed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize_wts</code></td>
<td>
<p>a boolean for whether the weights should be
renormalized to have a mean value of 1. This mean is computed over elements
which contribute to the moments, so if <code>na_rm</code> is set, that means non-NA
elements of <code>wts</code> that correspond to non-NA elements of the data
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_se</code></td>
<td>
<p>for <code>running_sharpe</code>, return an extra column of the
standard error, as computed by Mertens' correction.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Given the length <code class="reqn">n</code> vector <code class="reqn">x</code>, for
a given index <code class="reqn">i</code>, define <code class="reqn">x^{(i)}</code>
as the vector of 
<code class="reqn">x_{i-window+1},x_{i-window+2},...,x_{i}</code>,
where we do not run over the 'edge' of the vector. In code, this is essentially
<code>x[(max(1,i-window+1)):i]</code>. Then define <code class="reqn">\mu_i</code>, <code class="reqn">\sigma_i</code>
and <code class="reqn">n_i</code> as, respectively, the sample mean, standard deviation and number of
non-NA elements in <code class="reqn">x^{(i)}</code>. 
</p>
<p>We compute output vector <code class="reqn">m</code> the same size as <code class="reqn">x</code>. 
For the 'centered' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = x_i - \mu_i</code>.
For the 'scaled' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = x_i / \sigma_i</code>.
For the 'z-scored' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = (x_i - \mu_i) / \sigma_i</code>.
For the 't-scored' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = \sqrt{n_i} \mu_i / \sigma_i</code>.
</p>
<p>We also allow a 'lookahead' for some of these operations.
If positive, the moments are computed using data from larger indices;
if negative, from smaller indices. Letting <code class="reqn">j = i + lookahead</code>:
For the 'centered' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = x_i - \mu_j</code>.
For the 'scaled' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = x_i / \sigma_j</code>.
For the 'z-scored' version of <code class="reqn">x</code>, we have <code class="reqn">m_i = (x_i - \mu_j) / \sigma_j</code>.
</p>


<h3>Value</h3>

<p>a vector the same size as the input consisting of the adjusted version of the input.
When there are not sufficient (non-nan) elements for the computation, <code>NaN</code> are returned.
</p>


<h3>Note</h3>

<p>The moment computations provided by fromo are 
numerically robust, but will often <em>not</em> provide the
same results as the 'standard' implementations,
due to differences in roundoff. We make every attempt to balance
speed and robustness. User assumes all risk from using
the fromo package.
</p>
<p>Note that when weights are given, they are treated as replication weights.
This can have subtle effects on computations which require minimum
degrees of freedom, since the sum of weights will be compared to
that minimum, not the number of data points. Weight values
(much) less than 1 can cause computations to return <code>NA</code>
somewhat unexpectedly due to this condition, while values greater
than one might cause the computation to spuriously return a value
with little precision.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Terriberry, T. "Computing Higher-Order Moments Online."
<a href="http://people.xiph.org/~tterribe/notes/homs.html">http://people.xiph.org/~tterribe/notes/homs.html</a>
</p>
<p>J. Bennett, et. al., "Numerically Stable, Single-Pass, 
Parallel Statistics Algorithms," Proceedings of IEEE
International Conference on Cluster Computing, 2009.
<a href="https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265">https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265</a>
</p>
<p>Cook, J. D. "Accurately computing running variance."
<a href="http://www.johndcook.com/standard_deviation.html">http://www.johndcook.com/standard_deviation.html</a>
</p>
<p>Cook, J. D. "Comparing three methods of computing 
standard deviation."
<a href="http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation">http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation</a>
</p>


<h3>See Also</h3>

<p><code>t_running_centered</code>, <code>scale</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if (require(moments)) {
    set.seed(123)
    x &lt;- rnorm(5e1)
    window &lt;- 10L
    rm1 &lt;- t(sapply(seq_len(length(x)),function(iii) { 
                  xrang &lt;- x[max(1,iii-window+1):iii]
                  c(sd(xrang),mean(xrang),length(xrang)) },
                  simplify=TRUE))
    rcent &lt;- running_centered(x,window=window)
    rscal &lt;- running_scaled(x,window=window)
    rzsco &lt;- running_zscored(x,window=window)
    rshrp &lt;- running_sharpe(x,window=window)
    rtsco &lt;- running_tstat(x,window=window)
    rsrse &lt;- running_sharpe(x,window=window,compute_se=TRUE)
    stopifnot(max(abs(rcent - (x - rm1[,2])),na.rm=TRUE) &lt; 1e-12)
    stopifnot(max(abs(rscal - (x / rm1[,1])),na.rm=TRUE) &lt; 1e-12)
    stopifnot(max(abs(rzsco - ((x - rm1[,2]) / rm1[,1])),na.rm=TRUE) &lt; 1e-12)
    stopifnot(max(abs(rshrp - (rm1[,2] / rm1[,1])),na.rm=TRUE) &lt; 1e-12)
    stopifnot(max(abs(rtsco - ((sqrt(rm1[,3]) * rm1[,2]) / rm1[,1])),na.rm=TRUE) &lt; 1e-12)
    stopifnot(max(abs(rsrse[,1] - rshrp),na.rm=TRUE) &lt; 1e-12)

    rm2 &lt;- t(sapply(seq_len(length(x)),function(iii) { 
                  xrang &lt;- x[max(1,iii-window+1):iii]
                  c(kurtosis(xrang)-3.0,skewness(xrang)) },
                  simplify=TRUE))
    mertens_se &lt;- sqrt((1 + ((2 + rm2[,1])/4) * rshrp^2 - rm2[,2]*rshrp) / rm1[,3])
    stopifnot(max(abs(rsrse[,2] - mertens_se),na.rm=TRUE) &lt; 1e-12)
}

</code></pre>


</div>