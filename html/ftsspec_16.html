<div class="container">

<table style="width: 100%;"><tr>
<td>Spec</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Spectral Density of Functional Time Series</h2>

<h3>Description</h3>

<p>This function estimates the spectral density operator of a Functional Time Series (FTS)
</p>


<h3>Usage</h3>

<pre><code class="language-R">Spec(X, W = Epanechnikov_kernel, B.T = (dim(X)[1])^(-1/5),
  only.diag = FALSE, trace = FALSE, demean = TRUE, subgrid = FALSE,
  subgrid.density = 10, verbose = 0,
  subgrid.density.relative.to.bandwidth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A <code class="reqn">T \times nbasis</code> matrix of containing the coordinates of the FTS
expressed in a basis. Each row corresponds to a time point, and each column
corresponds to the coefficient of the corresponding basis function of the  FTS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>The weight function used to smooth the periodogram operator. Set by
default to be the Epanechnikov kernel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.T</code></td>
<td>
<p>The bandwidth of frequencies over which the periodogram operator
is smoothed. If <code>B.T=0</code>,  the periodogram operator is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only.diag</code></td>
<td>
<p>A logical variable to choose if the function only computes
the marginal spectral density of each basis coordinate
(<code>only.diag=TRUE</code>). <code>only.diag=FALSE</code> by default, the full spectral
density operator is computed .</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>A logical variable to choose if only the trace of the spectral
density operator is computed. <code>trace=FALSE</code> by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demean</code></td>
<td>
<p>A logical variable to choose if the FTS is centered before
computing its spectral density operator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgrid</code></td>
<td>
<p>A logical variable to choose if the spectral density operator
is only returned for a subgrid of the Fourier frequencies, which can be
useful in large datasets to reduce memory usage. <code>subgrid=FALSE</code> by
default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgrid.density</code></td>
<td>
<p>Only used if <code>subgrid=TRUE</code>. Specifies the
approximate number of frequencies within the bandwidth over which the
periodogram operator is smoothed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A  variable to show the progress of the computations. By
default, <code>verbose=0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subgrid.density.relative.to.bandwidth</code></td>
<td>
<p>logical parameter to specify if
<code>subgrid.density</code> is specified relative to the bandwidth parameter <code>B.T</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>spec</dt>
<dd>
<p>The estimated spectral density operator. The first dimension corresponds to the different frequencies over which the spectral density operators are estimated.</p>
</dd>
<dt>omega</dt>
<dd>
<p>The frequencies over which the spectral density is estimated.</p>
</dd>
<dt>m</dt>
<dd>
<p>The number of Fourier frequencies over which the periodogram operator was smoothed.</p>
</dd>
<dt>bw</dt>
<dd>
<p>The equivalent Bandwidth used in the weight function W(), as defined in Bloomfield (1976, p.201).</p>
</dd>
<dt>weight</dt>
<dd>
<p>The weight function used to smooth the periodogram operator.</p>
</dd>
<dt>kappa.square</dt>
<dd>
<p>The L2 norm of the weight function W.</p>
</dd>
</dl>
<h3>References</h3>

<p>spec.pgram function of R.
</p>
<p><cite> Bloomfield, P. (1976) "Fourier Analysis of Time Series:
An Introduction", Wiley.</cite>
</p>
<p><cite>Panaretos, V. M. and Tavakoli, S., "Fourier Analysis of Functional Time Series", Ann. Statist. Volume 41, Number 2 (2013), 568-603.</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ma.scale1=c(-1.4,2.3,-2)
a1=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale1)
X=Simulate_new_MA(a1, T.len=512, noise.type='wiener')
ans=Spec(X, trace=FALSE, only.diag=FALSE)
plot(ans)
plot(Spec(X, trace=FALSE, only.diag=FALSE, subgrid=TRUE, subgrid.density=10,
subgrid.density.relative.to.bandwidth=FALSE))
rm(ans)
</code></pre>


</div>