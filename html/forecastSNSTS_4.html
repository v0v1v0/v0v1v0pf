<div class="container">

<table style="width: 100%;"><tr>
<td>f</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute <code class="reqn">f(\delta)</code> for a tvAR(p) process</h2>

<h3>Description</h3>

<p>This functions computes the quantity <code class="reqn">f(\delta)</code> defined in (24) of
Kley et al. (2019) when the underlying process follows an tvAR(p) process.
Recall that, to apply Theorem 3.1 in Kley et al. (2019), the function
<code class="reqn">f(\delta)</code> is required to be positive, which can be verified with the
numbers returned from this function.
The function returns a vector with elements <code class="reqn">f(\delta)</code> 
for each <code class="reqn">\delta</code> in <code>which.deltas</code>, with <code class="reqn">f(\delta)</code>
defined as  
</p>
<p style="text-align: center;"><code class="reqn">f(\delta) := \min_{p_1,p_2 = 0, \ldots, p_{\max}} \min_{N \in \mathcal{N}} \Big| {\rm MSPE}_{s_1/T,m/T}^{(p_1,h)}(\frac{s_1}{T}) - (1+\delta) \cdot {\rm MSPE}_{N/T,m/T}^{(p_2,h)}(\frac{s_1}{T}) \Big|, \quad \delta \geq 0</code>
</p>

<p>where <code class="reqn">T, m, p_{\max}, h</code> are positive integers,
<code class="reqn">\mathcal{N} \subset \{p_{\max}+1, \ldots, T-m-h\}</code>, and <code class="reqn">s_1 := T-m-h+1</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">f(which.deltas, p_max, h, T, Ns, m, a, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>which.deltas</code></td>
<td>
<p>vector containing the <code class="reqn">\delta</code>'s for which to
to compute <code class="reqn">f(\delta)</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_max</code></td>
<td>
<p>parameter <code class="reqn">p_{\max}</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>parameter <code class="reqn">h</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p>parameter <code class="reqn">T</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ns</code></td>
<td>
<p>a vector containing the elements of the set
<code class="reqn">\mathcal{N}</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>parameter <code class="reqn">m</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>a list of real-valued functions, specifying the
coefficients of the tvAR(p) process,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>a positive-valued function, specifying the variance
of the innovations of the tvAR(p) process,</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code class="reqn">{\rm MSPE}_{\Delta_1, \Delta_2}^{(p,h)}(u)</code> is defined, for real-valued <code class="reqn">u</code> and
<code class="reqn">\Delta_1, \Delta_2 \geq 0</code>, in terms of the second order properties of the process:
</p>
<p style="text-align: center;"><code class="reqn">{\rm MSPE}_{\Delta_1, \Delta_2}^{(p,h)}(u) := \int_0^1 g^{(p,h)}_{\Delta_1}\Big( u + \Delta_2 (1-x) \Big) {\rm d}x,</code>
</p>

<p>with <code class="reqn">g^{(0,h)}_{\Delta}(u) := \gamma_0(u)</code> and, for <code class="reqn">p = 1, 2, \ldots</code>,
</p>
<p style="text-align: center;"><code class="reqn">g^{(p,h)}_{\Delta}(u) := \gamma_0(u) - 2 \big( v_{\Delta}^{(p,h)}(u) \big)' \gamma_0^{(p,h)}(u) + \big( v_{\Delta}^{(p,h)}(u) \big)' \Gamma_0^{(p)}(u) v_{\Delta}^{(p,h)}(u)</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma_0^{(p,h)}(u) := \big( \gamma_h(u), \ldots, \gamma_{h+p-1}(u) \big)',</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">v^{(p,h)}_{\Delta}(u) := e'_1 \big( e_1 \big( a_{\Delta}^{(p)}(t) \big)' + H \big)^h,</code>
</p>

<p>with <code class="reqn">e_1</code> and <code class="reqn">H</code> defined in the documentation of <code>predCoef</code> and,
for every real-valued <code class="reqn">u</code> and <code class="reqn">\Delta \geq 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">a^{(p)}_{\Delta}(u) := \Gamma^{(p)}_{\Delta}(u)^{-1} \gamma^{(p)}_{\Delta}(u),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\gamma^{(p)}_{\Delta}(u) := \int_0^1 \gamma^{(p)}(u+\Delta (x-1)) {\rm d}x, \quad \gamma^{(p)}(u) := [\gamma_1(u)\;\ldots\;\gamma_p(u)]',</code>
</p>

<p style="text-align: center;"><code class="reqn">\Gamma^{(p)}_{\Delta}(u) := \int_0^1 \Gamma^{(p)}(u+\Delta (x-1)) {\rm d}x, \quad \Gamma^{(p)}(u) := (\gamma_{i-j}(u);\,i,j=1,\ldots,p).</code>
</p>

<p>The local autocovariances <code class="reqn">\gamma_k(u)</code> are defined as the lag-<code class="reqn">k</code>
autocovariances of an AR(p) process which has coefficients
<code class="reqn">a_1(u), \ldots, a_p(u)</code> and innovations with variance <code class="reqn">\sigma(u)^2</code>,
because the underlying model is assumed to be tvAR(p)  
</p>
<p style="text-align: center;"><code class="reqn">Y_{t,T} = \sum_{j=1}^p a_j(t/T) Y_{t-j,T} + \sigma(t/T) \varepsilon_{t},</code>
</p>

<p>where <code class="reqn">a_1, \ldots, a_p</code> are real valued functions (defined on <code class="reqn">[0,1]</code>) and <code class="reqn">\sigma</code> is a
positive function (defined on <code class="reqn">[0,1]</code>).
</p>


<h3>Value</h3>

<p>Returns     a vector with the values <code class="reqn">f(\delta)</code>, as defined in
(24) of Kley et al. (2019), where it is now denoted by <code class="reqn">q(\delta)</code>, for each <code class="reqn">\delta</code> in
<code>which.delta</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
## because computation is quite time-consuming.
n &lt;- 100
a &lt;- list( function(u) {return(0.8+0.19*sin(4*pi*u))} )
sigma &lt;- function (u) {return(1)}

Ns &lt;- seq( floor((n/2)^(4/5)), floor(n^(4/5)),
           ceiling((floor(n^(4/5)) - floor((n/2)^(4/5)))/25) )
which.deltas &lt;- c(0, 0.01, 0.05, 0.1, 0.15, 0.2, 0.4, 0.6)
P_max &lt;- 7
H &lt;- 1
m &lt;- floor(n^(.85)/4)

# now replicate some results from Table 4 in Kley et al. (2019)
f( which.deltas, P_max, h = 1, n - m, Ns, m, a, sigma )
f( which.deltas, P_max, h = 5, n - m, Ns, m, a, sigma )

## End(Not run)
</code></pre>


</div>