<div class="container">

<table style="width: 100%;"><tr>
<td>create.bspline.basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create a B-spline Basis
</h2>

<h3>Description</h3>

<p>Functional data objects are constructed by specifying a set of basis
functions and a set of coefficients defining a linear combination of
these basis functions.  The B-spline basis is used for non-periodic
functions.  B-spline basis functions are polynomial segments jointed
end-to-end at at argument values called knots, breaks or join points.
The segments have specifiable smoothness across these breaks.  B-spline
basis functions have the advantages of very fast computation and great
flexibility.  A polygonal basis generated by
<code>create.polygonal.basis</code> is essentially a B-spline basis of order
2, degree 1.  Monomial and polynomial bases can be obtained as linear
transformations of certain B-spline bases.
</p>


<h3>Usage</h3>

<pre><code class="language-R">create.bspline.basis(rangeval=NULL, nbasis=NULL, norder=4,
      breaks=NULL, dropind=NULL, quadvals=NULL, values=NULL,
      basisvalues=NULL, names="bspl")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rangeval</code></td>
<td>

<p>a numeric vector of length 2 defining the interval over which the
functional data object can be evaluated;  default value is
<code>if(is.null(breaks)) 0:1 else range(breaks)</code>.
</p>
<p>If <code>length(rangeval) == 1</code> and <code>rangeval &lt;= 0</code>, this is an
error.  Otherwise, if <code>length(rangeval) == 1</code>, <code>rangeval</code>
is replaced by <code>c(0,rangeval)</code>.
</p>
<p>If length(rangeval)&gt;2 and neither <code>breaks</code> nor <code>nbasis</code>
are provided, this extra long <code>rangeval</code> argument is assigned
to <code>breaks</code>, and then <code>rangeval = range(breaks)</code>.
</p>
<p>NOTE:  Nonnumerics are also accepted provided
<code>sum(is.na(as.numeric(rangeval))) == 0</code>.  However, as of July
2, 2012, nonnumerics may not work for <code>argvals</code> in other
<code>fda</code> functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>

<p>an integer variable specifying the number of basis functions.  This
'nbasis' argument is ignored if <code>breaks</code> is supplied, in which
case
</p>
<p>nbasis = nbreaks + norder - 2,
</p>
<p>where nbreaks = length(breaks).  If <code>breaks</code> is not supplied
and <code>nbasis</code> is, then
</p>
<p>nbreaks = nbasis - norder + 2,
</p>
<p>and breaks = seq(rangevals[1], rangevals[2], nbreaks).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norder</code></td>
<td>

<p>an integer specifying the order of b-splines, which is one higher
than their degree. The default of 4 gives cubic splines.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>

<p>a vector specifying the break points defining the b-spline.
Also called knots, these are a strictly increasing sequence
of junction points between piecewise polynomial segments.
They must satisfy <code>breaks[1] = rangeval[1]</code> and
<code>breaks[nbreaks] = rangeval[2]</code>, where <code>nbreaks</code> is the
length of <code>breaks</code>.  There must be at least 2 values in
<code>breaks</code>.
</p>
<p>As for rangeval, must satisfy <code>sum(is.na(as.numeric(breaks)))
      == 0</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropind</code></td>
<td>

<p>a vector of integers specifying the basis functions to
be dropped, if any.  For example, if it is required that
a function be zero at the left boundary, this is achieved
by dropping the first basis function, the only one that
is nonzero at that point.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to 1, 4, 2, 4, ..., 2, 4,
1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>

<p>a list containing the basis functions and their derivatives
evaluated at the quadrature points contained in the first
column of <code> quadvals </code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisvalues</code></td>
<td>

<p>a vector of lists, allocated by code such as  <code>vector("list",1)</code>.
This argument is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each list within the vector corresponds to a
specific set of argument values, and must have at least two components,
which may be tagged as you wish.  The first component in an element of the
list vector contains the argument values.  The second component in an
element of the list vector contains a matrix of values of the basis
functions evaluated at the arguments in the first component.  The third and
subsequent components, if present, contain matrices of values their
derivatives up to a maximum derivative order. Whenever function
<code>getbasismatrix()</code> is called, it checks the first list in each row to
see, first, if the number of argument values corresponds to the size of the
first dimension, and if this test succeeds, checks that all of the argument
values match.  This takes time, of course, but is much  faster than
re-evaluation of the basis system.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a single character string to which <code>norder, "."</code>
and <code>1:nbasis</code> are appended as <code>paste(names, norder, ".",
    1:nbasis, sep="")</code>.  For example, if <code>norder = 4</code>, this
defaults to <code>'bspl4.1', 'bspl4.2'</code>, ... .
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Spline functions are constructed by joining polynomials end-to-end at
argument values called <em>break points</em> or <em>knots</em>. First, the
interval is subdivided into a set of adjoining intervals
separated the knots.  Then a polynomial of order $m$ (degree $m-1$) is
defined for each interval.  To make the resulting piecewise polynomial
smooth, two adjoining polynomials are constrained to have their values
and all their derivatives up to order $m-2$ match at the point where
they join.
</p>
<p>Consider as an illustration the very common case where the order is 4
for all polynomials, so that degree of each polynomials is 3.  That
is, the polynomials are <em>cubic</em>.  Then at each break point or
knot, the values of adjacent polynomials must match, and so also for
their first and second derivatives.  Only their third derivatives will
differ at the point of junction.
</p>
<p>The number of degrees of freedom of a cubic spline function of this
nature is calculated as follows.  First, for the first interval, there
are four degrees of freedom.  Then, for each additional interval, the
polynomial over that interval now has only one degree of freedom
because of the requirement for matching values and derivatives.  This
means that the number of degrees of freedom is the number of interior
knots (that is, not counting the lower and upper limits) plus the
order of the polynomials:
</p>
<p><code>nbasis = norder + length(breaks) - 2</code>
</p>
<p>The consistency of the values of <code>nbasis</code>, <code>norder</code> and
<code>breaks</code> is checked, and an error message results if this
equation is not satisfied.
</p>
<p><em>B-splines</em> are a set of special spline functions that can be
used to construct any such piecewise polynomial by computing the
appropriate linear combination.  They derive their computational
convenience from the fact that any B-spline basis function is nonzero
over at most m adjacent intervals.  The number of basis functions is
given by the rule above for the number of degrees of freedom.
</p>
<p>The number of intervals controls the flexibility of the spline;  the
more knots, the more flexible the resulting spline will be. But the
position of the knots also plays a role.  Where do we position the
knots?  There is room for judgment here, but two considerations must
be kept in mind:  (1) you usually want at least one argument value
between two adjacent knots, and (2) there should be more knots where
the curve needs to have sharp curvatures such as a sharp peak or
valley or an abrupt change of level, but only a few knots are required
where the curve is changing very slowly.
</p>
<p>This function automatically includes <code>norder</code> replicates of the
end points rangeval.  By contrast, the analogous functions
splineDesign and spline.des in the
<code>splines</code> package do NOT automatically replicate the end points.
To compare answers, the end knots must be replicated manually when
using splineDesign or spline.des.
</p>


<h3>Value</h3>

<p>a basis object of the type <code>bspline</code>
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>basisfd</code>,
<code>create.constant.basis</code>,
<code>create.exponential.basis</code>,
<code>create.fourier.basis</code>,
<code>create.monomial.basis</code>,
<code>create.polygonal.basis</code>,
<code>create.power.basis</code>
<code>splineDesign</code>
<code>spline.des</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## The simplest basis currently available with this function:
##
bspl1.1 &lt;- create.bspline.basis(norder=1)
oldpar &lt;- par(no.readonly=TRUE)
plot(bspl1.1)
# 1 basis function, order 1 = degree 0 = step function:
# should be the same as above:
b1.1 &lt;- create.bspline.basis(0:1, nbasis=1, norder=1, breaks=0:1)

all.equal(bspl1.1, b1.1)

bspl2.2 &lt;- create.bspline.basis(norder=2)
plot(bspl2.2)
bspl3.3 &lt;- create.bspline.basis(norder=3)
plot(bspl3.3)
bspl4.4 &lt;- create.bspline.basis()
plot(bspl4.4)
bspl1.2 &lt;- create.bspline.basis(norder=1, breaks=c(0,.5, 1))
plot(bspl1.2)
# 2 bases, order 1 = degree 0 = step functions:
# (1) constant 1 between 0 and 0.5 and 0 otherwise
# (2) constant 1 between 0.5 and 1 and 0 otherwise.
bspl2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))
plot(bspl2.3)
# 3 bases:  order 2 = degree 1 = linear
# (1) line from (0,1) down to (0.5, 0), 0 after
# (2) line from (0,0) up to (0.5, 1), then down to (1,0)
# (3) 0 to (0.5, 0) then up to (1,1).
bspl3.4 &lt;- create.bspline.basis(norder=3, breaks=c(0,.5, 1))
plot(bspl3.4)
# 4 bases:  order 3 = degree 2 = parabolas.
# (1) (x-.5)^2 from 0 to .5, 0 after
# (2) 2*(x-1)^2 from .5 to 1, and a parabola
#     from (0,0 to (.5, .5) to match
# (3 &amp; 4) = complements to (2 &amp; 1).
bSpl4. &lt;- create.bspline.basis(c(-1,1))
plot(bSpl4.)
# Same as bSpl4.23 but over (-1,1) rather than (0,1).
# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis &lt;- create.bspline.basis(c(0,1), 23)
plot(lipbasis)
bSpl.growth &lt;- create.bspline.basis(growth$age)
# cubic spline (order 4)
bSpl.growth6 &lt;- create.bspline.basis(growth$age,norder=6)
# quintic spline (order 6)
##
## Nonnumeric rangeval
##
# Date
July4.1776 &lt;- as.Date('1776-07-04')
Apr30.1789 &lt;- as.Date('1789-04-30')
AmRev &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)
# POSIXct
July4.1776ct &lt;- as.POSIXct1970('1776-07-04')
Apr30.1789ct &lt;- as.POSIXct1970('1789-04-30')
AmRev.ct &lt;- c(July4.1776ct, Apr30.1789ct)
BspRev.ct &lt;- create.bspline.basis(AmRev.ct)
par(oldpar)
</code></pre>


</div>