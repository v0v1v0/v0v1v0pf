<div class="container">

<table style="width: 100%;"><tr>
<td>fastcpd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find change points efficiently</h2>

<h3>Description</h3>

<p><code>fastcpd()</code> takes in formulas, data, families and extra
parameters and returns a fastcpd object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fastcpd(
  formula = y ~ . - 1,
  data,
  beta = "MBIC",
  cost_adjustment = "MBIC",
  family = NULL,
  cost = NULL,
  cost_gradient = NULL,
  cost_hessian = NULL,
  line_search = c(1),
  lower = rep(-Inf, p),
  upper = rep(Inf, p),
  pruning_coef = 0,
  segment_count = 10,
  trim = 0.02,
  momentum_coef = 0,
  multiple_epochs = function(x) 0,
  epsilon = 1e-10,
  order = c(0, 0, 0),
  p = ncol(data) - 1,
  cp_only = FALSE,
  vanilla_percentage = 0,
  warm_start = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula object specifying the model to be fitted. The
(optional) response variable should be on the LHS of the formula, while the
covariates should be on the RHS. The naming of variables used in the formula
should be consistent with the column names in the data frame provided in
<code>data</code>. The intercept term should be removed from the formula.
The response variable is not needed for mean/variance change models and time
series models. By default, an intercept column will be added to the data,
similar to the <code>lm()</code> function.
Thus, it is suggested that users should remove the intercept term by
appending <code>- 1</code> to the formula. Note that the fastcpd.family functions
do not require a formula input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame of dimension <code class="reqn">T \times d</code> containing the
data to be segmented (where each row denotes a data point
<code class="reqn">z_t \in \mathbb{R}^d</code> for <code class="reqn">t = 1, \ldots, T</code>) is
required in the main function, while a matrix or a vector input is also
accepted in the fastcpd.family functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Penalty criterion for the number of change points. This parameter
takes a string value of <code>"BIC"</code>, <code>"MBIC"</code>, <code>"MDL"</code> or a
numeric value.
If a numeric value is provided, the value will be used as the penalty.
By default, the mBIC criterion is used, where
<code class="reqn">\beta = (p + 2) \log(T) / 2</code>.
This parameter usage should be paired with <code>cost_adjustment</code> described
below. Discussions about the penalty criterion can be found in the
references.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost_adjustment</code></td>
<td>
<p>Cost adjustment criterion.
It can be <code>"BIC"</code>, <code>"MBIC"</code>, <code>"MDL"</code> or <code>NULL</code>.
By default, the cost adjustment criterion is set to be <code>"MBIC"</code>.
The <code>"MBIC"</code> and <code>"MDL"</code> criteria modify the cost function by
adding a negative adjustment term to the cost function.
<code>"BIC"</code> or <code>NULL</code> does not modify the cost function.
Details can in found in the references.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Family class of the change point model. It can be
<code>"mean"</code> for mean change,
<code>"variance"</code> for variance change,
<code>"meanvariance"</code> for mean and/or variance change,
<code>"lm"</code> for linear regression,
<code>"binomial"</code> for logistic regression,
<code>"poisson"</code> for Poisson regression,
<code>"lasso"</code> for penalized linear regression,
<code>"ar"</code> for AR(<code class="reqn">p</code>) models,
<code>"arma"</code> for ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) models,
<code>"arima"</code> for ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) models,
<code>"garch"</code> for GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models,
<code>"var"</code> for VAR(<code class="reqn">p</code>) models and
<code>"custom"</code> for user-specified custom models.
Omitting this parameter is the same as specifying the parameter to be
<code>"custom"</code> or <code>NULL</code>, in which case, users must specify the
custom cost function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost</code></td>
<td>
<p>Cost function to be used. <code>cost</code>, <code>cost_gradient</code>, and
<code>cost_hessian</code> should not be specified at the same time with
<code>family</code> as built-in families have cost functions implemented in C++
to provide better performance. If not specified, the default is the negative
log-likelihood for the corresponding family. Custom cost functions can be
provided in the following two formats:
</p>

<ul>
<li> <p><code>cost = function(data) {...}</code>
</p>
</li>
<li> <p><code>cost = function(data, theta) {...}</code>
</p>
</li>
</ul>
<p>Users can specify a loss function using the second format that will be used
to calculate the cost value. In both formats, the input data is a subset of
the original data frame in the form of a matrix
(a matrix with a single column in the case of a univariate data set).
In the first format, the specified cost function directly calculates the cost
value. <code>fastcpd()</code> performs the vanilla PELT algorithm, and
<code>cost_gradient</code> and <code>cost_hessian</code> should not be provided since no
parameter updating is necessary for vanilla PELT.
In the second format, the loss function
<code class="reqn">\sum_{i = s}^t l(z_i, \theta)</code> is
provided, which has to be optimized over the parameter <code class="reqn">\theta</code> to
obtain the cost value. A detailed discussion about the custom cost function
usage can be found in the references.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost_gradient</code></td>
<td>
<p>Gradient of the custom cost function. Example usage:
</p>
<div class="sourceCode r"><pre>cost_gradient = function(data, theta) {
  ...
  return(gradient)
}
</pre></div>
<p>The gradient function takes two inputs, the first being a matrix representing
a segment of the data, similar to the format used in the <code>cost</code>
function, and the second being the parameter that needs to be optimized.
The gradient function returns the value of the gradient of the loss function,
i.e.,
<code class="reqn">\sum_{i = s}^t \nabla l(z_i, \theta)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost_hessian</code></td>
<td>
<p>Hessian of the custom loss function. The Hessian function
takes two inputs, the first being a matrix representing a segment of the
data, similar to the format used in the <code>cost</code> function, and the second
being the parameter that needs to be optimized. The gradient function returns
the Hessian of the loss function, i.e.,
<code class="reqn">\sum_{i = s}^t \nabla^2 l(z_i, \theta)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>line_search</code></td>
<td>
<p>If a vector of numeric values is provided, a line search
will be performed to find the optimal step size for each update. Detailed
usage of <code>line_search</code> can be found in the references.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>Lower bound for the parameters. Used to specify the domain of
the parameters after each gradient descent step. If not specified, the lower
bound is set to be <code>-Inf</code> for all parameters. <code>lower</code> is especially
useful when the estimated parameters take only positive values, such as the
noise variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>Upper bound for the parameters. Used to specify the domain of
the parameters after each gradient descent step. If not specified, the upper
bound is set to be <code>Inf</code> for all parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pruning_coef</code></td>
<td>
<p>Pruning coefficient $c_0$ used in the pruning step of the
PELT algorithm with the default value 0. If <code>cost_adjustment</code> is
specified as <code>"MBIC"</code>, an adjustment term <code class="reqn">p\log(2)</code>
will be added to the pruning coefficient. If <code>cost_adjustment</code> is
specified as <code>"MDL"</code>, an adjustment term <code class="reqn">p\log_2(2)</code>
will be added to the pruning coefficient. Detailed discussion about the
pruning coefficient can be found in the references.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>segment_count</code></td>
<td>
<p>An initial guess of the number of segments. If not
specified, the initial guess of the number of segments is 10. The initial
guess affects the initial estimates of the parameters in SeGD.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>Trimming for the boundary change points so that a change point
close to the boundary will not be counted as a change point. This
parameter also specifies the minimum distance between two change points.
If several change points have mutual distances smaller than
<code>trim * nrow(data)</code>, those change points will be merged into one
single change point. The value of this parameter should be between
0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentum_coef</code></td>
<td>
<p>Momentum coefficient to be applied to each update. This
parameter is used when the loss function is bad-shaped so that
maintaining a momentum from previous update is desired. Default value is
0, meaning the algorithm doesn't maintain a momentum by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multiple_epochs</code></td>
<td>
<p>A function can be specified such that an adaptive
number of multiple epochs can be utilized to improve the algorithm's
performance. <code>multiple_epochs</code> is a function of the length of the data
segment. The function returns an integer indicating how many epochs should be
performed apart from the default update. By default, the function returns
zero, meaning no multiple epochs will be used to update the parameters.
Example usage:
</p>
<div class="sourceCode r"><pre>multiple_epochs = function(segment_length) {
  if (segment_length &lt; 100) 1
  else 0
}
</pre></div>
<p>This function will let SeGD perform parameter updates with an additional
epoch for each segment with a length less than 100 and no additional epoch
for segments with lengths greater or equal to 100.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Epsilon to avoid numerical issues. Only used for the Hessian
computation in Logistic Regression and Poisson Regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Order of the AR(<code class="reqn">p</code>), VAR(<code class="reqn">p</code>) or
ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Number of covariates in the model. If not specified, the number of
covariates will be inferred from the data, i.e.,
<code>p = ncol(data) - 1</code>. This parameter is superseded by <code>order</code> in the
case of time series models: "ar", "var", "arima".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cp_only</code></td>
<td>
<p>If <code>TRUE</code>, only the change points are returned.
Otherwise, the cost function values together with the estimated
parameters for each segment are also returned. By default the value is
set to be <code>FALSE</code> so that <code>plot</code> can be used to visualize the
results for a built-in model. <code>cp_only</code> has some performance impact
on the algorithm, since the cost values and estimated parameters for each
segment need to be calculated and stored. If the users are only
interested in the change points, setting <code>cp_only</code> to be <code>TRUE</code>
will help with the computational cost.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vanilla_percentage</code></td>
<td>
<p>The parameter <code class="reqn">v</code> is between zero and one.
For each segment, when its length is no more than <code class="reqn">vT</code>, the cost value
will be computed by performing an exact minimization of the loss function
over the parameter. When its length is greater than <code class="reqn">vT</code>, the cost value
is approximated through SeGD. Therefore, this parameter induces an algorithm
that can be interpreted as an interpolation between dynamic programming with
SeGD (<code class="reqn">v = 0</code>) and the vanilla PELT (<code class="reqn">v = 1</code>).
The readers are referred to the references for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm_start</code></td>
<td>
<p>If <code>TRUE</code>, the algorithm will use the estimated
parameters from the previous segment as the initial value for the
current segment. This parameter is only used for the <code>"glm"</code> families.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other parameters for specific models.
</p>

<ul>
<li> <p><code>include.mean</code> is used to determine if a mean/intercept term
should be included in the ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) or
GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models.
</p>
</li>
<li> <p><code>r.clock</code> is used to create an <code>RcppClock</code> object to record
the time spent in the C++ code. Default is an empty string. If set to
any non-empty string, an object with specified name will be created.
Usage: <code>library(RcppClock); plot(VARIABLE_NAME)</code>.
</p>
</li>
<li> <p><code>r.progress</code> is used to control the progress bar. By default the
progress bar will be shown. To disable it, set <code>r.progress = FALSE</code>.
</p>
</li>
<li> <p><code>p.response</code> is used to specify the number of response variables.
This parameter is especially useful for linear models with multivariate
responses.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A fastcpd object.
</p>


<h3>Gallery</h3>

<p><a href="https://github.com/doccstat/fastcpd/tree/main/tests/testthat/examples">https://github.com/doccstat/fastcpd/tree/main/tests/testthat/examples</a>
</p>


<h3>References</h3>

<p>Xingchi Li, Xianyang Zhang (2024). “fastcpd: Fast Change Point Detection
in R.” <em>arXiv:2404.05933</em>, <a href="https://arxiv.org/abs/2404.05933">https://arxiv.org/abs/2404.05933</a>.
</p>
<p>Xianyang Zhang, Trisha Dawn (2023). “Sequential Gradient Descent and
Quasi-Newton's Method for Change-Point Analysis.” In Ruiz, Francisco,
Dy, Jennifer, van de Meent, Jan-Willem (eds.), <em>Proceedings of The 26th
International Conference on Artificial Intelligence and Statistics</em>,
volume 206 series Proceedings of Machine Learning Research, 1129-1143.
</p>


<h3>See Also</h3>

<p>fastcpd.family for the family-specific function;
<code>plot.fastcpd()</code> for plotting the results,
<code>summary.fastcpd()</code> for summarizing the results.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 200
  p &lt;- 4
  d &lt;- 2
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_1 &lt;- matrix(runif(8, -3, -1), nrow = p)
  theta_2 &lt;- matrix(runif(8, -1, 3), nrow = p)
  y &lt;- rbind(
    x[1:125, ] %*% theta_1 + mvtnorm::rmvnorm(125, rep(0, d), 3 * diag(d)),
    x[126:n, ] %*% theta_2 + mvtnorm::rmvnorm(75, rep(0, d), 3 * diag(d))
  )
  result_mlm &lt;- fastcpd(
    cbind(y.1, y.2) ~ . - 1, cbind.data.frame(y = y, x = x), family = "lm"
  )
  summary(result_mlm)
}
if (
  requireNamespace("mvtnorm", quietly = TRUE) &amp;&amp;
    requireNamespace("stats", quietly = TRUE)
) {
  set.seed(1)
  n &lt;- 400 + 300 + 500
  p &lt;- 5
  x &lt;- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = diag(p))
  theta &lt;- rbind(
    mvtnorm::rmvnorm(1, mean = rep(0, p - 3), sigma = diag(p - 3)),
    mvtnorm::rmvnorm(1, mean = rep(5, p - 3), sigma = diag(p - 3)),
    mvtnorm::rmvnorm(1, mean = rep(9, p - 3), sigma = diag(p - 3))
  )
  theta &lt;- cbind(theta, matrix(0, 3, 3))
  theta &lt;- theta[rep(seq_len(3), c(400, 300, 500)), ]
  y_true &lt;- rowSums(x * theta)
  factor &lt;- c(
    2 * stats::rbinom(400, size = 1, prob = 0.95) - 1,
    2 * stats::rbinom(300, size = 1, prob = 0.95) - 1,
    2 * stats::rbinom(500, size = 1, prob = 0.95) - 1
  )
  y &lt;- factor * y_true + stats::rnorm(n)
  data &lt;- cbind.data.frame(y, x)
  huber_threshold &lt;- 1
  huber_loss &lt;- function(data, theta) {
    residual &lt;- data[, 1] - data[, -1, drop = FALSE] %*% theta
    indicator &lt;- abs(residual) &lt;= huber_threshold
    sum(
      residual^2 / 2 * indicator +
        huber_threshold * (
          abs(residual) - huber_threshold / 2
        ) * (1 - indicator)
    )
  }
  huber_loss_gradient &lt;- function(data, theta) {
    residual &lt;- c(data[nrow(data), 1] - data[nrow(data), -1] %*% theta)
    if (abs(residual) &lt;= huber_threshold) {
      -residual * data[nrow(data), -1]
    } else {
      -huber_threshold * sign(residual) * data[nrow(data), -1]
    }
  }
  huber_loss_hessian &lt;- function(data, theta) {
    residual &lt;- c(data[nrow(data), 1] - data[nrow(data), -1] %*% theta)
    if (abs(residual) &lt;= huber_threshold) {
      outer(data[nrow(data), -1], data[nrow(data), -1])
    } else {
      0.01 * diag(length(theta))
    }
  }
  huber_regression_result &lt;- fastcpd(
    formula = y ~ . - 1,
    data = data,
    beta = (p + 1) * log(n) / 2,
    cost = huber_loss,
    cost_gradient = huber_loss_gradient,
    cost_hessian = huber_loss_hessian
  )
  summary(huber_regression_result)
}

set.seed(1)
p &lt;- 5
x &lt;- matrix(rnorm(375 * p, 0, 1), ncol = p)
theta &lt;- rbind(rnorm(p, 0, 1), rnorm(p, 2, 1))
y &lt;- c(
  rbinom(200, 1, 1 / (1 + exp(-x[1:200, ] %*% theta[1, ]))),
  rbinom(175, 1, 1 / (1 + exp(-x[201:375, ] %*% theta[2, ])))
)
data &lt;- data.frame(y = y, x = x)
result_builtin &lt;- suppressWarnings(fastcpd.binomial(data))
logistic_loss &lt;- function(data, theta) {
  x &lt;- data[, -1]
  y &lt;- data[, 1]
  u &lt;- x %*% theta
  nll &lt;- -y * u + log(1 + exp(u))
  nll[u &gt; 10] &lt;- -y[u &gt; 10] * u[u &gt; 10] + u[u &gt; 10]
  sum(nll)
}
logistic_loss_gradient &lt;- function(data, theta) {
  x &lt;- data[nrow(data), -1]
  y &lt;- data[nrow(data), 1]
  c(-(y - 1 / (1 + exp(-x %*% theta)))) * x
}
logistic_loss_hessian &lt;- function(data, theta) {
  x &lt;- data[nrow(data), -1]
  prob &lt;- 1 / (1 + exp(-x %*% theta))
  (x %o% x) * c((1 - prob) * prob)
}
result_custom &lt;- fastcpd(
  formula = y ~ . - 1,
  data = data,
  epsilon = 1e-5,
  cost = logistic_loss,
  cost_gradient = logistic_loss_gradient,
  cost_hessian = logistic_loss_hessian
)
cat(
  "Change points detected by built-in logistic regression model: ",
  result_builtin@cp_set, "\n",
  "Change points detected by custom logistic regression model: ",
  result_custom@cp_set, "\n",
  sep = ""
)
result_custom_two_epochs &lt;- fastcpd(
  formula = y ~ . - 1,
  data = data,
  multiple_epochs = function(segment_length) 1,
  epsilon = 1e-5,
  cost = logistic_loss,
  cost_gradient = logistic_loss_gradient,
  cost_hessian = logistic_loss_hessian
)
summary(result_custom_two_epochs)


if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 480
  p_true &lt;- 6
  p &lt;- 50
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_0 &lt;- rbind(
    runif(p_true, -5, -2),
    runif(p_true, -3, 3),
    runif(p_true, 2, 5),
    runif(p_true, -5, 5)
  )
  theta_0 &lt;- cbind(theta_0, matrix(0, ncol = p - p_true, nrow = 4))
  y &lt;- c(
    x[1:80, ] %*% theta_0[1, ] + rnorm(80, 0, 1),
    x[81:200, ] %*% theta_0[2, ] + rnorm(120, 0, 1),
    x[201:320, ] %*% theta_0[3, ] + rnorm(120, 0, 1),
    x[321:n, ] %*% theta_0[4, ] + rnorm(160, 0, 1)
  )
  small_lasso_data &lt;- cbind.data.frame(y, x)
  result_no_vp &lt;- fastcpd.lasso(
    small_lasso_data,
    beta = "BIC",
    cost_adjustment = NULL,
    pruning_coef = 0
  )
  summary(result_no_vp)
  result_20_vp &lt;- fastcpd.lasso(
    small_lasso_data,
    beta = "BIC",
    cost_adjustment = NULL,
    vanilla_percentage = 0.2,
    pruning_coef = 0
  )
  summary(result_20_vp)
}

</code></pre>


</div>