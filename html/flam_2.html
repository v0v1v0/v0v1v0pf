<div class="container">

<table style="width: 100%;"><tr>
<td>flam</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fit the Fused Lasso Additive Model for a Sequence of Tuning Parameters
</h2>

<h3>Description</h3>

<p>Fit an additive model where each component is estimated to piecewise constant with a small number of adaptively-chosen knots. The model is fit for a sequence of tuning parameters. In particular, this function implements the "fused lasso additive model", as proposed in Petersen, A., Witten, D., and Simon, N. (2014). Fused Lasso Additive Model. arXiv preprint arXiv:1409.5391.
</p>


<h3>Usage</h3>

<pre><code class="language-R">flam(x, y, lambda.min.ratio = 0.01, n.lambda = 50, lambda.seq = NULL,
alpha.seq = 1, family = "gaussian", method = "BCD", tolerance = 10e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>n x p covariate matrix. May have p &gt; n.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>n-vector containing the outcomes for the n observations in <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.min.ratio</code></td>
<td>

<p>smallest value for <code>lambda.seq</code>, as a fraction of the maximum lambda value, which is the data-derived smallest value for which all estimated functions are zero. The default is 0.01.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.lambda</code></td>
<td>

<p>the number of lambda values to consider - the default is 50.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.seq</code></td>
<td>

<p>a user-supplied sequence of positive lambda values to consider. The typical usage is to calculate <code>lambda.seq</code> using <code>lambda.min.ratio</code> and <code>n.lambda</code>, but providing <code>lambda.seq</code> overrides this. If provided, <code>lambda.seq</code> should be a decreasing sequence of values, since <code>flam</code> relies on warm starts for speed. Thus fitting the model for a whole sequence of lambda values is often faster than fitting for a single lambda value. Note that the model is fit for all combinations of <code>alpha.seq</code> and <code>lambda.seq</code>, so all values of <code>lambda.seq</code> provided should be unique.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha.seq</code></td>
<td>

<p>the value(s) of alpha to consider - default is 1. Values must be in [0,1] with values near 0 prioritizing sparsity of functions and values near 1 prioritizing limiting the number of knots. Empirical evidence suggests using alpha of 1 when p &lt; n and alpha of 0.75 when p &gt; n. Note that the model is fit for all combinations of <code>alpha.seq</code> and <code>lambda.seq</code>, so all values of <code>alpha.seq</code> provided should be unique.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>

<p>specifies the loss function to use. Currently supports squared error loss (default; <code>family="gaussian"</code>) and logistic loss (<code>family="binomial"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>specifies the optimization algorithm to use. Options are block-coordinate descent (default; <code>method="BCD"</code>), generalized gradient descent (<code>method="GGD"</code>), or generalized gradient descent with backtracking (<code>method="GGD.backtrack"</code>). This argument is ignored if <code>family="binomial"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>

<p>specifies the convergence criterion for the objective (default is 10e-6).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object with S3 class "flam".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>all.alpha</code></td>
<td>
<p>vector of alpha values considered. This will be m times longer than the user-specified <code>alpha.seq</code> where m is the length of the user-specified <code>lambda.seq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.lambda</code></td>
<td>
<p>vector of lambda values considered. This will be q times longer than the user-specified <code>lambda.seq</code> where q is the length of the user-specified <code>alpha.seq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.hat.list</code></td>
<td>
<p>list of estimated theta matrices of dimension n x p. Note that the predicted values <code>y.hat.mat[i,] = g(</code><code>beta0.hat.vec[i] + </code><code>rowSums(theta.hat.list[[i]]))</code> where <code>g</code> is the link function (identity if <code>family="gaussian"</code> and expit if <code>family="binomial"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f.hat.list</code></td>
<td>
<p>list of estimated function matrices of dimension n x p. Note that <code>f.hat.list[[i]]</code> is <code>theta.hat.list[[i]]</code> with the elements of each column ordered in terms of increasing <code>x[,i]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0.hat.vec</code></td>
<td>
<p>vector of estimated intercepts with <code>beta0.hat.vec[i]</code> being the intercept for the model with tuning parameters <code>all.alpha[i]</code> and <code>all.lambda[i]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.hat.mat</code></td>
<td>
<p>matrix with <code>y.hat.mat[i,]</code> containing fitted y values for the tuning parameters <code>all.alpha[i]</code> and <code>all.lambda[i]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>non.sparse.list</code></td>
<td>
<p>list with <code>non.sparse.list[[i]]</code> containing the indices for the predictors with non-sparse fits for the tuning parameters <code>all.alpha[i]</code> and <code>all.lambda[i]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.non.sparse</code></td>
<td>
<p>vector with <code>num.non.sparse[i]</code> indicating the number of non-sparse predictor fits for the tuning parameters <code>all.alpha[i]</code> and <code>all.lambda[i]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>as specified by user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>as specified by user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>as specified by user (or default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>as specified by user (or default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tolerance</code></td>
<td>
<p>as specified by user (or default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>the matched call.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Ashley Petersen
</p>


<h3>References</h3>

<p>Petersen, A., Witten, D., and Simon, N. (2014). Fused Lasso Additive Model. arXiv preprint arXiv:1409.5391.
</p>


<h3>See Also</h3>

<p><code>predict.flam</code>, <code>plot.flam</code>, <code>summary.flam</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#See ?'flam-package' for a full example of how to use this package

#generate data
set.seed(1)
data &lt;- sim.data(n = 50, scenario = 1, zerof = 10, noise = 1)

#fit model for a range of lambda chosen by default and alpha's of 0.75 and 1
flam.out &lt;- flam(x = data$x, y = data$y, alpha.seq = c(0.75, 1))
#or specify desired lambda sequence (often equally spaced on log scale)
#should be a decreasing sequence of several values for computational speed
user.lambda.seq &lt;- exp(seq(log(50), log(1), len=40))
flam.out2 &lt;- flam(x = data$x, y = data$y, lambda.seq = user.lambda.seq)

## Not run: 
#alternatively, generate data for logistic FLAM model
data2 &lt;- sim.data(n = 50, scenario = 1, zerof = 10, family = "binomial")
#fit the FLAM model using logistic loss
flam.logistic.out &lt;- flam(x = data2$x, y = data2$y, family = "binomial")

## End(Not run)

#'flam' returns an object of the class 'flam'
#see ?'flam-package' for an example using S3 methods for 'flam' objects

</code></pre>


</div>