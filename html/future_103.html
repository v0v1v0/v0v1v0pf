<div class="container">

<table style="width: 100%;"><tr>
<td>resolve</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Resolve one or more futures synchronously</h2>

<h3>Description</h3>

<p>This function provides an efficient mechanism for waiting for multiple
futures in a container (e.g. list or environment) to be resolved while in
the meanwhile retrieving values of already resolved futures.
</p>


<h3>Usage</h3>

<pre><code class="language-R">resolve(
  x,
  idxs = NULL,
  recursive = 0,
  result = FALSE,
  stdout = FALSE,
  signal = FALSE,
  force = FALSE,
  sleep = getOption("future.wait.interval", 0.01),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A Future to be resolved, or a list, an environment, or a
list environment of futures to be resolved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idxs</code></td>
<td>
<p>(optional) integer or logical index specifying the subset of
elements to check.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>recursive</code></td>
<td>
<p>A non-negative number specifying how deep of a recursion
should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,
no recursion is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>(internal) If TRUE, the results are <em>retrieved</em>, otherwise not.
Note that this only collects the results from the parallel worker, which
can help lower the overall latency if there are multiple concurrent futures.
This does <em>not</em> return the collected results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stdout</code></td>
<td>
<p>(internal) If TRUE, captured standard output is relayed, otherwise not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signal</code></td>
<td>
<p>(internal) If TRUE, captured conditions are relayed,
otherwise not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force</code></td>
<td>
<p>(internal) If TRUE, captured standard output and captured
conditions already relayed is relayed again, otherwise not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sleep</code></td>
<td>
<p>Number of seconds to wait before checking if futures have been
resolved since last time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function is resolves synchronously, i.e. it blocks until <code>x</code> and
any containing futures are resolved.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> (regardless of subsetting or not).
If <code>signal</code> is TRUE and one of the futures produces an error, then
that error is produced.
</p>


<h3>See Also</h3>

<p>To resolve a future <em>variable</em>, first retrieve its
Future object using <code>futureOf()</code>, e.g.
<code>resolve(futureOf(x))</code>.
</p>


</div>