<div class="container">

<table style="width: 100%;"><tr>
<td>fechner</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Main Function For Fechnerian Scaling</h2>

<h3>Description</h3>

<p><code>fechner</code> provides the Fechnerian scaling computations.  It is
the main function of this package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fechner(X, format = c("probability.different", "percent.same", "general"),
        compute.all = FALSE, check.computation = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a required square matrix or data frame of numeric data.
No <code>NA</code>, <code>NaN</code>, <code>Inf</code>, or <code>-Inf</code> values are
allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>an optional character string giving the data format
that is used.  This must be one of <code>"probability.different"</code>,
<code>"percent.same"</code>, or <code>"general"</code>, with default
<code>"probability.different"</code>, and may be abbreviated to a unique
prefix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.all</code></td>
<td>
<p>an optional logical.  The default value
<code>FALSE</code> corresponds to short computation, which yields the
main Fechnerian scaling computations.  The value <code>TRUE</code>
corresponds to long computation, which additionally yields
intermediate results and also allows for a check of computations
if <code>check.computation</code> is set <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.computation</code></td>
<td>
<p>an optional logical.  If <code>TRUE</code>, the
check for whether the overall Fechnerian distance of the first
kind (in the first observation area) is equal to the overall
Fechnerian distance of the second kind (in the second observation
area) is performed.  The check requires <code>compute.all</code> to be
set <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>format</code> argument specifies the data format that is used.
<code>"probability.different"</code> and <code>"percent.same"</code> are for
datasets in the probability-different and percent-same formats, and
in the latter case, the data are automatically transformed prior to
the analysis using the transformation <code class="reqn">(100 - X) / 100</code>.
<code>"general"</code> is to be used for datasets that are properly in the
general data format.  Note that for <code>"percent.same"</code>, the data
must satisfy regular maximality, for <code>"probability.different"</code>
and <code>"general"</code>, regular minimality (otherwise function
<code>fechner</code> produces respective messages).  In particular, data
in the general format may possibly need to be transformed manually
prior to calling the function <code>fechner</code>.
</p>
<p>If <code>compute.all = TRUE</code> and <code>check.computation = TRUE</code>,
the performed check computes the difference ‘overall
Fechnerian distance of the first kind minus overall Fechnerian
distance of the second kind’.  By theory, this difference is zero.
The function <code>fechner</code> calculates that difference and checks
for equality of these Fechnerian distances up to machine precision
(see ‘Value’). <code>fechner</code> calls
<code>check.regular</code>, which in turn calls
<code>check.data</code>.  In particular, the specified data format
and regular minimality/maximality are checked, and the rows and
columns of the canonical representation matrix (see
<code>check.regular</code>) are canonically relabeled based on the
labeling provided by <code>check.data</code>.
</p>
<p>The function <code>fechner</code> returns an object of the class
<code>fechner</code> (see ‘Value’), for which <code>plot</code>,
<code>print</code>, and <code>summary</code> methods are provided;
<code>plot.fechner</code>, <code>print.fechner</code>, and
<code>summary.fechner</code>, respectively.  Moreover, objects of
the class <code>fechner</code> are set the specific named attribute
<code>computation</code>, which is assumed to have the value <code>short</code>
or <code>long</code> indicating whether short computation
(<code>compute.all = FALSE</code>) or long computation
(<code>compute.all = TRUE</code>) was performed, respectively.
</p>


<h3>Value</h3>

<p>If the arguments <code>X</code>, <code>format</code>, <code>compute.all</code>, and
<code>check.computation</code> are of required types, <code>fechner</code>
returns a named list, of the class <code>fechner</code> and with the
attribute <code>computation</code>, which consists of <code class="reqn">6</code> or <code class="reqn">18</code>
components, depending on whether short computation
(<code>computation</code> is then set <code>short</code>) or long computation
(<code>computation</code> is then set <code>long</code>) was performed,
respectively.  <br></p>
<p>The short computation list contains the following first <code class="reqn">6</code>
components, the long computation list the subsequent ones:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>points.of.subjective.equality</code></td>
<td>
<p>a data frame giving the
permutation of the columns of <code>X</code> used to produce the
canonical representation of <code>X</code>.  The first and second
variables of this data frame, <code>observation.area.1</code> and
<code>observation.area.2</code>, respectively, represent the pairs
of points of subjective equality (PSEs).  The third variable,
<code>common.label</code>, lists the identical labels assigned to the
pairs of PSEs.  (first component of short computation list)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>canonical.representation</code></td>
<td>
<p>a matrix giving the representation
of <code>X</code> in which regular minimality/maximality is satisfied in
the canonical form.  That is, the single minimal/maximal entries
of the rows and columns lie on the main diagonal (of the canonical
representation).  In addition, the rows and columns are
canonically relabeled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overall.Fechnerian.distances</code></td>
<td>
<p>a matrix of the overall
Fechnerian distances (of the first kind); by theory, invariant
from observation area.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geodesic.loops</code></td>
<td>
<p>a data frame of the geodesic loops of the
first kind; must be read from left to right for the first kind,
and from right to left for the second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.lengths.of.geodesic.loops</code></td>
<td>
<p>a matrix of the
graph-theoretic (edge/link based) lengths of the geodesic loops
(of the first kind).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.index</code></td>
<td>
<p>a matrix of the generalized ‘Shepardian’
dissimilarity (or S-index) values.  An S-index value is defined as
the psychometric length of the loop between a row stimulus and a
column stimulus containing only these two stimuli.  (last
component of short computation list)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>points.of.subjective.equality</code></td>
<td>
<p>the same as in case of short
computation; see above.  (first component of long computation
list)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>canonical.representation</code></td>
<td>
<p>the same as in case of short
computation; see above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psychometric.increments.1</code></td>
<td>
<p>a matrix of the psychometric
increments of the first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psychometric.increments.2</code></td>
<td>
<p>a matrix of the psychometric
increments of the second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oriented.Fechnerian.distances.1</code></td>
<td>
<p>a matrix of the oriented
Fechnerian distances of the first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overall.Fechnerian.distances.1</code></td>
<td>
<p>a matrix of the overall
Fechnerian distances of the first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oriented.Fechnerian.distances.2</code></td>
<td>
<p>a matrix of the oriented
Fechnerian distances of the second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overall.Fechnerian.distances.2</code></td>
<td>
<p>a matrix of the overall
Fechnerian distances of the second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>if <code>check.computation = TRUE</code>, a list of two
components: <code>difference</code> and <code>are.nearly.equal</code>.  The
component <code>difference</code> is a matrix of the differences of the
overall Fechnerian distances of the first and second kind; ought
to be a zero matrix.  The component <code>are.nearly.equal</code> is a
logical indicating whether this matrix of differences is equal to
the zero matrix up to machine precision.  If
<code>check.computation = FALSE</code>, a character string saying
<em>“computation check was not requested”</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geodesic.chains.1</code></td>
<td>
<p>a data frame of the geodesic chains of the
first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geodesic.loops.1</code></td>
<td>
<p>a data frame of the geodesic loops of the
first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.lengths.of.geodesic.chains.1</code></td>
<td>
<p>a matrix of the
graph-theoretic (edge/link based) lengths of the geodesic chains
of the first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.lengths.of.geodesic.loops.1</code></td>
<td>
<p>a matrix of the
graph-theoretic (edge/link based) lengths of the geodesic loops of
the first kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geodesic.chains.2</code></td>
<td>
<p>a data frame of the geodesic chains of the
second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>geodesic.loops.2</code></td>
<td>
<p>a data frame of the geodesic loops of the
second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.lengths.of.geodesic.chains.2</code></td>
<td>
<p>a matrix of the
graph-theoretic (edge/link based) lengths of the geodesic chains
of the second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>graph.lengths.of.geodesic.loops.2</code></td>
<td>
<p>a matrix of the
graph-theoretic (edge/link based) lengths of the geodesic loops of
the second kind.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S.index</code></td>
<td>
<p>the same as in case of short computation; see above.
(last component of long computation list)</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Thomas Kiefer, Ali Uenlue.  Based on original MATLAB source by Ehtibar N. Dzhafarov.
</p>


<h3>References</h3>

<p>Dzhafarov, E. N. and Colonius, H. (2006) Reconstructing
distances among objects from their discriminability.
<em>Psychometrika</em>, <b>71</b>, 365–386.
</p>
<p>Dzhafarov, E. N. and Colonius, H. (2007) Dissimilarity
cumulation theory and subjective metrics. <em>Journal of
Mathematical Psychology</em>, <b>51</b>, 290–304.
</p>
<p>Uenlue, A. and Kiefer, T. and Dzhafarov, E. N.
(2009) Fechnerian scaling in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>: The package <span class="pkg">fechner</span>.
<em>Journal of Statistical Software</em>, <b>31</b>(6), 1–24.
URL <a href="http://www.jstatsoft.org/v31/i06/">http://www.jstatsoft.org/v31/i06/</a>.
</p>


<h3>See Also</h3>

<p><code>check.data</code> for checking data format;
<code>check.regular</code> for checking regular
minimality/maximality; <code>plot.fechner</code>, the S3 method for
plotting objects of the class <code>fechner</code>;
<code>print.fechner</code>, the S3 method for printing objects of
the class <code>fechner</code>; <code>summary.fechner</code>, the S3
method for summarizing objects of the class <code>fechner</code>, which
creates objects of the class <code>summary.fechner</code>;
<code>print.summary.fechner</code>, the S3 method for printing
objects of the class <code>summary.fechner</code>.  See also
<code>fechner-package</code> for general information about this
package.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## (1) examples based on dataset \link{morse}
##

## dataset \link{morse} satisfies regular maximality in canonical form
morse
check.regular(morse, type = "percent.same")

## a self-contained 10-code subspace consisting of the codes for the
## letter B and the digits 0, 1, 2, 4, \ldots, 9
indices &lt;- which(is.element(names(morse), c("B", c(0, 1, 2, 4:9))))
f.scal.morse &lt;- fechner(morse, format = "percent.same")
f.scal.morse$geodesic.loops[indices, indices]
morse.subspace &lt;- morse[indices, indices]
check.regular(morse.subspace, type = "percent.same")

## since the subspace is self-contained, results must be the same
f.scal.subspace.mo &lt;- fechner(morse.subspace, format = "percent.same")
identical(f.scal.morse$geodesic.loops[indices, indices],
          f.scal.subspace.mo$geodesic.loops)
identical(f.scal.morse$overall.Fechnerian.distances[indices, indices],
          f.scal.subspace.mo$overall.Fechnerian.distances)

## Fechnerian scaling analysis using short computation
f.scal.subspace.mo
str(f.scal.subspace.mo)
attributes(f.scal.subspace.mo)
## for instance, the S-index
f.scal.subspace.mo$S.index

## Fechnerian scaling analysis using long computation
f.scal.subspace.long.mo &lt;- fechner(morse.subspace,
                                   format = "percent.same",
                                   compute.all = TRUE,
                                   check.computation = TRUE)
f.scal.subspace.long.mo
str(f.scal.subspace.long.mo)
attributes(f.scal.subspace.long.mo)
## for instance, the geodesic chains of the first kind
f.scal.subspace.long.mo$geodesic.chains.1

## check whether the overall Fechnerian distance of the first kind is
## equal to the overall Fechnerian distance of the second kind
## the difference, by theory a zero matrix
f.scal.subspace.long.mo$check[1]
## or, up to machine precision
f.scal.subspace.long.mo$check[2]

## plot of the S-index versus the overall Fechnerian distance
## for all (off-diagonal) pairs of stimuli
plot(f.scal.subspace.long.mo)
## for all (off-diagonal) pairs of stimuli with geodesic loops
## containing at least 3 links
plot(f.scal.subspace.long.mo, level = 3)

## corresponding summaries, including Pearson correlation and C-index
summary(f.scal.subspace.long.mo)
## in particular, accessing detailed summary through assignment
detailed.summary.mo &lt;- summary(f.scal.subspace.long.mo, level = 3)
str(detailed.summary.mo)

##
## (2) examples based on dataset \link{wish}
##

## dataset \link{wish} satisfies regular minimality in canonical form
wish
check.regular(wish, type = "probability.different")

## a self-contained 10-code subspace consisting of S, U, W, X,
## 0, 1, \ldots, 5
indices &lt;- which(is.element(names(wish), c("S", "U", "W", "X", 0:5)))
f.scal.wish &lt;- fechner(wish, format = "probability.different")
f.scal.wish$geodesic.loops[indices, indices]
wish.subspace &lt;- wish[indices, indices]
check.regular(wish.subspace, type = "probability.different")

## since the subspace is self-contained, results must be the same
f.scal.subspace.wi &lt;- fechner(wish.subspace,
                              format = "probability.different")
identical(f.scal.wish$geodesic.loops[indices, indices],
          f.scal.subspace.wi$geodesic.loops)
identical(f.scal.wish$overall.Fechnerian.distances[indices, indices],
          f.scal.subspace.wi$overall.Fechnerian.distances)

## dataset \link{wish} transformed to percent-same format
check.data(100 - (wish * 100), format = "percent.same")

## Fechnerian scaling analysis using short computation
f.scal.subspace.wi
str(f.scal.subspace.wi)
attributes(f.scal.subspace.wi)
## for instance, the graph-theoretic lengths of geodesic loops
f.scal.subspace.wi$graph.lengths.of.geodesic.loops

## Fechnerian scaling analysis using long computation
f.scal.subspace.long.wi &lt;- fechner(wish.subspace,
                                   format = "probability.different",
                                   compute.all = TRUE,
                                   check.computation = TRUE)
f.scal.subspace.long.wi
str(f.scal.subspace.long.wi)
attributes(f.scal.subspace.long.wi)
## for instance, the oriented Fechnerian distances of the first kind
f.scal.subspace.long.wi$oriented.Fechnerian.distances.1
## or, graph-theoretic lengths of chains and loops
identical(f.scal.subspace.long.wi$graph.lengths.of.geodesic.chains.1 +
          t(f.scal.subspace.long.wi$graph.lengths.of.geodesic.chains.1),
          f.scal.subspace.long.wi$graph.lengths.of.geodesic.loops.1)

## overall Fechnerian distances are not monotonically related to
## discrimination probabilities; however, there is a strong positive
## correlation
cor(as.vector(f.scal.wish$overall.Fechnerian.distances),
    as.vector(as.matrix(wish)))

## check whether the overall Fechnerian distance of the first kind is
## equal to the overall Fechnerian distance of the second kind
## the difference, by theory a zero matrix
f.scal.subspace.long.wi$check[1]
## or, up to machine precision
f.scal.subspace.long.wi$check[2]

## plot of the S-index versus the overall Fechnerian distance
## for all (off-diagonal) pairs of stimuli
plot(f.scal.subspace.long.wi)
## for all (off-diagonal) pairs of stimuli with geodesic loops
## containing at least 5 links
plot(f.scal.subspace.long.wi, level = 5)

## corresponding summaries, including Pearson correlation and C-index
summary(f.scal.subspace.long.wi)
## in particular, accessing detailed summary through assignment
detailed.summary.wi &lt;- summary(f.scal.subspace.long.wi, level = 5)
str(detailed.summary.wi)
</code></pre>


</div>