<div class="container">

<table style="width: 100%;"><tr>
<td>GetCI_Sparse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for sparsely observed data.</h2>

<h3>Description</h3>

<p>Bootstrap pointwise confidence intervals for the coefficient functions in functional concurrent regression for sparsely observed data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GetCI_Sparse(
  vars,
  outGrid = NULL,
  level = 0.95,
  R = 999,
  userBwMu = NULL,
  userBwCov = NULL,
  kern = "gauss",
  measurementError = FALSE,
  diag1D = "all",
  useGAM = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>A list of input functional/scalar covariates.
Each field corresponds to a functional (a list) or scalar (a vector) covariate.
The last entry is assumed to be the response if no entry is named 'Y'.
If a field corresponds to a functional covariate, it should have two fields: 'Lt', a list of time points, and 'Ly', a list of functional values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outGrid</code></td>
<td>
<p>A vector with the output time points, which need to be within 5% and 95% of the range of functional covariates. If NULL, outGrid will be generated from 5% to 95% of the range of functional covariates with 51 grids for fitting. Default: NULL</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>A number taking values in [0,1] determining the confidence level. Default: 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>An integer holding the number of bootstrap replicates. Default: 999.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>userBwMu</code></td>
<td>
<p>A scalar/vector bandwidth used for smoothing the mean function. Each entry in the vector represents the bandwidth used for the corresponding covariate in vars. For the scalar covariates, you can input 0 as a placeholder. If you only input a scalar, the function will use the same bandwidth to smooth all mean functions. — a scalar/vector of positive numeric -
default: NULL — if no scalar/vector value is provided, the bandwidth value for the smoothed mean function is chosen using 'GCV';</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>userBwCov</code></td>
<td>
<p>A scalar/vector bandwidth used for smoothing the auto or cross-covariances. If you use 1D smoothing for the diagonal line of the covariance (diag1D="all"), only one scalar input is needed. If you use 2D smoothing for the covariance (diag1D="none"), a vector of bandwidth is required. Each entry in the vector represents the bandwidth used for the corresponding covariate in vars. For the scalar covariates, you can input 0 as a placeholder. — a scalar/vector of positive numeric -
default: NULL — if no scalar/vector is provided, the bandwidth value for the smoothed cross-covariance function is chosen using 'GCV';</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kern</code></td>
<td>
<p>Smoothing kernel choice, common for mu and covariance;
"rect", "gauss", "epan", "gausvar", "quar" (default: "gauss")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measurementError</code></td>
<td>
<p>Assume measurement error in the data; logical - default: FALSE. If TRUE the diagonal raw covariance will be removed when smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag1D</code></td>
<td>
<p>A string specifying whether to use 1D smoothing for the diagonal line of the covariance.
'none': don't use 1D smoothing; 'all': use 1D for both auto- and cross-covariances. (default : 'all')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useGAM</code></td>
<td>
<p>Use GAM smoothing instead of local linear smoothing (semi-parametric option);  logical - default: FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If measurement error is assumed, the diagonal elements of the raw covariance will be removed. This could result in highly unstable estimate
if the design is very sparse, or strong seasonality presents.
WARNING! For very sparse functional data, setting measurementError = TRUE is not recommended.
</p>


<h3>Value</h3>

<p>A list containing the following fields:
</p>

<dl>
<dt>CI_beta0</dt>
<dd>
<p>CI for the intercept function — A data frame holding three variables:
<code>CIgrid</code> — the time grid where the CIs are evaluated,
<code>CI_beta0.lower</code> and <code>CI_beta0.upper</code> — the lower and upper bounds of the CIs
for the intercept function on <code>CIgrid</code>.</p>
</dd>
<dt>CI_beta</dt>
<dd>
<p> A list containing CIs for the slope functions — the length of
the list is same as the number of covariates. Each list contains the following fields:
A data frame holding three variables: <code>CIgrid</code> — the time grid where the CIs are evaluated,
<code>CI_beta_j.lower</code> and <code>CI_beta_j.upper</code> — the lower and upper bounds of the CIs
for the coefficient functions on <code>CIgrid</code> for <code class="reqn">j = 1,2,\dots</code>.</p>
</dd>
<dt>CI_R2</dt>
<dd>
<p>CI the time-varying <code class="reqn">R^2(t)</code> — A data frame holding three variables:
<code>CIgrid</code> — the time grid where the CIs are evaluated,
<code>CI_R2.lower</code> and <code>CI_R2.upper</code> — the lower and upper bounds of the CIs
for the time-varying <code class="reqn">R^2(t)</code> on <code>CIgrid</code>.</p>
</dd>
<dt>level</dt>
<dd>
<p>The confidence level of the CIs.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">
set.seed(1)
n &lt;- 30
nGridIn &lt;- 100
sparsity &lt;- 5:10 # Sparse data sparsity
T &lt;- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw &lt;- 0.1
outGrid &lt;- round(seq(min(T), 1, by=0.05), 2)
# Simulate functional data
mu &lt;- T * 2 # mean function for X_1
sigma &lt;- 1

beta_0 &lt;- 0
beta &lt;- rbind(cos(T), 1.5 + sin(T))
beta_2 &lt;- 1

Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
  Y[i, ] &lt;- beta_0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}

# Sparsify functional data
set.seed(1)
X_1sp &lt;- fdapace::Sparsify(X_1, T, sparsity)
Ysp &lt;- fdapace::Sparsify(Y, T, sparsity)
vars &lt;- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
res &lt;-  GetCI_Sparse(vars, outGrid[-c(1,21)], level = 0.95, R = 2,
                     userBwMu = c(.1,.1,.1), userBwCov = c(.1,.1,.1),
                     kern='gauss', measurementError=TRUE, diag1D='none',
                     useGAM = FALSE)
</code></pre>


</div>