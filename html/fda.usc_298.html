<div class="container">

<table style="width: 100%;"><tr>
<td>semimetric.NPFDA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Proximities between functional data (semi-metrics)</h2>

<h3>Description</h3>

<p>Computes semi-metric distances of functional data based on Ferraty F and
Vieu, P. (2006).
</p>


<h3>Usage</h3>

<pre><code class="language-R">semimetric.deriv(
  fdata1,
  fdata2 = fdata1,
  nderiv = 1,
  nknot = ifelse(floor(ncol(DATA1)/3) &gt; floor((ncol(DATA1) - nderiv - 4)/2),
    floor((ncol(DATA1) - nderiv - 4)/2), floor(ncol(DATA1)/3)),
  ...
)

semimetric.fourier(
  fdata1,
  fdata2 = fdata1,
  nderiv = 0,
  nbasis = ifelse(floor(ncol(DATA1)/3) &gt; floor((ncol(DATA1) - nderiv - 4)/2),
    floor((ncol(DATA1) - nderiv - 4)/2), floor(ncol(DATA1)/3)),
  period = NULL,
  ...
)

semimetric.hshift(fdata1, fdata2 = fdata1, t = 1:ncol(DATA1), ...)

semimetric.mplsr(fdata1, fdata2 = fdata1, q = 2, class1, ...)

semimetric.pca(fdata1, fdata2 = fdata1, q = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdata1</code></td>
<td>
<p>Functional data 1 or curve 1. <code>DATA1</code> with dimension
(<code>n1</code> x <code>m</code>), where <code>n1</code> is the number of curves and <code>m</code>
are the points observed in each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fdata2</code></td>
<td>
<p>Functional data 2 or curve 2. <code>DATA1</code> with dimension
(<code>n2</code> x <code>m</code>), where <code>n2</code> is the number of curves and <code>m</code>
are the points observed in each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nderiv</code></td>
<td>
<p>Order of derivation, used in <code>semimetric.deriv</code> and <br><code>semimetric.fourier</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nknot</code></td>
<td>
<p>semimetric.deriv argument: number of interior knots (needed for
defining the B-spline basis).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbasis</code></td>
<td>
<p><code>semimetric.fourier</code>: size of the basis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>period</code></td>
<td>
<p><code>semimetric.fourier</code>:allows to select the period for the
fourier expansion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p><code>semimetric.hshift</code>: vector which defines <code>t</code> (one can
choose <code>1,2,...,nbt</code> where <code>nbt</code> is the number of points of the
discretization)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>If <code>semimetric.pca</code>: the retained number of principal
components.<br> If <code>semimetric.mplsr</code>: the retained number of factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class1</code></td>
<td>
<p><code>semimetric.mplsr</code>: vector containing a categorical
response which corresponds to class number for units stored in <code>DATA1</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>semimetric.deriv</code>: approximates <code class="reqn">L_2</code> metric
between derivatives of the curves based on ther B-spline representation. The
derivatives set with the argument <code>nderiv</code>.<br><code>semimetric.fourier</code>: approximates <code class="reqn">L_2</code> metric between the curves
based on ther B-spline representation. The derivatives set with the argument
<code>nderiv</code>.<br><code>semimetric.hshift</code>: computes distance between curves
taking into account an horizontal shift effect.<br><code>semimetric.mplsr</code>:
computes distance between curves based on the partial least squares
method.<br><code>semimetric.pca</code>: computes distance between curves based on
the functional principal components analysis method.
</p>
<p>In the next semi-metric functions the functional data <code class="reqn">X</code> is
approximated by <code class="reqn">k_n</code> elements of the Fourier, Bâ€“spline, PC or PLS basis
using, <code class="reqn">\hat{X_i} =\sum_{k=1}^{k_n}\nu_{k,i}\xi_k</code>, where <code class="reqn">\nu_k</code>
are the coefficient of the expansion on the basis function
<code class="reqn">\left\{\xi_k\right\}_{k=1}^{\infty}</code>.<br> The distances between the q-order derivatives of two curves <code class="reqn">X_{1}</code> and
<code class="reqn">X_2</code> is,
</p>
<p style="text-align: center;"><code class="reqn">d_{2}^{(q)}\left(X_1,X_2\right)_{k_n}=\sqrt{\frac{1}{T}\int_{T}\left(X_{1}^{(q)}(t)-X_{2}^{(q)}(t)\right)^2
dt}</code>
</p>
<p> where <code class="reqn">X_{i}^{(q)}\left(t\right)</code> denot the <code class="reqn">q</code> derivative of
<code class="reqn">X_i</code>.
</p>
<p><code>semimetric.deriv</code> and <code>semimetric.fourier</code> function use a
B-spline and Fourier approximation respectively for each curve and the
derivatives are directly computed by differentiating several times their
analytic form, by default <code>q=1</code> and <code>q=0</code> respectively.
<code>semimetric.pca</code> and <code>semimetric.mprls</code> function compute
proximities between curves based on the functional principal components
analysis (FPCA) and the functional partial least square analysis (FPLS),
respectively. The FPC and FPLS reduce the functional data in a reduced
dimensional space (q components). <code>semimetric.mprls</code> function requires
a scalar response.
</p>
<p style="text-align: center;"><code class="reqn">d_{2}^{(q)}\left(X_1,X_2\right)_{k_n}\approx\sqrt{\sum_{k=1}^{k_n}\left(\nu_{k,1}-\nu_{k,2}\right)^2\left\|\xi_k^{(q)}\right\|dt}</code>
</p>

<p><code>semimetric.hshift</code> computes proximities between curves taking into
account an horizontal shift effect.
</p>
<p style="text-align: center;"><code class="reqn">d_{hshift}\left(X_1,X_2\right)=\min_{h\in\left[-mh,mh\right]}d_2(X_1(t),X_2(t+h))</code>
</p>

<p>where <code class="reqn">mh</code> is the maximum horizontal shifted allowed.
</p>


<h3>Value</h3>

<p>Returns a proximities matrix between two functional datasets.
</p>


<h3>Source</h3>

<p><a href="https://www.math.univ-toulouse.fr/~ferraty/SOFTWARES/NPFDA/">https://www.math.univ-toulouse.fr/~ferraty/SOFTWARES/NPFDA/</a>
</p>


<h3>References</h3>

<p>Ferraty, F. and Vieu, P. (2006). <em>Nonparametric functional
data analysis.</em> Springer Series in Statistics, New York.
</p>
<p>Ferraty, F. and Vieu, P. (2006). <em>NPFDA in practice</em>.  Free access on
line at <a href="https://www.math.univ-toulouse.fr/~ferraty/SOFTWARES/NPFDA/">https://www.math.univ-toulouse.fr/~ferraty/SOFTWARES/NPFDA/</a>
</p>


<h3>See Also</h3>

<p>See also <code>metric.lp</code> and <code>semimetric.basis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run:  
#	INFERENCE PHONDAT
data(phoneme)
ind=1:100 # 2 groups
mlearn&lt;-phoneme$learn[ind,]
mtest&lt;-phoneme$test[ind,]
n=nrow(mlearn[["data"]])
np=ncol(mlearn[["data"]])
mdist1=semimetric.pca(mlearn,mtest)
mdist2=semimetric.pca(mlearn,mtest,q=2)
mdist3=semimetric.deriv(mlearn,mtest,nderiv=0)
mdist4=semimetric.fourier(mlearn,mtest,nderiv=2,nbasis=21)
#uses hshift function
#mdist5=semimetric.hshift(mlearn,mtest) #takes a lot
glearn&lt;-phoneme$classlearn[ind]
#uses mplsr function
mdist6=semimetric.mplsr(mlearn,mtest,5,glearn)
mdist0=metric.lp(mlearn,mtest)
b=as.dist(mdist6)
c2=hclust(b)
plot(c2)
memb &lt;- cutree(c2, k = 2)
table(memb,phoneme$classlearn[ind])
 
## End(Not run) 
  
</code></pre>


</div>