<div class="container">

<table style="width: 100%;"><tr>
<td>inprod_mfd_diag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inner product of two multivariate functional data objects,
for each observation</h2>

<h3>Description</h3>

<p>Inner product of two multivariate functional data objects,
for each observation
</p>


<h3>Usage</h3>

<pre><code class="language-R">inprod_mfd_diag(mfdobj1, mfdobj2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mfdobj1</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mfdobj2</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>,
with the same number of functional variables and observations
as <code>mfdobj1</code>.
If NULL, then <code>mfdobj2=mfdobj1</code>. Default is NULL.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It calculates the inner product of two
multivariate functional data objects.
The main function <code>inprod</code> of the package <code>fda</code>
calculates inner products among
all possible couples of observations.
This means that, if <code>mfdobj1</code> has <code>n1</code> observations
and <code>mfdobj2</code> has <code>n2</code> observations,
then for each variable <code>n1 X n2</code> inner products are calculated.
However, often one is interested only in calculating
the <code>n</code> inner products
between the <code>n</code> observations of <code>mfdobj1</code> and
the corresponding <code>n</code>
observations of <code>mfdobj2</code>. This function provides
this "diagonal" inner products only,
saving a lot of computation with respect to using
<code>fda::inprod</code> and then extracting the
diagonal elements.
Note that the code of this function calls a modified version
of <code>fda::inprod()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">mfdobj &lt;- data_sim_mfd()
inprod_mfd_diag(mfdobj)

</code></pre>


</div>