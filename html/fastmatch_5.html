<div class="container">

<table style="width: 100%;"><tr>
<td>fmatch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fast match() replacement
</h2>

<h3>Description</h3>

<p><code>fmatch</code> is a faster version of the built-in <code>match</code>()
function. It is slightly faster than the built-in version because it
uses more specialized code, but in addition it retains the hash table
within the table object such that it can be re-used, dramatically reducing
the look-up time especially for large tables.
</p>
<p>Although <code>fmatch</code> can be used separately, in general it is also
safe to use: <code>match &lt;- fmatch</code> since it is a drop-in
replacement. Any cases not directly handled by <code>fmatch</code> are passed
to <code>match</code> with a warning.
</p>
<p><code>fmatch.hash</code> is identical to <code>fmatch</code> but it returns the table
object with the hash table attached instead of the result, so it can be
used to create a table object in cases where direct modification is
not possible.
</p>
<p><code>%fin%</code> is a version of the built-in <code>%in%</code> function
that uses <code>fmatch</code> instead of <code>match</code>().
</p>


<h3>Usage</h3>

<pre><code class="language-R">fmatch(x, table, nomatch = NA_integer_, incomparables = NULL)
fmatch.hash(x, table, nomatch = NA_integer_, incomparables = NULL)
x %fin% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>values to be matched</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>values to be matched against</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is
found. It is coerced to <code>integer</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>incomparables</code></td>
<td>
<p>a vector of values that cannot be matched. Any
value other than <code>NULL</code> will result in a fall-back to
<code>match</code> without any speed gains.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>match</code> for the purpose and details of the
<code>match</code> function. <code>fmatch</code> is a drop-in replacement for
the <code>match</code> function with the focus on
performance. <code>incomparables</code> are not supported by <code>fmatch</code>
and will be passed down to <code>match</code>.
</p>
<p>The first match against a table results in a hash table to be computed
from the table. This table is then attached as the <code>".match.hash"</code>
attribute of the table so that it can be re-used on subsequent calls
to <code>fmatch</code> with the same table.
</p>
<p>The hashing algorithm used is the same as the <code>match</code> function in
R, but it is re-implemented in a slightly different way to improve its
performance at the cost of supporting only a subset of types (integer,
real and character). For any other types <code>fmatch</code> falls back to
<code>match</code> (with a warning).
</p>


<h3>Value</h3>

<p><code>fmatch</code>: A vector of the same length as <code>x</code> - see
<code>match</code> for details.
</p>
<p><code>fmatch.hash</code>: <code>table</code>, possibly coerced to match the type
of <code>x</code>, with the hash table attached.
</p>
<p><code>%fin%</code>: A logical vector the same length as <code>x</code> - see
<code>%in%</code> for details.
</p>


<h3>Note</h3>

<p><code>fmatch</code> modifies the <code>table</code> by attaching an attribute to
it. It is expected that the values will not change unless that
attribute is dropped. Under normal circumstances this should not have
any effect from user's point of view, but there is a theoretical
chance of the cache being out of sync with the table in case the table
is modified directly (e.g. by some C code) without removing
attributes.
</p>
<p>In cases where the <code>table</code> object cannot be modified (or such
modification would not survive) <code>fmatch.hash</code> can be used to build
the hash table and return <code>table</code> object including the hash
table. In that case no lookup is done and <code>x</code> is only used to
determine the type into which <code>table</code> needs to be coerced.
</p>
<p>Also <code>fmatch</code> does not convert to a common encoding so strings
with different representation in two encodings don't match.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>


<h3>See Also</h3>

<p><code>match</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># some random speed comparison examples:
# first use integer matching
x = as.integer(rnorm(1e6) * 1000000)
s = 1:100
# the first call to fmatch is comparable to match
system.time(fmatch(s,x))
# but the subsequent calls take no time!
system.time(fmatch(s,x))
system.time(fmatch(-50:50,x))
system.time(fmatch(-5000:5000,x))
# here is the speed of match for comparison
system.time(base::match(s, x))
# the results should be identical
identical(base::match(s, x), fmatch(s, x))

# next, match a factor against the table
# this will require both x and the factor
# to be cast to strings
s = factor(c("1","1","2","foo","3",NA))
# because the casting will have to allocate a string
# cache in R, we run a dummy conversion to take
# that out of the equation
dummy = as.character(x)
# now we can run the speed tests
system.time(fmatch(s, x))
system.time(fmatch(s, x))
# the cache is still valid for string matches as well
system.time(fmatch(c("foo","bar","1","2"),x))
# now back to match
system.time(base::match(s, x))
identical(base::match(s, x), fmatch(s, x))

# finally, some reals to match
y = rnorm(1e6)
s = c(y[sample(length(y), 100)], 123.567, NA, NaN)
system.time(fmatch(s, y))
system.time(fmatch(s, y))
system.time(fmatch(s, y))
system.time(base::match(s, y))
identical(base::match(s, y), fmatch(s, y))

# this used to fail before 0.1-2 since nomatch was ignored
identical(base::match(4L, 1:3, nomatch=0), fmatch(4L, 1:3, nomatch=0))
</code></pre>


</div>