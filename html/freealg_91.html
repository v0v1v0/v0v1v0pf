<div class="container">

<table style="width: 100%;"><tr>
<td>dot-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class “dot”</h2>

<h3>Description</h3>

<p>The dot object is defined so that <code>.[x,y]</code> returns the commutator
of <code>x</code> and <code>y</code>, that is, <code>xy-yx</code> or the Lie bracket
<code class="reqn">[x,y]</code>.  It would have been nice to use <code>[x,y]</code> (that is,
without the dot) but although this is syntactically consistent, it
cannot be done in R.
</p>
<p>The “meat” of the dot functionality is:
</p>
<pre>
setClass("dot", slots = c(ignore='numeric'))
`.` &lt;- new("dot")
setMethod("[",signature(x="dot",i="ANY",j="ANY"),function(x,i,j,drop){i*j-j*i})
</pre>
<p>The package code includes other bits and pieces such as informative
error messages for idiom such as <code>.[]</code>.  The package defines a
matrix method for the dot object.  This is because “<code>*</code>”
returns (incorrectly, in my view) the elementwise product, not the
matrix product.
</p>
<p>The Jacobi identity, satisfied by any associative algebra, is
</p>
<p style="text-align: center;"><code class="reqn">
  \left[x,\left[y,z\right]\right]+
  \left[y,\left[z,x\right]\right]+
  \left[z,\left[x,y\right]\right]=0
</code>
</p>

<p>and the left hand side is returned by <code>jacobi()</code>, which should be
zero (for some definition of “zero”).
</p>
<p>Function <code>ad()</code> returns the adjoint operator.  The <code>adjoint</code>
vignette provides details and examples of the adjoint operator.
</p>
<p>The dot object is generated by running script <code>inst/dot.Rmd</code>, which
includes some further discussion and technical documentation, and
creates file <code>dot.rda</code> which resides in the <code>data/</code> directory.
</p>


<h3>Value</h3>

<p>Always returns an object of the same class as <code>xy</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>
<code>ignore</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>, just a
formal placeholder</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt>[</dt>
<dd>
<p><code>signature(x = "dot", i = "ANY", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "dot", i = "ANY", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "dot", i = "function", j = "function")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "dot", i = "matrix", j = "matrix")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "dot", i = "missing", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt>
<dd>
<p><code>signature(x = "dot", i = "missing", j = "missing")</code>: ... </p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">
.[as.freealg("x"),as.freealg("y")]
.[as.freealg("x"),as.freealg("y+2z")]
.[as.freealg("x+y+2xYx"),as.freealg("x+y+2xYx")]


x &lt;- rfalg()
y &lt;- rfalg()
z &lt;- rfalg()

jacobi(x,y,z) # Jacobi identity
.[x,.[y,z]] + .[y,.[z,x]] + .[z,.[x,y]]  # Jacobi, expanded


f &lt;- ad(x)
f(y)


rM &lt;- function(...){matrix(sample(1:9,9),3,3)} # a random matrix

M &lt;- rM()
N &lt;- rM()
O &lt;- rM()

.[M,N]
jacobi(M,N,O)

plot(.[sin,tan](seq(from=0,to=1,len=100)))

</code></pre>


</div>