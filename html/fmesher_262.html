<div class="container">

<table style="width: 100%;"><tr>
<td>fm_evaluate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Methods for projecting to/from mesh objects</h2>

<h3>Description</h3>

<p>Calculate evaluation information and/or evaluate a function
defined on a mesh or function space.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fm_evaluate(...)

## Default S3 method:
fm_evaluate(mesh, field, ...)

## S3 method for class 'fm_evaluator'
fm_evaluate(projector, field, ...)

fm_evaluator(...)

## S3 method for class 'fm_mesh_2d'
fm_evaluator(mesh, loc = NULL, lattice = NULL, crs = NULL, ...)

## S3 method for class 'fm_mesh_1d'
fm_evaluator(mesh, loc = NULL, xlim = mesh$interval, dims = 100, ...)

## S3 method for class 'fm_tensor'
fm_evaluator(x, loc, ...)

fm_evaluator_lattice(
  mesh,
  xlim = NULL,
  ylim = NULL,
  dims = c(100, 100),
  projection = NULL,
  crs = NULL,
  ...
)

## S3 method for class 'inla.mesh'
fm_evaluator(mesh, loc = NULL, lattice = NULL, crs = NULL, ...)

## S3 method for class 'inla.mesh.1d'
fm_evaluator(mesh, loc = NULL, xlim = mesh$interval, dims = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mesh</code></td>
<td>
<p>An <code>inla.mesh</code> or <code>inla.mesh.1d</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>field</code></td>
<td>
<p>Basis function weights, one per mesh basis function, describing
the function to be evaluated at the projection locations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projector</code></td>
<td>
<p>An <code>fm_evaluator</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>Projection locations.  Can be a matrix, <code>SpatialPoints</code>,
<code>SpatialPointsDataFrame</code>, <code>sf</code>, <code>sfc</code>, or <code>sfg</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lattice</code></td>
<td>
<p>An <code>fm_lattice_2d()</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>An optional CRS or inla.CRS object associated with <code>loc</code>
and/or <code>lattice</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>X-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Lattice dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p><code>fm_tensor()</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>Y-axis limits for a lattice. For R2 meshes, defaults to covering
the domain.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>projection</code></td>
<td>
<p>One of <code>c("default", "longlat", "longsinlat", "mollweide")</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A vector or matrix of the evaluated function
</p>
<p>An <code>fm_evaluator</code> object
</p>


<h3>Methods (by class)</h3>


<ul><li> <p><code>fm_evaluate(default)</code>: The default method calls
<code>proj = fm_evaluator(mesh, ...)</code>, followed by <code>fm_evaluate(proj, field)</code>.
</p>
</li></ul>
<h3>Functions</h3>


<ul>
<li> <p><code>fm_evaluate()</code>: Returns the field function evaluated at the locations determined by an
<code>fm_evaluator</code> object. <code>fm_evaluate(mesh, field = field, ...)</code> is a
shortcut to <code>fm_evaluate(fm_evaluator(mesh, ...), field = field)</code>.
</p>
</li>
<li> <p><code>fm_evaluator()</code>: Returns an <code>fm_evaluator</code> list object with evaluation information.
The <code>proj</code> element contains a mapping matrix <code>A</code> and a logical vector <code>ok</code>,
that indicates which locations were mappable to the input mesh.
For <code>fm_mesh_2d</code> and <code>inla.mesh</code>
input, <code>proj</code> also contains a matrix <code>bary</code> and vector <code>t</code>, with the
barycentric coordinates within the triangle each input location falls in.
</p>
</li>
<li> <p><code>fm_evaluator(fm_mesh_2d)</code>: The <code>...</code> arguments are passed on to <code>fm_evaluator_lattice()</code>
if no <code>loc</code> or <code>lattice</code> is provided.
</p>
</li>
<li> <p><code>fm_evaluator_lattice()</code>: Creates an <code>fm_lattice_2d()</code> object, by default covering the input mesh.
</p>
</li>
<li> <p><code>fm_evaluator(inla.mesh)</code>: The <code>...</code> arguments are passed on to <code>fm_evaluator_lattice()</code>
if no <code>loc</code> or <code>lattice</code> is provided.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>fm_mesh_2d()</code>, <code>fm_mesh_1d()</code>,
<code>fm_lattice_2d()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (TRUE) {
  n &lt;- 20
  loc &lt;- matrix(runif(n * 2), n, 2)
  mesh &lt;- fm_rcdt_2d_inla(loc, refine = list(max.edge = 0.05))
  proj &lt;- fm_evaluator(mesh)
  field &lt;- cos(mesh$loc[, 1] * 2 * pi * 3) * sin(mesh$loc[, 2] * 2 * pi * 7)
  image(proj$x, proj$y, fm_evaluate(proj, field))
}

# if (require("ggplot2") &amp;&amp;
#  require("ggpolypath")) {
#  ggplot() +
#    gg(data = fm_as_sfc(mesh), col = field)
# }


</code></pre>


</div>