<div class="container">

<table style="width: 100%;"><tr>
<td>ldf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LDF method for flash and flash fit objects</h2>

<h3>Description</h3>

<p>Given a <code>flash</code> or <code>flash_fit</code> object, returns the LDF
decomposition <code class="reqn">Y \approx LDF'</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ldf(object, type)

## S3 method for class 'flash'
ldf(object, type = "f")

## S3 method for class 'flash_fit'
ldf(object, type = "f")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object inheriting from class <code>flash</code> or
<code>flash_fit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Takes identical arguments to function <code>norm</code>. Use
<code>"f"</code> or <code>"2"</code> for the 2-norm (Euclidean norm); <code>"o"</code> or
<code>"1"</code> for the 1-norm (taxicab norm); and <code>"i"</code> or <code>"m"</code> for
the infinity norm (maximum norm).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When the prior families <code class="reqn">G_\ell^{(k)}</code> and <code class="reqn">G_f^{(k)}</code> are closed
under scaling (as is typically the case), then the EBMF model (as
described in the documention to function <code>flash</code>) is only
identifiable up to scaling by a diagonal matrix <code class="reqn">D</code>:
</p>
<p style="text-align: center;"><code class="reqn">Y = LDF' + E.</code>
</p>

<p>Method <code>ldf</code> scales columns <code class="reqn">\ell_k</code> and <code class="reqn">f_k</code>
so that, depending on the argument to parameter <code>type</code>, their
1-norms, 2-norms, or infinity norms are equal to 1.
</p>


<h3>Value</h3>

<p>A list with fields <code>L</code>, <code>D</code>, and <code>F</code>, each of which
corresponds to one of the matrices in the decomposition <code class="reqn">Y \approx LDF'</code>
(with the columns of <code class="reqn">L</code> and <code class="reqn">F</code> scaled according to
argument <code>type</code>). Note that <code>D</code> is returned as a vector rather
than a matrix (the vector of diagonal entries in <code class="reqn">D</code>). Thus, "fitted
values" <code class="reqn">LDF'</code> can be recovered as <code>L %*% diag(D) %*% t(F)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ldf(flash)</code>: LDF decomposition for <code>flash</code> objects
</p>
</li>
<li> <p><code>ldf(flash_fit)</code>: LDF decomposition for <code>flash_fit</code> objects
</p>
</li>
</ul>
</div>