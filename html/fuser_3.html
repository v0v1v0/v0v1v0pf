<div class="container">

<table style="width: 100%;"><tr>
<td>fusedLassoProximal</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fused lasso optimisation with proximal-gradient method.
(Chen et al. 2010)</h2>

<h3>Description</h3>

<p>Fused lasso optimisation with proximal-gradient method.
(Chen et al. 2010)
</p>


<h3>Usage</h3>

<pre><code class="language-R">fusedLassoProximal(X, Y, groups, lambda, gamma, G, mu = 1e-04, tol = 1e-06,
  num.it = 1000, lam.max = NULL, c.flag = FALSE, intercept = TRUE,
  penalty.factors = NULL, conserve.memory = p &gt;= 10000, scaling = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>matrix of covariates (n by p)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>vector of responses (length n)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>vector of group indicators (length n)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Sparsity hyperparameter (accepts scalar value only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Fusion hyperparameter (accepts scalar value only)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Matrix of pairwise group information sharing weights (K by K)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Smoothness parameter for proximal optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Tolerance for optimization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.it</code></td>
<td>
<p>Number of iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lam.max</code></td>
<td>
<p>Maximal eigenvalue of <code>t(X) %*% X</code> (will be calculate
if not provided)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c.flag</code></td>
<td>
<p>Whether to use Rcpp for certain calculations (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>Whether to include a (group-specific) intercept term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty.factors</code></td>
<td>
<p>Weights for sparsity penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conserve.memory</code></td>
<td>
<p>Whether to calculate XX and XY on the fly, conserving memory
at the cost of speed. (True by default iff p &gt;= 10000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>if TRUE, scale the sum-squared loss for each group by 1/n_k
where n_k is the number of samples in group k.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The proximal algorithm uses <code>t(X) %*% X</code> and <code>t(X) %*% Y</code>. The function will attempt to
pre-calculate these values to speed up computation. This may not always be possible due to
memory restrictions; at present this is only done for p &lt; 10,000. When p &gt; 10,000,
crossproducts are calculated explicitly; calculation can be speeded up by using
Rcpp code (setting c.flag=TRUE).
</p>


<h3>Value</h3>

<p>A matrix with the linear coefficients for each group (p by k).
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(123)
# Generate simple heterogeneous dataset
k = 4 # number of groups
p = 100 # number of covariates
n.group = 15 # number of samples per group
sigma = 0.05 # observation noise sd
groups = rep(1:k, each=n.group) # group indicators
# sparse linear coefficients
beta = matrix(0, p, k)
nonzero.ind = rbinom(p*k, 1, 0.025/k) # Independent coefficients
nonzero.shared = rbinom(p, 1, 0.025) # shared coefficients
beta[which(nonzero.ind==1)] = rnorm(sum(nonzero.ind), 1, 0.25)
beta[which(nonzero.shared==1),] = rnorm(sum(nonzero.shared), -1, 0.25)

X = lapply(1:k,
           function(k.i) matrix(rnorm(n.group*p),
                                n.group, p)) # covariates
y = sapply(1:k,
           function(k.i) X[[k.i]] %*% beta[,k.i] +
                           rnorm(n.group, 0, sigma)) # response
X = do.call('rbind', X)

# Pairwise Fusion strength hyperparameters (tau(k,k'))
# Same for all pairs in this example
G = matrix(1, k, k)

# Use L1 fusion to estimate betas (with near-optimal sparsity and
# information sharing among groups)
beta.estimate = fusedLassoProximal(X, y, groups, lambda=0.01, tol=3e-3,
                                   gamma=0.01, G, intercept=FALSE,
                                   num.it=500)
</code></pre>


</div>