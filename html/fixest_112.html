<div class="container">

<table style="width: 100%;"><tr>
<td>coeftable.fixest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Obtain various statistics from an estimation</h2>

<h3>Description</h3>

<p>Set of functions to directly extract some commonly used statistics, like the p-value or
the table of coefficients, from estimations. This was first implemented for
<code>fixest</code> estimations, but has some support for other models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'fixest'
coeftable(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  list = FALSE,
  ...
)

## S3 method for class 'fixest'
se(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)

## S3 method for class 'fixest'
tstat(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)

## S3 method for class 'fixest'
pvalue(
  object,
  vcov = NULL,
  ssc = NULL,
  cluster = NULL,
  keep = NULL,
  drop = NULL,
  order = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>fixest</code> object. For example an estimation obtained from <code>feols</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>A function to be used to compute the standard-errors of each fixest object. You can
pass extra arguments to this function using the argument <code>.vcov_args</code>. See the example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code>ssc</code>. Represents
how the degree of freedom correction should be done.You must use the function <code>ssc</code>
for this argument. The arguments and defaults of the function <code>ssc</code> are:
<code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>,
<code>t.df = "min"</code>, <code style="white-space: pre;">⁠fixef.force_exact=FALSE)⁠</code>. See the help of the function <code>ssc</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested). Can
be either a list of vectors, a character vector of variable names, a formula or an
integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code> contained
in the data.frame <code>base</code> used for the estimation. All the following <code>cluster</code> arguments
are valid and do the same thing: <code style="white-space: pre;">⁠cluster = base[, c("var1, "var2")]⁠</code>,
<code style="white-space: pre;">⁠cluster = c("var1, "var2")⁠</code>, <code>cluster = ~var1+var2</code>. If the two variables were used as
clusters in the estimation, you could further use <code>cluster = 1:2</code> or leave it blank
with <code>se = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was the 1st [resp. 2nd] cluster).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep</code></td>
<td>
<p>Character vector. This element is used to display only a subset of variables. This
should be a vector of regular expressions (see <code>base::regex</code> help for more info). Each
variable satisfying any of the regular expressions will be kept. This argument is applied post
aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to display
only <code>x1</code> to <code>x9</code>, then you could use <code>keep = "x[[:digit:]]$"</code>. If the first character is an
exclamation mark, the effect is reversed (e.g. keep = "!Intercept" means: every variable that
does not contain “Intercept” is kept). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Character vector. This element is used if some variables are not to be displayed.
This should be a vector of regular expressions (see <code>base::regex</code> help for more info). Each
variable satisfying any of the regular expressions will be discarded. This argument is applied
post aliasing (see argument <code>dict</code>). Example: you have the variable <code>x1</code> to <code>x55</code> and want to
display only <code>x1</code> to <code>x9</code>, then you could use <code style="white-space: pre;">⁠drop = "x[[:digit:]]{2}⁠</code>". If the first character
is an exclamation mark, the effect is reversed (e.g. drop = "!Intercept" means: every variable
that does not contain “Intercept” is dropped). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Character vector. This element is used if the user wants the variables to be
ordered in a certain way. This should be a vector of regular expressions (see <code>base::regex</code>
help for more info). The variables satisfying the first regular expression will be placed first,
then the order follows the sequence of regular expressions. This argument is applied post
aliasing (see argument <code>dict</code>). Example: you have the following variables: <code>month1</code> to <code>month6</code>,
then <code>x1</code> to <code>x5</code>, then <code>year1</code> to <code>year6</code>. If you want to display first the x's, then the
years, then the months you could use: <code>order = c("x", "year")</code>. If the first character is an
exclamation mark, the effect is reversed (e.g. order = "!Intercept" means: every variable that
does not contain “Intercept” goes first).  See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, then a nested list is returned, the
first layer is accessed with the coefficients names; the second layer with the
following values: <code>coef</code>, <code>se</code>, <code>tstat</code>, <code>pvalue</code>. Note that the variable <code>"(Intercept)"</code>
is renamed into <code>"constant"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to be passed to <code>summary.fixest</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This set of tiny functions is primarily constructed for <code>fixest</code> estimations.
</p>


<h3>Value</h3>

<p>Returns a table of coefficients, with in rows the variables and four columns: the estimate,
the standard-error, the t-statistic and the p-value.
</p>
<p>If <code>list = TRUE</code> then a nested list is returned, the first layer is accessed with
the coefficients names; the second layer with the following values:
<code>coef</code>, <code>se</code>, <code>tstat</code>, <code>pvalue</code>. For example, with <code>res = coeftable(est, list = TRUE)</code>
you can access the SE of the coefficient <code>x1</code> with <code>res$x1$se</code>; and its
coefficient with <code>res$x1$coef</code>, etc.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>se(fixest)</code>: Extracts the standard-error of an estimation
</p>
</li>
<li> <p><code>tstat(fixest)</code>: Extracts the t-statistics of an estimation
</p>
</li>
<li> <p><code>pvalue(fixest)</code>: Extracts the p-value of an estimation
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
# Some data and estimation
data(trade)
est = fepois(Euros ~ log(dist_km) | Origin^Product + Year, trade)

#
# Coeftable/se/tstat/pvalue
#

# Default is clustering along Origin^Product
coeftable(est)
se(est)
tstat(est)
pvalue(est)

# Now with two-way clustered standard-errors
#  and using coeftable()

coeftable(est, cluster = ~Origin + Product)
se(est, cluster = ~Origin + Product)
pvalue(est, cluster = ~Origin + Product)
tstat(est, cluster = ~Origin + Product)

# Or you can cluster only once:
est_sum = summary(est, cluster = ~Origin + Product)
coeftable(est_sum)
se(est_sum)
tstat(est_sum)
pvalue(est_sum)

# You can use the arguments keep, drop, order
# to rearrange the results

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

est_iv = feols(y ~ x1 | x2 ~ x3, base)

tstat(est_iv, keep = "x1")
coeftable(est_iv, keep = "x1|Int")

coeftable(est_iv, order = "!Int")

#
# Using lists
#

# Returning the coefficients table as a list can be useful for quick
# reference in markdown documents.
# Note that the "(Intercept)" is renamed into "constant"

res = coeftable(est_iv, list = TRUE)

# coefficient of the constant:
res$constant$coef

# pvalue of x1
res$x1$pvalue



</code></pre>


</div>