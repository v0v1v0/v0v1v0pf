<div class="container">

<table style="width: 100%;"><tr>
<td>calculateFeatureSet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate Landscape Features</h2>

<h3>Description</h3>

<p>Performs an Exploratory Landscape Analysis of a continuous function and
computes various features, which quantify the function's landscape.
Currently, the following feature sets are provided:
</p>

<ul>
<li>
<p>CM: cell mapping features (<code>"cm_angle"</code>, <code>"cm_conv"</code>,
<code>"cm_grad"</code>)
</p>
</li>
<li>
<p>ELA: classical ELA features (<code>"ela_conv"</code>,
<code>"ela_curv"</code>, <code>"ela_distr"</code>, <code>"ela_level"</code>,
<code>"ela_local"</code>, <code>"ela_meta"</code>)
</p>
</li>
<li>
<p>GCM: general cell mapping features (<code>"gcm"</code>)
</p>
</li>
<li>
<p>BT: barrier tree features (<code>"bt"</code>)
</p>
</li>
<li>
<p>IC: information content features (<code>"ic"</code>)
</p>
</li>
<li>
<p>Basic: basic features (<code>"basic"</code>)
</p>
</li>
<li>
<p>Disp: dispersion features (<code>"disp"</code>)
</p>
</li>
<li>
<p>LiMo: linear model features (<code>"limo"</code>)
</p>
</li>
<li>
<p>NBC: nearest better clustering features (<code>"nbc"</code>)
</p>
</li>
<li>
<p>PC: principal component features (<code>"pca"</code>)
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">calculateFeatureSet(feat.object, set, control, ...)

calculateFeatures(feat.object, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>feat.object</code></td>
<td>
<p>[<code>FeatureObject</code>]<br>
A feature object as created by <code>createFeatureObject</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set</code></td>
<td>
<p>[<code>character(1)</code>]<br>
Name of the feature set, which should be computed. All possible feature
sets can be listed using <code>listAvailableFeatureSets</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>[<code>list</code>]<br>
A <code>list</code>, which stores additional control arguments.
For further information, see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>[any]<br>
Further arguments, e.g. handled by <code>optim</code> (within the
computation of the ELA local search features) or <code>density</code>
(within the computation of the ELA y-distribution features).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that if you want to speed up the runtime of the features, you might
consider running your feature computation parallelized. For more
information, please refer to the <code>parallelMap</code> package or to
<a href="https://mlr.mlr-org.com/articles/tutorial/parallelization.html">https://mlr.mlr-org.com/articles/tutorial/parallelization.html</a>.
</p>
<p>Furthermore, please consider adapting the feature computation to your
needs. Possible <code>control</code> arguments are:
</p>

<ul>
<li>
<p>general: </p>

<ul>
<li>
<p><code>show_progress</code>: Show progress bar when computing the
features? The default is <code>TRUE</code>.
</p>
</li>
<li>
<p><code>subset</code>: Specify a subset of features that should be
computed. Per default, all features will be computed.
</p>
</li>
<li>
<p><code>allow_cellmapping</code>: Should cell mapping features be
computed? The default is <code>TRUE</code>.
</p>
</li>
<li>
<p><code>allow_costs</code>: Should expensive features, i.e. features,
which require additional function evaluations, be computed? The
default is <code>TRUE</code> if the feature object provides a function,
otherwise <code>FALSE</code>.
</p>
</li>
<li>
<p><code>blacklist</code>: Which features should NOT be computed? The
default is <code>NULL</code>, i.e. none of the features will be excluded.
</p>
</li>
</ul>
</li>
<li>
<p>cell mapping angle features: </p>

<ul><li>
<p><code>cm_angle.show_warnings</code>: Should possible warnings about
<code>NAs</code> in the feature computation be shown? The default is
<code>FALSE</code>.
</p>
</li></ul>
</li>
<li>
<p>cell mapping convexity features: </p>

<ul>
<li>
<p><code>cm_conv.diag</code>: Should cells, which are located on the
diagonal compared to the current cell, be considered as neighbouring
cells? The default is <code>FALSE</code>, i.e. only cells along the axes
are considered as neighbours.
</p>
</li>
<li>
<p><code>cm_conv.dist_method</code>: Which distance method should be
used for computing the distance between two observations? All methods
of <code>dist</code> are possible options with <code>"euclidean"</code>
being the default.
</p>
</li>
<li>
<p><code>cm_conv.minkowski_p</code>: Value of <code>p</code> in case
<code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
the euclidean distance.
</p>
</li>
<li>
<p><code>cm_conv.fast_k</code>: Percentage of elements that should be
considered within the nearest neighbour computation. The default is
<code>0.05</code>.
</p>
</li>
</ul>
</li>
<li>
<p>cell mapping gradient homogeneity features: </p>

<ul>
<li>
<p><code>cm_grad.dist_tie_breaker</code>: How will ties be broken when
different observations have the same distance to an observation?
Possible values are <code>"sample"</code>, <code>"first"</code> and <code>"last"</code>.
The default is <code>"sample"</code>.
</p>
</li>
<li>
<p><code>cm_grad.dist_method</code>: Which distance method should be
used for computing the distance between two observations? All methods
of <code>dist</code> are possible options with <code>"euclidean"</code>
being the default.
</p>
</li>
<li>
<p><code>cm_grad.minkowski_p</code>: Value of <code>p</code> in case
<code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
the euclidean distance.
</p>
</li>
<li>
<p><code>cm_grad.show_warnings</code>: Should possible warnings about
(almost) empty cells be shown? The default is <code>FALSE</code>.
</p>
</li>
</ul>
</li>
<li>
<p>ELA convexity features: </p>

<ul>
<li>
<p><code>ela_conv.nsample</code>: Number of samples that are drawn for
calculating the convexity features. The default is <code>1000</code>.
</p>
</li>
<li>
<p><code>ela_conv.threshold</code>: Threshold of the linearity, i.e. the
tolerance to / deviation from perfect linearity, in order to still be
considered linear. The default is <code>1e-10</code>.
</p>
</li>
</ul>
</li>
<li>
<p>ELA curvature features: </p>

<ul>
<li>
<p><code>ela_curv.sample_size</code>: Number of samples used for
calculating the curvature features. The default is <code>100*d</code>.
</p>
</li>
<li>
<p><code>ela_curv.{delta, eps, zero_tol, r, v}</code>: Parameters used
by <code>grad</code> and <code>hessian</code> within the
approximation of the gradient and hessian. The default values are
identical to the ones from the corresponding functions. Note that we
slightly modified <code>hessian</code> in order to assure
that we do not exceed the boundaries during the estimation of the
Hessian.
</p>
</li>
</ul>
</li>
<li>
<p>ELA distribution features: </p>

<ul>
<li>
<p><code>ela_distr.smoothing_bandwidth</code>: The smoothing bandwidth,
which should be used within the <code>density</code> estimation.
The default is <code>"SJ"</code>.
</p>
</li>
<li>
<p><code>ela_distr.modemass_threshold</code>: Threshold that is used in
order to classify whether a minimum can be considered as a peak.
The default is <code>0.01</code>.
</p>
</li>
<li>
<p><code>ela_distr.skewness_type</code>: Algorithm type for computing
the <code>skewness</code>. The default is <code>3</code>.
</p>
</li>
<li>
<p><code>ela_distr.kurtosis_type</code>: Algorithm type for computing
the <code>kurtosis</code>. The default is <code>3</code>.
</p>
</li>
</ul>
</li>
<li>
<p>ELA levelset features: </p>

<ul>
<li>
<p><code>ela_level.quantiles</code>: Cutpoints (quantiles of the
objective values) for splitting the objective space. The default is
<code>c(0.10, 0.25, 0.50)</code>.
</p>
</li>
<li>
<p><code>ela_level.classif_methods</code>: Methods for classifying
the artificially splitted objective space. The default is
<code>c("lda", "qda", "mda")</code>.
</p>
</li>
<li>
<p><code>ela_level.resample_method</code>: Resample technique for
training the model, cf. <code>ResampleDesc</code>. The default
is <code>"CV"</code>.
</p>
</li>
<li>
<p><code>ela_level.resample_iterations</code>: Number of iterations
of the resampling method. The default is <code>10</code>.
</p>
</li>
<li>
<p><code>ela_level.resample_info</code>: Should information regarding
the resampling be printed? The default is <code>FALSE</code>.
</p>
</li>
<li>
<p><code>ela_level.parallelize</code>: Should the levelset features be
computed in parallel? The default is <code>FALSE</code>.
</p>
</li>
<li>
<p><code>ela_level.parallel.mode</code>: Which mode should be used for
the parallelized computation? Possible options are <code>"local"</code>,
<code>"multicore"</code>, <code>"socket"</code> (default), <code>"mpi"</code> and
<code>"BatchJobs"</code>. Note that in case you are using a windows computer
you can only use the <code>"socket"</code> mode.
</p>
</li>
<li>
<p><code>ela_level.parallel.cpus</code>: On how many cpus do you want to
compute the features in parallel? Per default, all available cpus are
used.
</p>
</li>
<li>
<p><code>ela_level.parallel.level</code>: On which level should the
parallel computation be performed? The default is
<code>"mlr.resample"</code>, i.e. the internal resampling (performed using
<code>mlr</code>) will be done in parallel.
</p>
</li>
<li>
<p><code>ela_level.parallel.logging</code>: Should slave output be
logged? The default is <code>FALSE</code>.
</p>
</li>
<li>
<p><code>ela_level.parallel.show_info</code>: Should verbose output of
function calls be printed on the console? The default is <code>FALSE</code>.
</p>
</li>
</ul>
</li>
<li>
<p>ELA local search features: </p>

<ul>
<li>
<p><code>ela_local.local_searches</code>: Number of local searches. The
default is <code>50 * d</code> with <code>d</code> being the number of features
(i.e. the dimension).
</p>
</li>
<li>
<p><code>ela_local.optim_method</code>: Local search algorithm. The
default is <code>"L-BFGS-B"</code>.
</p>
</li>
<li>
<p><code>ela_local.optim.{lower, upper}</code>: Lower and upper bounds
to be considered by the local search algorithm. Per default, the
boundaries are the same as defined within the feature object
(in case of <code>"L-BFGS-B"</code>) or infinity (for all others).
</p>
</li>
<li>
<p><code>ela_local.optim_method_control</code>: Control settings of the
local search algorithm. The default is an empty list.
</p>
</li>
<li>
<p><code>ela_local.sample_seed</code>: Seed, which will be set before
the selection of the initial start points of the local search. The
default is <code>sample(1:1e6, 1)</code>.
</p>
</li>
<li>
<p><code>ela_local.clust_method</code>: Once the local searches
converge, basins have to be assigned. This is done using hierarchical
clustering methods from <code>hclust</code>. The default is
<code>"single"</code>, i.e. <em>single linkage clustering</em>.
</p>
</li>
<li>
<p><code>ela_local.clust_cut_function</code>: A function of a
hierarchical clustering <code>cl</code>, which defines at which height the
dendrogramm should be splitted into clusters
(cf. <code>cutree</code>). The default is
<code>function(cl) as.numeric(quantile(cl$height, 0.1))</code>, i.e. the
<code>10%</code>-quantile of all the distances between clusters.
</p>
</li>
</ul>
</li>
<li>
<p>GCM features: </p>

<ul>
<li>
<p><code>gcm.approaches</code>: Which approach(es) should be used when
computing the representatives of a cell. The default are all three
approaches, i.e. <code>c("min", "mean", "near")</code>.
</p>
</li>
<li>
<p><code>gcm.cf_power</code>: Theoretically, we need to compute the
canonical form to the power of infinity. However, we use this value
as approximation of infinity. The default is <code>256</code>.
</p>
</li>
</ul>
</li>
<li>
<p>barrier tree features: </p>

<ul>
<li>
<p><code>gcm.approaches</code>: Which approach(es) should be used when
computing the representatives of a cell. The default are all three
approaches, i.e. <code>c("min", "mean", "near")</code>.
</p>
</li>
<li>
<p><code>gcm.cf_power</code>: Theoretically, we need to compute the
canonical form to the power of infinity. However, we use this value
as approximation of infinity. The default is <code>256</code>.
</p>
</li>
<li>
<p><code>bt.base</code>: Maximum number of basins, which are joined at a
single breakpoint. The default is <code>4L</code>.
</p>
</li>
<li>
<p><code>bt.max_depth</code>: Maximum number of levels of the barrier
tree. The default is <code>16L</code>.
</p>
</li>
</ul>
</li>
<li>
<p>information content features: </p>

<ul>
<li>
<p><code>ic.epsilon</code>: Epsilon values as described in section V.A
of Munoz et al. (2015). The default is
<code>c(0, 10^(seq(-5, 15, length.out = 1000))</code>.
</p>
</li>
<li>
<p><code>ic.sorting</code>: Sorting strategy, which is used to define
the tour through the landscape. Possible values are <code>"nn"</code>
(= default) and <code>"random"</code>.
</p>
</li>
<li>
<p><code>ic.sample.generate</code>: Should the initial design be created
using a LHS? The default is <code>FALSE</code>, i.e. the initial design from
the feature object will be used.
</p>
</li>
<li>
<p><code>ic.sample.dimensions</code>: Dimensions of the initial design,
if created using a LHS. The default is <code>feat.object$dimension</code>.
</p>
</li>
<li>
<p><code>ic.sample.size</code>: Size of the initial design, if created
using a LHS. The default is <code>100 * feat.object$dimension</code>.
</p>
</li>
<li>
<p><code>ic.sample.lower</code>: Lower bounds of the initial design, if
created with a LHS. The default is <code>100 * feat.object$lower</code>.
</p>
</li>
<li>
<p><code>ic.sample.upper</code>: Upper bounds of the initial design, if
created with a LHS. The default is <code>100 * feat.object$upper</code>.
</p>
</li>
<li>
<p><code>ic.aggregate_duplicated</code>: How should observations, which
have duplicates in the decision space, be aggregated? The default is
<code>mean</code>.
</p>
</li>
<li>
<p><code>ic.show_warnings</code>: Should warnings be shown, when
possible duplicates are removed? The default is <code>FALSE</code>.
</p>
</li>
<li>
<p><code>ic.seed</code>: Possible seed, which can be used for making
your experiments reproducable. Per default, a random number will be
drawn as seed.
</p>
</li>
<li>
<p><code>ic.nn.start</code>: Which observation should be used as
starting value, when exploring the landscape with the nearest
neighbour approach. The default is a randomly chosen integer value.
</p>
</li>
<li>
<p><code>ic.nn.neighborhood</code>: In order to provide a fast
computation of the features, we use <code>RANN::nn2</code> for computing
the nearest neighbors of an observation. Per default, we consider
the <code>20L</code> closest neighbors for finding the nearest
not-yet-visited observation. If all of those neighbors have been
visited already, we compute the distances to the remaining points
separately.
</p>
</li>
<li>
<p><code>ic.settling_sensitivity</code>: Threshold, which should be
used for computing the “settling sensitivity”. The default
is <code>0.05</code> (as used in the corresponding paper).
</p>
</li>
<li>
<p><code>ic.info_sensitivity</code>: Portion of partial information
sensitivity. The default is <code>0.5</code> (as used in the paper).
</p>
</li>
</ul>
</li>
<li>
<p>dispersion features: </p>

<ul>
<li>
<p><code>disp.quantiles</code>: Quantiles, which should be used for
defining the "best" elements of the entire initial design. The default
is <code>c(0.02, 0.05, 0.1, 0.25)</code>.
</p>
</li>
<li>
<p><code>disp.dist_method</code>: Which distance method should be
used for computing the distance between two observations? All methods
of <code>dist</code> are possible options with <code>"euclidean"</code>
being the default.
</p>
</li>
<li>
<p><code>disp.minkowski_p</code>: Value of <code>p</code> in case
<code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
the euclidean distance.
</p>
</li>
</ul>
</li>
<li>
<p>nearest better clustering features: </p>

<ul>
<li>
<p><code>nbc.dist_method</code>: Which distance method should be
used for computing the distance between two observations? All methods
of <code>dist</code> are possible options with <code>"euclidean"</code>
being the default.
</p>
</li>
<li>
<p><code>nbc.minkowski_p</code>: Value of <code>p</code> in case
<code>dist_meth</code> is <code>"minkowski"</code>. The default is <code>2</code>, i.e.
the euclidean distance.
</p>
</li>
<li>
<p><code>nbc.dist_tie_breaker</code>: How will ties be broken when
different observations have the same distance to an observation?
Possible values are <code>"sample"</code>, <code>"first"</code> and <code>"last"</code>.
The default is <code>"sample"</code>.
</p>
</li>
<li>
<p><code>nbc.cor_na</code>: How should NA's be handled when computing
correlations? Any method from the argument <code>use</code> of the function
<code>cor</code> is possible. The default is
<code>"pairwise.complete.obs"</code>.
</p>
</li>
<li>
<p><code>nbc.fast_k</code>: In case of euclidean distances, the method
can find neighbours faster. This parameter controls the percentage of
observations that should be considered when looking for the nearest
better neighbour, i.e. the nearest neighbour with a better objective
value. The default is <code>0.05</code>, i.e. the 5
</p>
</li>
</ul>
</li>
<li>
<p>principal component features: </p>

<ul><li>
<p><code>pca.{cov, cor}_{x, init}</code>: Which proportion of the
variance should be explained by the principal components given a
principal component analysis based on the covariance / correlation
matrix of the decision space (<code>x</code>) or the entire initial
design (<code>init</code>)? The defaults are <code>0.9</code>.
</p>
</li></ul>
</li>
</ul>
<h3>Value</h3>

<p><code>list</code> of (<code>numeric</code>) features:
</p>

<ul>
<li>
<p><code>cm_angle</code> – angle features (10):<br>
These features are based on the location of the worst and best element
within each cell. To be precise, their distance to the cell center and
the angle between these three elements (at the center) are the
foundation:
</p>

<ul>
<li>
<p><code>dist_ctr2{best, worst}.{mean, sd}</code>: arithmetic mean and
standard deviation of distances from the cell center to the best /
worst observation within the cell (over all cells)
</p>
</li>
<li>
<p><code>angle.{mean, sd}</code>: arithmetic mean and standard deviation
of angles (in degree) between worst, center and best element of a cell
(over all cells)
</p>
</li>
<li>
<p><code>y_ratio_best2worst.{mean, sd}</code>: arithmetic mean and
standard deviation of the ratios between the distance of the worst and
best element within a cell and the worst and best element in the
entire initial design (over all cells);<br>
note that the distances are only measured in the objective space
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>cm_conv</code> – cell mapping convexity features (6):<br>
Each cell will be represented by an observation (of the initial design),
which is located closest to the cell center. Then, the objectives of three
neighbouring cells are compared:<br></p>

<ul>
<li>
<p><code>{convex, concave}.hard</code>: if the objective of the inner
cell is above / below the two outer cells, there is strong evidence
for convexity / concavity
</p>
</li>
<li>
<p><code>{convex, concave}.soft</code>: if the objective of the inner
cell is above / below the arithmetic mean of the two outer cells,
there is weak evidence for convexity / concavity
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>cm_grad</code> – gradient homogeneity features (4):<br>
Within a cell of the initial grid, the gradients between each
observation and its nearest neighbour observation are computed. Those
gradients are then directed towards the smaller of the two objective
values and afterwards normalized. Then, the length of the sum of all the
directed and normalized gradients within a cell is computed. Based on
those measurements (one per cell) the following features are computed:<br></p>

<ul>
<li>
<p><code>{mean, sd}</code>: arithmetic mean and standard deviation of
the aforementioned lengths
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ela_conv</code> – ELA convexity features (6):<br>
Two observations are chosen randomly from the initial design. Then, a
linear (convex) combination of those observations is calculated – based
on a random weight from [0, 1]. The corresponding objective value will be
compared to the linear combination of the objectives from the two
original observations. This process is replicated <code>convex.nsample</code>
(per default <code>1000</code>) times and will then be aggregated:<br></p>

<ul>
<li>
<p><code>{convex_p, linear_p}</code>: percentage of convexity / linearity
</p>
</li>
<li>
<p><code>linear_dev.{orig, abs}</code>: average (original / absolute)
deviation between the linear combination of the objectives and the
objective of the linear combination of the observations
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ela_curv</code> – ELA curvature features (26):<br>
Given a feature object, <code>curv.sample_size</code> samples (per default
<code>100 * d</code> with <code>d</code> being the number of features) are randomly
chosen. Then, the gradient and hessian of the function are estimated
based on those points and the following features are computed:<br></p>

<ul>
<li>
<p><code>grad_norm.{min, lq, mean, median, uq, max, sd, nas}</code>:
aggregations (minimum, lower quartile, arithmetic mean, median, upper
quartile, maximum, standard deviation and percentage of NAs) of the
gradients' lengths
</p>
</li>
<li>
<p><code>grad_scale.{min, lq, mean, median, uq, max, sd, nas}</code>:
aggregations of the ratios between biggest and smallest (absolute)
gradient directions
</p>
</li>
<li>
<p><code>hessian_cond.{min, lq, mean, median, uq, max, sd, nas}</code>:
aggregations of the ratios of biggest and smallest eigenvalue of the
hessian matrices
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ela_distr</code> – ELA y-distribution features (5):<br></p>

<ul>
<li>
<p><code>skewness</code>: skewness of the objective values
</p>
</li>
<li>
<p><code>kurtosis</code>: kurtosis of the objective values
</p>
</li>
<li>
<p><code>number_of_peaks</code>: number of peaks based on an estimation
of the density of the objective values
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ela_level</code> – ELA levelset features (20):<br></p>

<ul>
<li>
<p><code>mmce_{methods}_{quantiles}</code>: mean misclassification error
of each pair of classification method and quantile
</p>
</li>
<li>
<p><code>{method1}_{method2}_{quantiles}</code>: ratio of all pairs of
classification methods for all quantiles
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ela_local</code> – ELA local search features (16):<br>
Based on some randomly chosen points from the initial design, a
pre-defined number of local searches (<code>ela_local.local_searches</code>)
are executed. Their optima are then clustered (using hierarchical
clustering), assuming that local optima that are located close to each
other, likely belong to the same basin. Given those basins, the
following features are computed:<br></p>

<ul>
<li>
<p><code>n_loc_opt.{abs, rel}</code>: the absolute / relative amount of
local optima
</p>
</li>
<li>
<p><code>best2mean_contr.orig</code>: each cluster is represented by its
center; this feature is the ratio of the objective values of the best
and average cluster
</p>
</li>
<li>
<p><code>best2mean_contr.ratio</code>: each cluster is represented by its
center; this feature is the ratio of the differences in the objective
values of average to best and worst to best cluster
</p>
</li>
<li>
<p><code>basin_sizes.avg_{best, non_best, worst}</code>: average basin
size of the best / non-best / worst cluster(s)
</p>
</li>
<li>
<p><code>fun_evals.{min, lq, mean, median, uq, max, sd}</code>:
aggregations of the performed local searches
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ela_meta</code> – ELA meta model features (11):<br>
Given an initial design, linear and quadratic models of the form
<code>objective ~ features</code> are created. Both versions are created
with and without simple interactions (e.g., <code>x1:x2</code>). Based on
those models, the following features are computed:<br></p>

<ul>
<li>
<p><code>lin_simple.{adj_r2, intercept}</code>: adjusted R^2 (i.e. model
fit) and intercept of a simple linear model
</p>
</li>
<li>
<p><code>lin_simple.coef.{min, max, max_by_min}</code>: smallest and
biggest (non-intercept) absolute coefficients of the simple linear
model, and their ratio
</p>
</li>
<li>
<p><code>{lin_w_interact, quad_simple, quad_w_interact}.adj_r2</code>:
adjusted R^2 (i.e. the model fit) of a linear model with interactions,
and a quadratic model with and without interactions
</p>
</li>
<li>
<p><code>quad_simple.cond</code>: condition of a simple quadratic model
(without interactions), i.e. the ratio of its (absolute) biggest and
smallest coefficients
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>gcm</code> – general cell mapping (GCM) features (75):<br>
Computes general cell mapping features based on the Generalized Cell
Mapping (GCM) approach, which interpretes the cells as absorbing Markov
chains. Computations are performed based on three different approaches:
taking the best (<code>min</code>) or average (<code>mean</code>) objective value of
a cell or the closest observation (<code>near</code>) to a cell as
representative. For each of these approaches the following 25 features
are computed:<br></p>

<ul>
<li>
<p><code>attractors, pcells, tcells, uncertain</code>: relative amount
of attractor, periodic, transient and uncertain cells
</p>
</li>
<li>
<p><code>basin_prob.{min, mean, median, max, sd}</code>: aggregations
of the probabilities of each basin of attraction
</p>
</li>
<li>
<p><code>basin_certain.{min, mean, median, max, sd}</code>: aggregations
of the (relative) size of each basin of attraction, in case only
certain cells are considered (i.e. cells, which only point towards one
attractor)
</p>
</li>
<li>
<p><code>basin_uncertain.{min, mean, median, max, sd}</code>:
aggregations of the (relative) size of each basin of attraction, in
case uncertain cells are considered (i.e. a cell, which points to
multiple attractors contributes to each of its basins)
</p>
</li>
<li>
<p><code>best_attr.{prob, no}</code>: probability of finding the
attractor with the best objective value and the (relative) amount of
those attractors (i.e. the ratio of the number of attractors with the
best objective value and the total amount of cells)
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>bt</code> – barrier tree features (90):<br>
Computes barrier tree features, based on a Generalized Cell Mapping
(GCM) approach. Computations are performed based on three different
approaches: taking the best (<code>min</code>) or average (<code>mean</code>)
objective value of a cell or the closest observation (<code>near</code>) to a
cell as representative. For each of these approaches the following 31
features are computed:<br></p>

<ul>
<li>
<p><code>levels</code>: absolute number of levels of the barrier tree
</p>
</li>
<li>
<p><code>leaves</code>: absolute number of leaves (i.e. local optima)
of the barrier tree
</p>
</li>
<li>
<p><code>depth</code>: range between highest and lowest node of the tree
</p>
</li>
<li>
<p><code>depth_levels_ratio</code>: ratio of depth and levels
</p>
</li>
<li>
<p><code>levels_nodes_ratio</code>: ratio of number of levels and number
of (non-root) nodes of the tree
</p>
</li>
<li>
<p><code>diffs.{min, mean, median, max, sd}</code>:
aggregations of the height differences between a node and its
predecessor
</p>
</li>
<li>
<p><code>level_diffs.{min, mean, median, max, sd}</code>:
aggregations of the average height differences per level
</p>
</li>
<li>
<p><code>attractor_dists.{min, mean, median, max, sd}</code>:
aggregations of the (euclidean) distances between the local and global
best cells (attractors)
</p>
</li>
<li>
<p><code>basin_ratio.{uncertain, certain, most_likely}</code>:
ratios of maximum and minimum size of the basins of attractions; here,
a cell might belong to different attractors (uncertain), exactly one
attractor (certain) or the attractor with the highest probability
</p>
</li>
<li>
<p><code>basin_intersection.{min, mean, median, max, sd}</code>:
aggregations of the intersection between the basin of the global best
value and the basins of all local best values
</p>
</li>
<li>
<p><code>basin_range</code>:
range of a basin (euclidean distance of widest range per dimension)
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>ic</code> – information content features (7):<br>
Computes features based on the Information Content of Fitness Sequences
(ICoFiS) approach (cf. Munoz et al., 2015). In this approach, the
information content of a continuous landscape, i.e. smoothness,
ruggedness, or neutrality, are quantified. While common analysis methods
were able to calculate the information content of discrete landscapes,
the ICoFiS approach provides an adaptation to continuous landscapes that
accounts e.g. for variable step sizes in random walk sampling:<br></p>

<ul>
<li>
<p><code>h.max</code>: “maximum information content” (entropy) of
the fitness sequence, cf. equation (5)
</p>
</li>
<li>
<p><code>eps.s</code>: “settling sensitivity”, indicating the
epsilon for which the sequence nearly consists of zeros only, cf.
equation (6)
</p>
</li>
<li>
<p><code>eps.max</code>: similar to <code>eps.s</code>, but in contrast to the
former <code>eps.max</code> guarantees non-missing values; this simply is the
epsilon-value for which H(<code>eps.max</code>) == <code>h.max</code>
</p>
</li>
<li>
<p><code>eps.ratio</code>: “ratio of partial information
sensitivity”, cf. equation (8), where the ratio is <code>0.5</code>
</p>
</li>
<li>
<p><code>m0</code>: “initial partial information”, cf. equation
(7)
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>basic</code> – basic features (15):<br>
Very simple features, which can be read from the feature object (without
any computational efforts):<br></p>

<ul>
<li>
<p><code>{dim, observations}</code>: number of features / dimensions and
observations within the initial sample
</p>
</li>
<li>
<p><code>{lower, upper, objective, blocks}_{min, max}</code>: minimum
and maximum value of all lower and upper bounds, the objective values
and the number of blocks / cells (per dimension)
</p>
</li>
<li>
<p><code>cells_{filled, total}</code>: number of filled (i.e. non-empty)
cells and total number of cells
</p>
</li>
<li>
<p><code>{minimize_fun}</code>: logical value, indicating
whether the optimization function should be minimized
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>disp</code> – dispersion features (18):<br>
Computes features based on the comparison of the dispersion of pairwise
distances among the 'best' elements and the entire initial design:<br></p>

<ul>
<li>
<p><code>{ratio, diff}_{mean, median}_{02, 05, 10, 25}</code>: ratio
and difference of the mean / median distances of the distances of the
'best' objectives vs. 'all' objectives
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>limo</code> – linear model features (14):<br>
Linear models are computed per cell, provided the decision space is
divided into a grid of cells. Each one of the models has the form
<code>objective ~ features</code>.<br></p>

<ul>
<li>
<p><code>avg_length.{reg, norm}</code>: length of the average
coefficient vector (based on regular and normalized vectors)
</p>
</li>
<li>
<p><code>length_{mean, sd}</code>: arithmetic mean and standard
deviation of the lengths of all coefficient vectors
</p>
</li>
<li>
<p><code>cor.{reg, norm}</code>: correlation of all coefficient vectors
(based on regular and normalized vectors)
</p>
</li>
<li>
<p><code>ratio_{mean, sd}</code>: arithmetic mean and standard deviation
of the ratios of (absolute) maximum and minimum (non-intercept)
coefficients per cell
</p>
</li>
<li>
<p><code>sd_{ratio, mean}.{reg, norm}</code>: max-by-min-ratio and
arithmetic mean of the standard deviations of the (non-intercept)
coefficients (based on regular and normalized vectors)
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>nbc</code> – nearest better (clustering) features (7):<br>
Computes features based on the comparison of nearest neighbour and
nearest better neighbour, i.e., the nearest neighbor with a better
performance / objective value value.<br></p>

<ul>
<li>
<p><code>nn_nb.{sd, mean}_ratio</code>: ratio of standard deviations and
arithmetic mean based on the distances among the nearest neighbours
and the nearest better neighbours
</p>
</li>
<li>
<p><code>nn_nb.cor</code>: correlation between distances of the nearest
neighbours and the distances of the nearest better neighbours
</p>
</li>
<li>
<p><code>dist_ratio.coeff_var</code>: coefficient of variation of the
distance ratios
</p>
</li>
<li>
<p><code>nb_fitness.cor</code>: correlation between fitness value and
count of observations to whom the current observation is the nearest
better neighbour (the so-called “indegree”).
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
<li>
<p><code>pca</code> – principal component (analysis) features (10):<br></p>

<ul>
<li>
<p><code>expl_var.{cov, cor}_{x, init}</code>: proportion of the
explained variance when applying PCA to the covariance / correlation
matrix of the decision space (<code>x</code>) or the entire initial design
(<code>init</code>)
</p>
</li>
<li>
<p><code>expl_var_PC1.{cov, cor}_{x, init}</code>: proportion of
variance, which is explained by the first principal component – when
applying PCA to the covariance / correlation matrix of the decision
space (<code>x</code>) or the entire initial design
</p>
</li>
<li>
<p><code>costs_{fun_evals, runtime}</code>: number of (additional)
function evaluations and runtime (in seconds), which were needed for
the computation of these features
</p>
</li>
</ul>
</li>
</ul>
<h3>References</h3>


<ul>
<li>
<p>Kerschke, P., and Trautmann, H. (2019):
“Comprehensive Feature-Based Landscape Analysis of Continuous
and Constrained Optimization Problems Using the R-package flacco”,
in: Applications in Statistical Computing – From Music Data Analysis
to Industrial Quality Improvement, pp. 93-123, Springer.
(<a href="https://link.springer.com/chapter/10.1007/978-3-030-25147-5_7">https://link.springer.com/chapter/10.1007/978-3-030-25147-5_7</a>).
</p>
</li>
<li>
<p>Kerschke, P., Preuss, M., Hernandez, C., Schuetze, O., Sun, J.-Q.,
Grimme, C., Rudolph, G., Bischl, B., and Trautmann, H. (2014):
“Cell Mapping Techniques for Exploratory Landscape Analysis”,
in: EVOLVE – A Bridge between Probability, Set Oriented Numerics, and
Evolutionary Computation V, pp. 115-131
(<a href="http://dx.doi.org/10.1007/978-3-319-07494-8_9">http://dx.doi.org/10.1007/978-3-319-07494-8_9</a>).
</p>
</li>
<li>
<p>Kerschke, P., Preuss, M., Wessing, S., and Trautmann, H. (2015):
“Detecting Funnel Structures by Means of Exploratory Landscape
Analysis”, in: Proceedings of the 17th Annual Conference on Genetic and
Evolutionary Computation (GECCO '15), pp. 265-272
(<a href="http://dx.doi.org/10.1145/2739480.2754642">http://dx.doi.org/10.1145/2739480.2754642</a>).
</p>
</li>
<li>
<p>Lunacek, M., and Whitley, D. (2006):
“The dispersion metric and the CMA evolution strategy”, in:
Proceedings of the 8th Annual Conference on Genetic and Evolutionary
Computation (GECCO '06), pp. 477-484
(<a href="http://dx.doi.org/10.1145/1143997.1144085">http://dx.doi.org/10.1145/1143997.1144085</a>).
</p>
</li>
<li>
<p>Mersmann, O., Bischl, B., Trautmann, H., Preuss, M., Weihs, C.,
and Rudolph, G. (2011): “Exploratory Landscape Analysis”, in:
Proceedings of the 13th Annual Conference on Genetic and Evolutionary
Computation (GECCO '11), pp. 829-836
(<a href="http://dx.doi.org/10.1145/2001576.2001690">http://dx.doi.org/10.1145/2001576.2001690</a>).
</p>
</li>
<li>
<p>Munoz, M. A., Kirley, M., and Halgamuge, S. K. (2015):
“Exploratory Landscape Analysis of Continuous Space Optimization
Problems Using Information Content”, in: IEEE Transactions on
Evolutionary Computation (19:1), pp. 74-87
(<a href="http://dx.doi.org/10.1109/TEVC.2014.2302006">http://dx.doi.org/10.1109/TEVC.2014.2302006</a>).
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># (1) create a feature object:
X = t(replicate(n = 2000, expr = runif(n = 5, min = -10, max = 10)))
## Not run: feat.object = createFeatureObject(X = X, fun = function(x) sum(x^2))

# (2) compute all non-cellmapping features
ctrl = list(allow_cellmapping = FALSE)
## Not run: features = calculateFeatures(feat.object, control = ctrl)

# (3) in order to allow the computation of the cell mapping features, one
# has to provide a feature object that has knowledge about the number of
# cells per dimension:
f = function(x) sum(x^2)
feat.object = createFeatureObject(X = X, fun = f, blocks = 3)
## Not run: features = calculateFeatures(feat.object)

# (4) if you want to compute a specific feature set, you can use
# calculateFeatureSet:
features.angle = calculateFeatureSet(feat.object, "cm_angle")

# (5) as noted in the details, it might be useful to compute the levelset
# features parallelized:
## Not run: 
library(parallelMap)
library(parallel)
n.cores = detectCores()
parallelStart(mode = "socket", cpus = n.cores,
  logging = FALSE, show.info = FALSE)
system.time((levelset.par = calculateFeatureSet(feat.object, "ela_level")))
parallelStop()
system.time((levelset.seq = calculateFeatureSet(feat.object, "ela_level")))
## End(Not run)

</code></pre>


</div>