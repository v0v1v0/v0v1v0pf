<div class="container">

<table style="width: 100%;"><tr>
<td>Fuzzy_DBScan</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fuzzy DBScan</h2>

<h3>Description</h3>

<p>This object implements fuzzy DBScan with both, fuzzy cores and fuzzy borders.
Additionally, it provides a predict function.
</p>


<h3>Details</h3>

<p>A method to initialize and run the algorithm and a function
to predict new data.
The package is build upon the paper
"Fuzzy Extensions of the DBScan algorithm" from Ienco and Bordogna.
The predict function assigns new data based on the same criteria as the
algorithm itself.
However, the prediction function freezes the algorithm to preserve the
trained cluster structure and treats each new prediction object individually.
Note, that border points are included to the cluster.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dta</code></dt>
<dd>
<p>data.frame | matrix<br>
The data to be clustered by the algorithm. Allowed
are only numeric columns.</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>numeric<br>
The size (radius) of the epsilon neighborhood.
If  the radius contains 2 numbers, the fuzzy cores
are calculated between the minimum and the maximum
radius.
If epsilon is a single number, the algorithm
looses the fuzzy core property. If the length of
<code>pts</code> is also 1L, the algorithm equals to non-fuzzy
DBScan.</p>
</dd>
<dt><code>pts</code></dt>
<dd>
<p>numeric<br>
number of maximum and minimum points required in the
<code>eps</code>  neighborhood for core points (excluding the
point itself). If the length of the argument is 1,
the algorithm looses its fuzzy border property. If
the length of <code>eps</code> is also 1L, the algorithm equals
to non-fuzzy DBScan.</p>
</dd>
<dt><code>clusters</code></dt>
<dd>
<p>factor<br>
Contains the assigned clusters per observation in
the same order as in <code>dta</code>.</p>
</dd>
<dt><code>dense</code></dt>
<dd>
<p>numeric<br>
Contains the assigned density estimates per
observation in the same order as in <code>dta</code>.</p>
</dd>
<dt><code>point_def</code></dt>
<dd>
<p>character<br>
Contains the assigned definition estimates per
observation in the same order as in <code>dta</code>. Possible
are "Core Point", "Border Point" and "Noise".</p>
</dd>
<dt><code>results</code></dt>
<dd>
<p>data.table<br>
A table where each column indicates for the
probability of the new data to belong to a
respective cluster.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FuzzyDBScan-new"><code>FuzzyDBScan$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FuzzyDBScan-predict"><code>FuzzyDBScan$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-FuzzyDBScan-plot"><code>FuzzyDBScan$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-FuzzyDBScan-clone"><code>FuzzyDBScan$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-FuzzyDBScan-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a FuzzyDBScan object. Apply the
fuzzy DBScan algorithm given the data <code>dta</code>, the
range of the radius <code>eps</code> and the range of the
Points <code>pts</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzyDBScan$new(dta, eps, pts)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dta</code></dt>
<dd>
<p>data.frame | matrix<br>
The data to be clustered by the algorithm. Allowed
are only numeric columns.</p>
</dd>
<dt><code>eps</code></dt>
<dd>
<p>numeric<br>
The size (radius) of the epsilon neighborhood.
If  the radius contains 2 numbers, the fuzzy cores
are calculated between the minimum and the maximum
radius.
If epsilon is a single number, the algorithm
looses the fuzzy core property. If the length of
<code>pts</code> is also 1L, the algorithm equals to non-fuzzy
DBScan.</p>
</dd>
<dt><code>pts</code></dt>
<dd>
<p>numeric<br>
number of maximum and minimum points required in the
<code>eps</code>  neighborhood for core points (excluding the
point itself). If the length of the argument is 1,
the algorithm looses its fuzzy border property. If
the length of <code>eps</code> is also 1L, the algorithm equals
to non-fuzzy DBScan.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-FuzzyDBScan-predict"></a>



<h4>Method <code>predict()</code>
</h4>

<p>Predict new data with the initialized
algorithm.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzyDBScan$predict(new_data, cmatrix = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_data</code></dt>
<dd>
<p>data.frame | matrix<br>
The data to be predicted by the algorithm. Allowed
are only numeric columns which should match to
<code>self$dta</code>.</p>
</dd>
<dt><code>cmatrix</code></dt>
<dd>
<p>logical<br>
Indicating whether the assigned cluster should be
returned in form of a matrix where each column
indicates for the probability of the new data to
belong to a respective cluster. The object will have
the same shape as the <code>results</code> field. If set to
<code>FALSE</code> the shape of the returned assigned clusters
is a two-column data.table with one column
indicating the assigned cluster and the second
column indicating the respective probability of
the new data.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-FuzzyDBScan-plot"></a>



<h4>Method <code>plot()</code>
</h4>

<p>Plot clusters and soft labels on two
features.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzyDBScan$plot(x, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt>
<dd>
<p>character<br>
Feature to plot on the x-axis.</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>character<br>
Feature to plot on the y-axis.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-FuzzyDBScan-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FuzzyDBScan$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p>Ienco, Dino, and Gloria Bordogna.
Fuzzy extensions of the DBScan clustering algorithm.
Soft Computing 22.5 (2018): 1719-1730.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load factoextra for data and ggplot for plotting
library(factoextra)
dta = multishapes[, 1:2]
eps = c(0, 0.2)
pts = c(3, 15)
# train DBScan based on data, ep and pts
cl = FuzzyDBScan$new(dta, eps, pts)
# Plot DBScan for x and y
library(ggplot2)
cl$plot("x", "y")
# produce test data
x &lt;- seq(min(dta$x), max(dta$x), length.out = 50)
y &lt;- seq(min(dta$y), max(dta$y), length.out = 50)
p_dta = expand.grid(x = x, y = y)
# predict on test data and plot results
p = cl$predict(p_dta, FALSE)
ggplot(p, aes(x = p_dta[, 1], y = p_dta[, 2], colour = as.factor(cluster))) +
  geom_point(alpha = p$dense)
</code></pre>


</div>