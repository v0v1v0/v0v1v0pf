<div class="container">

<table style="width: 100%;"><tr>
<td>NonLinStatistics</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Chaotic Time Series Statistics</h2>

<h3>Description</h3>

<p>A collection and description of functions to 
investigate the chaotic behavior of time series 
processes. 
<br></p>
<p>Functions to Analyse Chaotic Time Series:
</p>

<table>
<tr>
<td style="text-align: left;">
    <code>mutualPlot</code> </td>
<td style="text-align: left;"> Returns mutual information, </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>falsennPlot</code> </td>
<td style="text-align: left;"> returns false nearest neigbours, </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>recurrencePlot</code> </td>
<td style="text-align: left;"> returns a recurrence plot, </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>separationPlot</code> </td>
<td style="text-align: left;"> returns a space-time separation plot, </td>
</tr>
<tr>
<td style="text-align: left;">
    <code>lyapunovPlot</code> </td>
<td style="text-align: left;"> computes maximum lyapunov exponent. </td>
</tr>
</table>
<h3>Usage</h3>

<pre><code class="language-R">   
mutualPlot(x, partitions = 16, lag.max = 20, doplot = TRUE, ...)  
falsennPlot(x, m, d, t, rt = 10, eps = NULL, doplot = TRUE, ...) 
recurrencePlot(x, m, d, end.time, eps, nt = 10, doplot = TRUE, ...)
separationPlot(x, m, d, mdt, idt = 1, doplot = TRUE, ...)
lyapunovPlot(x, m, d, t, ref, s, eps, k = 1, doplot = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>

<p>an integer value setting the value of the time delay.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>[falsennPlot] - <br>
a numeric value setting the value of the neighbour diameter.
If NULL, which is the default value, then the value will be
automatically setted to <code>eps=sd(x)/10</code>.
<br>
[lyapunovPlot] - <br>
the radius where to find nearest neighbours.
<br>
[recurrencePlot] - <br>
the neighbourhood threshold.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>doplot</code></td>
<td>

<p>a logical flag. Should a plot be displayed?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end.time</code></td>
<td>

<p>[recurrencePlot] - <br>
ending time as number of observations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>idt</code></td>
<td>

<p>[separationPlot] - <br>
an integer value setting the number of observation steps in
each iterations. By default 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>[lyapunovPlot] - <br>
an integer setting th enumber of considered neighbours.
By default 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lag.max</code></td>
<td>

<p>[mutualPlot] - <br>
an integer value setting the number of maximum lags, by 
default 20.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>[*Plot] - <br>
an integer value setting the value of the maximum embedding 
dimension.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mdt</code></td>
<td>

<p>[separationPlot] - <br>
an integer value setting the number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nt</code></td>
<td>

<p>[recurrencePlot] - <br>
observations in each step which will be plotted, by default 10.
Increasing <code>nt</code> reduces number of points plotted which
is usefule especially with highly sampled data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rt</code></td>
<td>

<p>[falsennPlot] - <br>
an integer value setting the value for the escape factor. By
default 10.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partitions</code></td>
<td>

<p>[mutualPlot] - <br>
an integer value setting the number of bins, by default 16.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref</code></td>
<td>

<p>[lyapunovPlot] - <br>
the number of points to take into account.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
 
<p>[lyapunovPlot] - <br>
the iterations along which follow the neighbours of each point.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>

<p>[*Plot] - <br>
an integer value setting the value for the Theiler window.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>[*Plot] - <br>
a numeric vector, or an object either of class 'ts' or
of class 'timeSeries'.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>arguments to be passed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><b>Phase Space Representation:</b>
<br><br>  
The function <code>mutualPlot</code> estimates and plots the mutual 
information index of a given time series for a specified number 
of lags. The joint probability distribution function is estimated 
with a simple bi-dimensional density histogram.
<br> 
The function <code>falsennPlot</code> uses the Method of false nearest 
neighbours to help deciding the optimal embedding dimension.
<br></p>
<p><b>Non-Stationarity:</b>
<br><br>
The funcdtion <code>recurrencePlot</code> creates a recurrence plot as 
proposed by Eckmann et al. [1987]. 
<br>
The function <code>separationPlot</code> creates a space-time separation
plot qs introduced by Provenzale et al. [1992]. It plots the 
probability that two points in the reconstructed phase-space have 
distance smaller than epsilon in function of epsilon and of the 
time between the points, as iso-lines at levels 10, 20, ..., 100
percent levels. The plot can be used to decide the Theiler time 
window.
<br></p>
<p><b>Lyapunov Exponents:</b>
<br><br>
The function <code>lyapunovPlot</code> evaluates and plots the largest 
Lyapunov exponent of a dynamic system from a univariate time series.
The estimate of the Lyapunov exponent uses the algorithm of Kantz.
In addition, the function computes the regression coefficients of 
a user specified segment of the sequence given as input. 
<br></p>
<p><b>Dimensions and Entropies:</b>
<br><br>
The function <code>C2</code> computes the sample correlation integral on 
the provided time series for the specified length scale and 
Theiler window. It uses a naiv algorithm: simply returns the 
fraction of points pairs nearer than eps. It is prefarable to use 
the function <code>d2</code>, which takes roughly the same time, but 
computes the correlation sum for multiple length scales and 
embedding dimensions at once.
<br>
The function <code>d2</code> computes the sample correlation integral 
over given length scales <code>neps</code> for embedding dimensions 
<code>1:m</code> for a given Theiler window. The slope of the linear 
segment in the log-log plot gives an estimate of the correlation 
dimension.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Brock, W.A., Dechert W.D., Sheinkman J.A. (1987); 
<em>A Test of Independence Based on the Correlation 
Dimension</em>, 
SSRI no. 8702, Department of Economics, University of 
Wisconsin, Madison.
</p>
<p>Eckmann J.P., Oliffson Kamphorst S., Ruelle D. (1987), 
<em>Recurrence plots of dynamical systems</em>, 
Europhys. Letters 4, 973.
</p>
<p>Hegger R., Kantz H., Schreiber T. (1999);
<em>Practical implementation of nonlinear time series 
methods: The TISEAN package</em>,
CHAOS 9, 413â€“435.
</p>
<p>Kennel M.B., Brown R., Abarbanel H.D.I. (1992); 
<em>Determining embedding dimension for phase-space 
reconstruction using a geometrical construction</em>, 
Phys. Rev. A45, 3403. 
</p>
<p>Rosenstein M.T., Collins J.J., De Luca C.J. (1993);
<em>A practical method for calculating largest Lyapunov 
exponents from small data sets</em>, 
Physica D 65, 117.
</p>


<h3>See Also</h3>

<p><code>RandomInnovations</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## mutualPlot -
   mutualPlot(logisticSim(1000))
   
## recurrencePlot -
   lorentz = lorentzSim(
     times = seq(0, 40, by = 0.01), 
     parms = c(sigma = 16, r = 45.92, b = 4), 
     start = c(-14, -13, 47), 
     doplot = FALSE) 
   recurrencePlot(lorentz[, 2], m = 3, d = 2, end.time = 800, eps = 3, 
     nt = 5, pch = '.', cex = 2)
</code></pre>


</div>