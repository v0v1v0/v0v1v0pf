<div class="container">

<table style="width: 100%;"><tr>
<td>mmsbm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create an undirected degree-corrected mixed membership stochastic blockmodel object</h2>

<h3>Description</h3>

<p>To specify a degree-corrected mixed membership stochastic blockmodel, you must specify
the degree-heterogeneity parameters (via <code>n</code> or <code>theta</code>),
the mixing matrix (via <code>k</code> or <code>B</code>), and the relative block
propensities (optional, via <code>alpha</code>). We provide defaults for most of these
options to enable rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mmsbm(
  n = NULL,
  theta = NULL,
  k = NULL,
  B = NULL,
  ...,
  alpha = rep(1, k),
  sort_nodes = TRUE,
  force_pure = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>(degree heterogeneity) The number of nodes in the blockmodel.
Use when you don't want to specify the degree-heterogeneity
parameters <code>theta</code> by hand. When <code>n</code> is specified, <code>theta</code>
is randomly generated from a <code>LogNormal(2, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>n</code> defaults to <code>NULL</code>. You must specify either <code>n</code>
or <code>theta</code>, but not both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>(degree heterogeneity) A numeric vector
explicitly specifying the degree heterogeneity
parameters. This implicitly determines the number of nodes
in the resulting graph, i.e. it will have <code>length(theta)</code> nodes.
Must be positive. Setting to a vector of ones recovers
a stochastic blockmodel without degree correction.
Defaults to <code>NULL</code>. You must specify either <code>n</code> or <code>theta</code>,
but not both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>(mixing matrix) The number of blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k</code> is specified, the elements of <code>B</code> are drawn
randomly from a <code>Uniform(0, 1)</code> distribution.
This is subject to change, and may not be reproducible.
<code>k</code> defaults to <code>NULL</code>. You must specify either <code>k</code>
or <code>B</code>, but not both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>(mixing matrix) A <code>k</code> by <code>k</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>. Must be
a square matrix. <code>matrix</code> and <code>Matrix</code> objects are both
acceptable. If <code>B</code> is not symmetric, it will be
symmetrized via the update <code>B := B + t(B)</code>. Defaults to <code>NULL</code>.
You must specify either <code>k</code> or <code>B</code>, but not both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>undirected_factor_model</code>
</p>

<dl>
<dt><code>expected_degree</code></dt>
<dd>
<p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt>
<dd>
<p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(relative block propensities) Relative block
propensities, which are parameters of a Dirichlet distribution.
All elments of <code>alpha</code> must thus be positive.
Must match the dimensions of <code>B</code> or <code>k</code>. Defaults to
<code>rep(1, k)</code>, or balanced membership across blocks.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block and by <code>theta</code>. Useful for plotting.
Defaults to <code>TRUE</code>. When <code>TRUE</code>, nodes are first sorted by block
membership, and then by degree-correction parameters within each block.
Additionally, <code>pi</code> is sorted in increasing order, and the columns
of the <code>B</code> matrix are permuted to match the new order of <code>pi</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_pure</code></td>
<td>
<p>Logical indicating whether or not to force presence of
"pure nodes" (nodes that belong only to a single community) for the sake
of identifiability. To include pure nodes, block membership sampling
first proceeds as per usual. Then, after it is complete, <code>k</code> nodes
are chosen randomly as pure nodes, one for each block. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>undirected_mmsbm</code> S3 object, a subclass of the
<code>undirected_factor_model()</code> with the following additional
fields:
</p>

<ul>
<li> <p><code>theta</code>: A numeric vector of degree-heterogeneity parameters.
</p>
</li>
<li> <p><code>Z</code>: The community memberships of each node, a <code>matrix()</code> with
<code>k</code> columns, whose row sums all equal one.
</p>
</li>
<li> <p><code>alpha</code>: Community membership proportion propensities.
</p>
</li>
<li> <p><code>sorted</code>: Logical indicating where nodes are arranged by
block (and additionally by degree heterogeneity parameter)
within each block.
</p>
</li>
</ul>
<h3>Generative Model</h3>

<p>There are two levels of randomness in a degree-corrected
stochastic blockmodel. First, we randomly choose how much
each node belongs to each block in the blockmodel. Each node
is one unit of block membership to distribute. This is
handled by <code>mmsbm()</code>. Then, given these block memberships,
we randomly sample edges between nodes. This second
operation is handled by <code>sample_edgelist()</code>,
<code>sample_sparse()</code>, <code>sample_igraph()</code> and
<code>sample_tidygraph()</code>, depending depending on your desired
graph representation.
</p>


<h4>Block memberships</h4>

<p>Let <code class="reqn">Z_i</code> by a vector on the <code>k</code> dimensional simplex
representing the block memberships of node <code class="reqn">i</code>.
To generate <code class="reqn">z_i</code> we sample from a Dirichlet
distribution with parameter vector <code class="reqn">\alpha</code>.
Block memberships for each node are independent.
</p>



<h4>Degree heterogeneity</h4>

<p>In addition to block membership, the MMSBM also allows
nodes to have different propensities for edge formation.
We represent this propensity for node <code class="reqn">i</code> by a positive
number <code class="reqn">\theta_i</code>.
</p>



<h4>Edge formulation</h4>

<p>Once we know the block membership vector <code class="reqn">z_i, z_j</code> and the degree
heterogeneity parameters <code class="reqn">\theta</code>, we need one more
ingredient, which is the baseline intensity of connections
between nodes in block <code>i</code> and block <code>j</code>. This is given by a
<code class="reqn">k \times k</code> matrix <code class="reqn">B</code>. Then each edge
<code class="reqn">A_{i,j}</code> is Poisson distributed with parameter
</p>
<p style="text-align: center;"><code class="reqn">
  \lambda_{i, j} = \theta_i \cdot z_i^T  B z_j \cdot \theta_j.
</code>
</p>




<h3>See Also</h3>

<p>Other stochastic block models: 
<code>dcsbm()</code>,
<code>directed_dcsbm()</code>,
<code>overlapping_sbm()</code>,
<code>planted_partition()</code>,
<code>sbm()</code>
</p>
<p>Other undirected graphs: 
<code>chung_lu()</code>,
<code>dcsbm()</code>,
<code>erdos_renyi()</code>,
<code>overlapping_sbm()</code>,
<code>planted_partition()</code>,
<code>sbm()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(27)

lazy_mmsbm &lt;- mmsbm(n = 1000, k = 5, expected_density = 0.01)
lazy_mmsbm

# sometimes you gotta let the world burn and
# sample a wildly dense graph

dense_lazy_mmsbm &lt;- mmsbm(n = 500, k = 3, expected_density = 0.8)
dense_lazy_mmsbm

# explicitly setting the degree heterogeneity parameter,
# mixing matrix, and relative community sizes rather
# than using randomly generated defaults

k &lt;- 5
n &lt;- 1000
B &lt;- matrix(stats::runif(k * k), nrow = k, ncol = k)

theta &lt;- round(stats::rlnorm(n, 2))

alpha &lt;- c(1, 2, 4, 1, 1)

custom_mmsbm &lt;- mmsbm(
  theta = theta,
  B = B,
  alpha = alpha,
  expected_degree = 50
)

custom_mmsbm

edgelist &lt;- sample_edgelist(custom_mmsbm)
edgelist

# efficient eigendecompostion that leverages low-rank structure in
# E(A) so that you don't have to form E(A) to find eigenvectors,
# as E(A) is typically dense. computation is
# handled via RSpectra

population_eigs &lt;- eigs_sym(custom_mmsbm)
svds(custom_mmsbm)$d

</code></pre>


</div>