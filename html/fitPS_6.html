<div class="container">

<table style="width: 100%;"><tr>
<td>bootCI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bootstrap confidence intervals or regions</h2>

<h3>Description</h3>

<p>Use boostrapping to generate confidence intervals, or confidence regions in
the case of the zero-inflated model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bootCI(x, ...)

## Default S3 method:
bootCI(
  x,
  level = 0.95,
  B = 2000,
  model = c("zeta", "ziz"),
  returnBootValues = FALSE,
  silent = FALSE,
  plot = FALSE,
  parallel = TRUE,
  progressBar = FALSE,
  pbopts = list(type = "txt"),
  ...
)

## S3 method for class 'psData'
bootCI(x, ...)

## S3 method for class 'psFit'
bootCI(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a object either of class <code>psData</code>—see <code>readData</code> for more
details—or of class <code>psFit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>the confidence level required—restricted to [0.75, 1). This may
be a vector, in which case multiple intervals, or confidence regions will be
returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>the number of bootstrap samples to take.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>which model to fit to the data, either <code>"zeta"</code> or
<code>"ziz"</code>. Maybe abbreviated to <code>"z"</code> and <code>"zi"</code>. Default
is <code>"zeta"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnBootValues</code></td>
<td>
<p>if <code>TRUE</code> then the <code>vector</code> (or
<code>data.frame</code>) of bootstrapped values is returned. This can be useful
for debugging or understanding the results. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>if <code>TRUE</code>, then no output will be displayed whilst the
bootstrapping is being undertaken. <code>plot</code> if <code>TRUE</code> then the
contours for the confidence region will be plotted. This only works if
<code>model = "ziz"</code>. It is ignored otherwise. <code>parallel</code> if
<code>TRUE</code> then the bootstrapping is performed in parallel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>if <code>TRUE</code> and <code>model == "ziz"</code>, then a plot of the
bootstrapped values will be produced and confidence contour lines will be
drawn for each value in level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>if <code>TRUE</code>, then the package will attempt to use multiple
cores to speed up computation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressBar</code></td>
<td>
<p>if <code>TRUE</code>, then progress bars will be displayed to
show progress on the bootstrapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pbopts</code></td>
<td>
<p>a list of arguments for the <code>pboptions</code>
function that affect the progress bars. Ignored if <code>progressBar =
FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses bootstrapping to compute a confidence interval for
the shape parameter in the case of the zeta model and a confidence region in
the case of the zero-inflated zeta model. A smoothed bootstrap approach is
taken rather than a simple percentile method. The kernel density estimation
is performed by the <code>ks</code> package using a smoothed cross-validated
bandwidth selection procedure.
</p>


<h3>Value</h3>

<p>If <code>returnBootVals == TRUE</code> then the results are returned in a
list with elements named <code>ci</code> and <code>bootVals</code> for the zeta model
and <code>confRegion</code> and <code>bootVals</code> for the zero-inflated zeta model.
The structure of <code>ci</code> and <code>confregion</code> is described below. If
<code>model == "zeta"</code>, then either a <code>vector</code> or a <code>data.frame</code>
with elements/columns named <code>"lower"</code> and <code>"upper"</code> representing
the lower and upper bounds of the confidence interval(s). Multiple bounds
are returned in a <code>data.frame</code> when <code>level</code> has more than one
value. If <code>model == "ziz
 "</code>, then a list with length equal to the
length of <code>level</code> is returned. The name of each element in the list is
the level with 
list has a single element named <code>"95%"</code>. It is possible for there to
be multiple contours for the confidence region for a given <code>level</code>. If
there is only one contour for each value of <code>level</code>, then each element
of the list consists of a <code>list</code> with elements named <code>pi</code> and
<code>shape</code> which specify the coordinates of the contour(s) for that level.
There is a third element named <code>level</code> which gives the height of the
kernel density estimate at that contour. If there are multiple contours for
a given value of <code>level</code> then each list element is a list of lists with
the structure given above (<code>level</code>, <code>pi</code>, and <code>shape</code>). NOTE:
it is quite possible that there are multiple contours for a given height. If
you want a way of thinking about this consider a mountain range with two
mountains of equal height. If you draw the contours for (almost) any
elevation, then you would expect to capture a region from each mountain.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>bootCI(default)</code>: Bootstrap confidence intervals or regions
</p>
</li>
<li> <p><code>bootCI(psData)</code>: Bootstrap confidence intervals or regions
</p>
</li>
<li> <p><code>bootCI(psFit)</code>: Bootstrap confidence intervals or regions
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(Psurveys)
roux = Psurveys$roux
confRegion = bootCI(roux, model = "ziz", parallel = FALSE, plot = TRUE)

## This will not work unless you have the sp package installed
## Count how many of the points lie within the 95% confidence region
lapply(confRegion, function(cr){
  table(sp::point.in.polygon(fit$pi,fit$shape, cr$pi, cr$shape))
. })

## End(Not run)
</code></pre>


</div>