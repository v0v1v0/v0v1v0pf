<div class="container">

<table style="width: 100%;"><tr>
<td>f_group_by</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>'collapse' version of <code>dplyr::group_by()</code>
</h2>

<h3>Description</h3>

<p>This works the exact same as <code>dplyr::group_by()</code> and typically
performs around the same speed but uses slightly less memory.
</p>


<h3>Usage</h3>

<pre><code class="language-R">f_group_by(
  data,
  ...,
  .add = FALSE,
  order = df_group_by_order_default(data),
  .by = NULL,
  .cols = NULL,
  .drop = df_group_by_drop_default(data)
)

group_ordered(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Variables to group by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.add</code></td>
<td>
<p>Should groups be added to existing groups?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Should groups be ordered? If <code>FALSE</code>
groups will be ordered based on first-appearance. <br>
Typically, setting order to <code>FALSE</code> is faster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.drop</code></td>
<td>
<p>Should unused factor levels be dropped? Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>f_group_by()</code> works almost exactly like the 'dplyr' equivalent.
An attribute "ordered" (<code>TRUE</code> or <code>FALSE</code>) is added to the group data to
signify if the groups are sorted or not.
</p>


<h4>Ordered vs Sorted</h4>

<p>The distinction between ordered and sorted is somewhat subtle.
Functions in fastplyr that use a <code>sort</code> argument generally refer
to the top-level dataset being sorted in some way, either by sorting
the group columns like in <code>f_expand()</code> or <code>f_distinct()</code>, or
some other columns, like the count column in <code>f_count()</code>.
</p>
<p>The <code>order</code> argument, when set to <code>TRUE</code> (the default),
is used to mean that the group data will be calculated
using a sort-based algorithm, leading to sorted group data.
When <code>order</code> is <code>FALSE</code>, the group data will be returned based on
the order-of-first appearance of the groups in the data.
This order-of-first appearance may still naturally be sorted
depending on the data.
For example, <code>group_id(1:3, order = T)</code> results in the same group IDs
as <code>group_id(1:3, order = F)</code> because 1, 2, and 3 appear in the data in
ascending sequence whereas <code>group_id(3:1, order = T)</code> does not equal
<code>group_id(3:1, order = F)</code>
</p>
<p>Part of the reason for the distinction is that internally fastplyr
can in theory calculate group data
using the sort-based algorithm and still return unsorted groups,
though this combination is only available to the user in limited places like
<code>f_distinct(order = TRUE, sort = FALSE)</code>.
</p>
<p>The other reason is to prevent confusion in the meaning
of <code>sort</code> and <code>order</code> so that <code>order</code> always refers to the
algorithm specified, resulting in sorted groups, and <code>sort</code> implies a
physical sorting of the returned data. It's also worth mentioning that
in most functions, <code>sort</code> will implicitly utilise the sort-based algorithm
specified via <code>order = TRUE</code>.
</p>



<h4>Using the order-of-first appearance algorithm for speed</h4>

<p>In many situations (not all) it can be faster to use the
order-of-first appearance algorithm, specified via <code>order = FALSE</code>.
</p>
<p>This can generally be accessed by first calling
<code>f_group_by(data, ..., order = FALSE)</code> and then
performing your calculations.
</p>
<p>To utilise this algorithm more globally and package-wide,
set the '.fastplyr.order.groups' option to <code>FALSE</code> using the code:
<code>options(.fastplyr.order.groups = FALSE)</code>.
</p>



<h3>Value</h3>

<p><code>f_group_by()</code> returns a <code>grouped_df</code> that can be used
for further for grouped calculations.
</p>
<p><code>group_ordered()</code> returns <code>TRUE</code> if the group data are sorted,
i.e if <code>attr(attr(data, "groups"), "ordered") == TRUE</code>. If sorted,
which is usually the default, this leads to summary calculations
like <code>f_summarise()</code> or <code>dplyr::summarise()</code> producing sorted groups.
If <code>FALSE</code> they are returned based on order-of-first appearance in the data.
</p>


</div>