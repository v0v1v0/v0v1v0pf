<div class="container">

<table style="width: 100%;"><tr>
<td>svds.undirected_factor_model</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the singular value decomposition of the expected adjacency matrix of an undirected factor model</h2>

<h3>Description</h3>

<p>Compute the singular value decomposition of the expected adjacency matrix of an undirected factor model
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'undirected_factor_model'
svds(A, k = A$k, nu = k, nv = k, opts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>An <code>undirected_factor_model()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>Desired rank of decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>Number of left singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nv</code></td>
<td>
<p>Number of right singular vectors to be computed. This must
be between 0 and <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opts</code></td>
<td>
<p>Control parameters related to the computing
algorithm. See <strong>Details</strong> below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Unused, included only for consistency with generic signature.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>opts</code> argument is a list that can supply any of the
following parameters:
</p>

<dl>
<dt><code>ncv</code></dt>
<dd>
<p>Number of Lanzcos basis vectors to use. More vectors
will result in faster convergence, but with greater
memory use. <code>ncv</code> must be satisfy
<code class="reqn">k &lt; ncv \le p</code> where
<code>p = min(m, n)</code>.
Default is <code>min(p, max(2*k+1, 20))</code>.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>Precision parameter. Default is 1e-10.</p>
</dd>
<dt><code>maxitr</code></dt>
<dd>
<p>Maximum number of iterations. Default is 1000.</p>
</dd>
<dt><code>center</code></dt>
<dd>
<p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <code class="reqn">n</code>. If a vector <code class="reqn">c</code> is supplied, then
SVD is computed on the matrix <code class="reqn">A - 1c'</code>,
in an implicit way without actually forming this matrix.
<code>center = TRUE</code> has the same effect as
<code>center = colMeans(A)</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>scale</code></dt>
<dd>
<p>Either a logical value (<code>TRUE</code>/<code>FALSE</code>), or a numeric
vector of length <code class="reqn">n</code>. If a vector <code class="reqn">s</code> is supplied, then
SVD is computed on the matrix <code class="reqn">(A - 1c')S</code>,
where <code class="reqn">c</code> is the centering vector and <code class="reqn">S = diag(1/s)</code>.
If <code>scale = TRUE</code>, then the vector <code class="reqn">s</code> is computed as
the column norm of <code class="reqn">A - 1c'</code>.
Default is <code>FALSE</code>.</p>
</dd>
</dl>
</div>