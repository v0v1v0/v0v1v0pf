<div class="container">

<table style="width: 100%;"><tr>
<td>qtclust</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Stochastic QT Clustering</h2>

<h3>Description</h3>

<p>Perform stochastic QT clustering on a data matrix.
</p>


<h3>Usage</h3>

<pre><code class="language-R">qtclust(x, radius, family = kccaFamily("kmeans"), control = NULL,
        save.data=FALSE, kcca=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric matrix of data, or an object that can be coerced to
such a matrix (such as a numeric vector or a data frame with all
numeric columns).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>radius</code></td>
<td>
<p>Maximum radius of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Object of class <code>"kccaFamily"</code> specifying the
distance measure to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>An object of class <code>"flexclustControl"</code>
specifying the minimum number of observations per cluster
(<code>min.size</code>), and trials per iteration (<code>ntry</code>, see details
below).</p>
</td>
</tr>
</table>
<p>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>save.data</code></td>
<td>
<p>Save a copy of <code>x</code> in the return object?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kcca</code></td>
<td>
<p>Run <code>kcca</code> after the QT cluster algorithm has
converged?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function implements a variation of the QT clustering algorithm by
Heyer et al. (1999), see Scharl and Leisch (2006). The main difference
is that in each iteration not
all possible cluster start points are considered, but only a random
sample of size <code>control@ntry</code>. We also consider only points as initial
centers where at least one other point is within a circle with radius
<code>radius</code>.  In most cases the resulting
solutions are almost
the same at a considerable speed increase, in some cases even better
solutions are obtained than with the original algorithm. If
<code>control@ntry</code> is set to the size of the data set, an algorithm
similar to the original algorithm as proposed by Heyer et al. (1999)
is obtained.
</p>


<h3>Value</h3>

<p>Function <code>qtclust</code> by default returns objects of class
<code>"kccasimple"</code>. If argument <code>kcca</code> is <code>TRUE</code>, function
<code>kcca()</code> is run afterwards (initialized on the QT cluster
solution). Data points
not clustered by the QT cluster algorithm are omitted from the
<code>kcca()</code> iterations, but filled back into the return
object. All plot methods defined for objects of class <code>"kcca"</code>
can be used.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch</p>


<h3>References</h3>

<p>Heyer, L. J., Kruglyak, S., Yooseph, S. (1999). Exploring expression data:
Identification and analysis of coexpressed genes. Genome Research 9,
1106–1115.
</p>
<p>Theresa Scharl and Friedrich Leisch. The stochastic QT-clust
algorithm: evaluation of stability and variance on time-course
microarray data. In Alfredo Rizzi and Maurizio Vichi, editors,
Compstat 2006 – Proceedings in Computational Statistics, pages
1015-1022. Physica Verlag, Heidelberg, Germany, 2006.
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- matrix(10*runif(1000), ncol=2)

## maximum distrance of point to cluster center is 3
cl1 &lt;- qtclust(x, radius=3)

## maximum distrance of point to cluster center is 1
## -&gt; more clusters, longer runtime
cl2 &lt;- qtclust(x, radius=1)

opar &lt;- par(c("mfrow","mar"))
par(mfrow=c(2,1), mar=c(2.1,2.1,1,1))
plot(x, col=predict(cl1), xlab="", ylab="")
plot(x, col=predict(cl2), xlab="", ylab="")
par(opar)
</code></pre>


</div>