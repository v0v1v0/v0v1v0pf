<div class="container">

<table style="width: 100%;"><tr>
<td>vcov_conley</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conley VCOV</h2>

<h3>Description</h3>

<p>Compute VCOVs robust to spatial correlation, a la Conley (1999).
</p>


<h3>Usage</h3>

<pre><code class="language-R">vcov_conley(
  x,
  lat = NULL,
  lon = NULL,
  cutoff = NULL,
  pixel = 0,
  distance = "triangular",
  ssc = NULL,
  vcov_fix = TRUE
)

conley(cutoff = NULL, pixel = NULL, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>fixest</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lat</code></td>
<td>
<p>A character scalar or a one sided formula giving the name of the variable
representing the latitude. The latitude must lie in [-90, 90], [0, 180] or [-180, 0].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lon</code></td>
<td>
<p>A character scalar or a one sided formula giving the name of the variable
representing the longitude. The longitude must be in [-180, 180], [0, 360] or [-360, 0].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>The distance cutoff, in km. You can express the cutoff in miles by writing the
number in character form and adding "mi" as a suffix: cutoff = "100mi" would be 100 miles. If
missing, a rule of thumb is used to deduce the cutoff.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pixel</code></td>
<td>
<p>A positive numeric scalar, default is 0. If a positive number, the coordinates of
each observation are pooled into <code>pixel</code> x <code>pixel</code> km squares. This lowers the precision but can
(depending on the cases) greatly improve computational speed at a low precision cost. Note that
if the <code>cutoff</code> was expressed in miles, then <code>pixel</code> will also be in miles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>How to compute the distance between points. It can be equal to "triangular"
(default) or "spherical". The latter case corresponds to the great circle distance and is more
precise than triangular but is a bit more intensive computationally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object returned by the function <code>ssc</code>. It specifies how to perform the small
sample correction.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov_fix</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. If the VCOV ends up not being
positive definite, whether to "fix" it using an eigenvalue decomposition
(a la Cameron, Gelbach &amp; Miller 2011).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes VCOVs that are robust to spatial correlations by assuming a correlation
between the units that are at a geographic distance lower than a given cutoff.
</p>
<p>The kernel is uniform.
</p>
<p>If the cutoff is not provided, an estimation of it is given. This cutoff ensures that a minimum
of units lie within it and is robust to sub-sampling. This automatic cutoff is only here for
convenience, the most appropriate cutoff shall depend on the application and shall be provided
by the user.
</p>
<p>The function <code>conley</code> does not compute VCOVs directly but is meant to be used in the argument
<code>vcov</code> of <code>fixest</code> functions (e.g. in <code>vcov.fixest</code> or even in the estimation calls).
</p>


<h3>Value</h3>

<p>If the first argument is a <code>fixest</code> object, then a VCOV is returned (i.e. a symmetric matrix).
</p>
<p>If the first argument is not a <code>fixest</code> object, then a) implicitly the arguments are shifted to
the left (i.e. <code>vcov_conley("lat", "long")</code> is equivalent to
<code>vcov_conley(lat = "lat", lon = "long")</code>) and b) a VCOV-<em>request</em> is returned and NOT a VCOV.
That VCOV-request can then be used in the argument <code>vcov</code> of various <code>fixest</code> functions
(e.g. <code>vcov.fixest</code> or even in the estimation calls).
</p>


<h3>References</h3>

<p>Conley TG (1999). "GMM Estimation with Cross Sectional Dependence", <em>Journal of Econometrics</em>, 92, 1-45.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(quakes)

# We use conley() in the vcov argument of the estimation
feols(depth ~ mag, quakes, conley(100))

# Post estimation
est = feols(depth ~ mag, quakes)
vcov_conley(est, cutoff = 100)



</code></pre>


</div>