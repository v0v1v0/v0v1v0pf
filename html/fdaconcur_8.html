<div class="container">

<table style="width: 100%;"><tr>
<td>historyIndexDense</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional History Index Model</h2>

<h3>Description</h3>

<p>Functional history index model for dense functional responses and dense functional predictors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">historyIndexDense(Y, X, Lag = NULL, optnsY = NULL, optnsX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a list which contains functional responses in the form of a list LY and the time points LT at which they are observed (i.e., list(Ly = LY,Lt = LT)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a list of lists which contains the observed functional predictors list Lxj and the time points list Ltj at which they are observed. It needs to be of the form <code>list(list(Ly = Lx1,Lt = Lxt1),list(Ly = Lx2,Lt = Lxt2),...)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lag</code></td>
<td>
<p>a length <code>length(X)</code> vector denoting the lags for all predictors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optnsY</code></td>
<td>
<p>a list of options control parameters for the response specified by <code>list(name=value)</code>. See ‘Details’ in <code>fdapace::FPCA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optnsX</code></td>
<td>
<p>a list of options control parameters for the predictors specified by <code>list(name=value)</code>. See ‘Details’ in <code>fdapace::FPCA</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The functional history index model is defined as
<code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{i=1}^p\beta_i(t)\int_0^{\Delta_i}\gamma_i(s)X_i(t-s)ds</code>
for <code class="reqn">t\in[\max_i\{\Delta_i\}, T]</code> with a suitable <code class="reqn">T&gt;0</code>.
Write <code class="reqn">\alpha_i(t, s)=\beta_i(t)\gamma_i(s)</code>. It becomes
<code class="reqn">E[Y(t)|X_1(t), \cdots, X_p(t)] = \beta_0(t) + \sum_{i=1}^p\int_0^{\Delta_i}\alpha_i(t, s)X_i(t-s)ds</code>.
For more details we refer to
<cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
</p>


<h3>Value</h3>

<p>A list of the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>a vector of <code>length(workGridY)</code> representing the fitted <code class="reqn">\beta_0(t)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>a list of matrices with the <code class="reqn">i</code>-th element representing the fitted <code class="reqn">\alpha_i(t, s)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yHat</code></td>
<td>
<p>an n by <code>length(workGridY)</code> matrix of fitted <code class="reqn">Y_i(t)</code>'s.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workGridY</code></td>
<td>
<p>a vetor representing the working grid for the response.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workGridLag</code></td>
<td>
<p>a list of vectors with the <code class="reqn">i</code>-th element representing the working grid in <code class="reqn">[0, \Delta_i]</code>.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p><cite>Şentürk, D. and Müller, H.G., (2010). Functional varying coefficient models for longitudinal data. Journal of the American Statistical Association, 105(491), pp.1256-1264.</cite>
<cite>Yao, F., Müller, H.G., Wang, J.L. (2005). Functional linear regression analysis for longitudinal data. Annals of Statistics 33, 2873–2903.</cite>
<cite>Hall, P., Horowitz, J.L. (2007). Methodology and convergence rates for functional linear regression. The Annals of Statistics, 35(1), 70–91.</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
### functional covariate X(t) ###
phi1 &lt;- function(t) sin(pi*t / 5) / sqrt(5)
phi2 &lt;- function(t) cos(pi*t / 5) / sqrt(5)
lambdaX &lt;- c(10, 5)
n &lt;- 150
N &lt;- 101
Xi &lt;- matrix(rnorm(2*n), nrow = n, ncol = 2)
denseLt &lt;- list()
denseLy &lt;- list()
t0 &lt;- seq(0, 15, length.out = N)
for (i in 1:n) {
  denseLt[[i]] &lt;- t0
  denseLy[[i]] &lt;- lambdaX[1]*Xi[i, 1]*phi1(t0) + lambdaX[2]*Xi[i, 2]*phi2(t0)
}
denseX0 &lt;- list(Ly = denseLy, Lt = denseLt)

### generate coefficient function gamma(u), beta(u) ###
Lag &lt;- 5
u0 &lt;- t0[t0&lt;=Lag]
t0_out &lt;- t0[t0&gt;=Lag]
gamma_u &lt;- function(u) sqrt(2/5) * cos(pi * u /5)
beta_1 &lt;- function(t) 5*sin(pi*t/10)
beta_0 &lt;- function(t) t^2/2

### functional response Y(t), t in t0_out ###
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n) {
  denseLt[[i]] &lt;- t0_out
  Xt &lt;- denseX0$Ly[[i]]
  Xtu &lt;- t(sapply((1:N)[t0&gt;=Lag], function(j){
    rev(Xt[(j-length(u0)+1):j])  #history index for X[t-u:t]
  }))
  IntGammaXtu &lt;- apply(Xtu, 1, function(v){
    fdapace::trapzRcpp(u0, gamma_u(u0) * v)
  })
  #append 0 in the first length(u0)-1 element(useless info. in our modeling)
  denseLy[[i]] &lt;- beta_0(t0_out) + IntGammaXtu * beta_1(t0_out) + rnorm(length(t0_out), 0, 0.1)
}
denseY &lt;- list(Ly = denseLy, Lt = denseLt)

### functional predictor X(t) (adjust for t0_out) ###
denseLt &lt;- list()
denseLy &lt;- list()
for (i in 1:n){
  denseLt[[i]] &lt;- t0_out
  denseLy[[i]] &lt;- denseX0$Ly[[i]][t0&gt;=Lag]
}
denseX &lt;- list(Ly = denseLy,
               Lt = denseLt)
fit &lt;- historyIndexDense(Y = denseY, X = list(X = denseX), Lag = Lag)
fit$beta0
fit$alpha[[1]]
</code></pre>


</div>