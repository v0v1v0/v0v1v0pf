<div class="container">

<table style="width: 100%;"><tr>
<td>boottest.felm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast wild cluster bootstrap inference for object of class felm</h2>

<h3>Description</h3>

<p><code>boottest.felm</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class felm by  implementing
fast wild bootstrap algorithms as developed in Roodman et al., 2019
and MacKinnon, Nielsen &amp; Webb (2022).
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'felm'
boottest(
  object,
  param,
  B,
  clustid = NULL,
  bootcluster = "max",
  fe = NULL,
  conf_int = TRUE,
  R = NULL,
  r = 0,
  beta0 = NULL,
  sign_level = 0.05,
  type = "rademacher",
  impose_null = TRUE,
  bootstrap_type = "fnw11",
  p_val_type = "two-tailed",
  tol = 1e-06,
  maxiter = 10,
  sampling = "dqrng",
  nthreads = getBoottest_nthreads(),
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  engine = getBoottest_engine(),
  floattype = "Float64",
  maxmatsize = FALSE,
  bootstrapc = FALSE,
  getauxweights = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class felm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>A character vector or rhs formula. The name of the regression
coefficient(s) for which the hypothesis is to be tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number
of clusters is low,
increasing B adds little additional runtime.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables. If NULL,
a heteroskedasticity-robust (HC1) wild bootstrap is run.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1.
Specifies the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered
by the intersections of
clustering implied by the listed variables. To mimic the behavior
of stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include "min", where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fe</code></td>
<td>
<p>A character vector or rhs formula of length one which contains
the name of the fixed effect to be projected
out in the bootstrap. Note: if regression weights are used, fe
needs to be NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_int</code></td>
<td>
<p>A logical vector. If TRUE, boottest computes confidence
intervals by test inversion. If FALSE, only the p-value is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Hypothesis Vector giving linear combinations of coefficients.
Must be either NULL or a vector of the same length as <code>param</code>. If NULL,
a vector of ones of length param.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A numeric. Shifts the null hypothesis
H0: param = r vs H1: param != r</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>Deprecated function argument. Replaced by function argument 'r'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of "rademacher", "mammen", "norm"
and "webb". Alternatively, type can be a function(n) for drawing
wild bootstrap factors. "rademacher" by default.
For the Rademacher distribution, if the number of replications B
exceeds the number of possible draw ombinations,
2^(#number of clusters), then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrap_type</code></td>
<td>
<p>Determines which wild cluster bootstrap type should be
run. Options are "fnw11","11", "13", "31" and "33" for the wild cluster
bootstrap and "11" and "31" for the heteroskedastic bootstrap.
For more information, see the details section. "fnw11" is the default for
the cluster bootstrap, which runs a "11" type
wild cluster bootstrap via the algorithm outlined in "fast and wild"
(Roodman et al (2019)). "11" is the default for the heteroskedastic
bootstrap.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default "two-tailed". Other options include "equal-tailed",
"&gt;" and "&lt;".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
1e-6 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Integer. Maximum number of iterations used in the root
finding procedure to find the confidence interval.
10 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling</code></td>
<td>
<p>'dqrng' or 'standard'. If 'dqrng', the 'dqrng' package is
used for random number generation (when available). If 'standard',
functions from the 'stats' package are used when available.
This argument is mostly a convenience to control random number generation in
a wrapper package around <code>fwildclusterboot</code>, <code>wildrwolf</code>.
I recommend to use the fast' option.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>The number of threads. Can be: a) an integer lower than,
or equal to, the maximum number of threads; b) 0: meaning
all available threads will be used; c) a number strictly
between 0 and 1 which represents the fraction of all threads
to use. The default is to use 1 core.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code>boot_ssc()</code>. Represents how the small sample
adjustments are computed. The defaults are
adj = TRUE, fixef.K = "none", cluster.adj = "TRUE",
cluster.df = "conventional". You can find more details in the help
file for <code>boot_ssc()</code>. The function is purposefully designed to mimic
fixest's <code>fixest::ssc()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>engine</code></td>
<td>
<p>Character scalar. Either "R" or "WildBootTests.jl".
Controls the algorithm employed by boottest.
"R" is the default and implements the cluster bootstrap
as in Roodman (2019). "WildBootTests.jl" executes the wild
cluster bootstrap by via the WildBootTests.jl
package. For it to run, Julia and WildBootTests.jl need to
be installed. Check out the set_up_ ... functions
The "fast and wild" algorithm is extremely fast for small
number of clusters, but because it is fully vectorized,
very memory-demanding.
For large number of clusters and large number of bootstrap
iterations, the fast and wild algorithm becomes infeasible.
If a out-of-memory error #
occurs, the "lean" algorithm is a memory friendly, but less
performant rcpp-armadillo based implementation of the wild
cluster bootstrap.
Note that if no cluster is provided, boottest() always
defaults to the "lean" algorithm. Note that you can set the
employed algorithm globally by using the
<code>setBoottest_engine()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit? Only relevant when
'engine = "WildBootTests.jl"'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set the
maximum size of auxilliary weight matrix (v), in gigabytes. Only relevant
when 'engine = "WildBootTests.jl"'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t. Only relevant when 'engine =
"WildBootTests.jl"'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getauxweights</code></td>
<td>
<p>Logical. Whether to save auxilliary weight matrix (v)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>boottest</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_int</code></td>
<td>
<p>The bootstrap confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>The tested parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>The vector "R" in the null hypothesis of interest Rbeta = r.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The scalar "r" in the null hypothesis of interest Rbeta = r.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_vals</code></td>
<td>
<p>All t-statistics calculated while calculating the
confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_grid_vals</code></td>
<td>
<p>All p-values calculated while calculating the confidence
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>engine</code></td>
<td>
<p>The employed bootstrap algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>The number of threads employed.</p>
</td>
</tr>
</table>
<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via
</p>

<ul>
<li> <p><code>set.seed()</code> when using
</p>

<ol>
<li>
<p> the lean algorithm (via <code>engine = "R-lean"</code>) including the
heteroskedastic wild bootstrap
</p>
</li>
<li>
<p> the wild cluster bootstrap via <code>engine = "R"</code> with Mammen weights or
</p>
</li>
<li> <p><code>engine = "WildBootTests.jl"</code>
</p>
</li>
</ol>
</li>
<li> <p><code>dqrng::dqset.seed()</code> when using <code>engine = "R"</code> for Rademacher, Webb
or Normal weights
</p>
</li>
</ul>
<h3>Confidence Intervals</h3>

<p><code>boottest</code> computes confidence intervals by inverting p-values.
In practice, the following procedure is used:
</p>

<ul>
<li>
<p> Based on an initial guess for starting values, calculate p-values for
26 equal spaced points between the starting values.
</p>
</li>
<li>
<p> Out of the 26 calculated p-values, find the two pairs of values x
for which the corresponding p-values px cross the significance level
sign_level.
</p>
</li>
<li>
<p> Feed the two pairs of x into an numerical root finding procedure and
solve for the root. boottest currently relies on
<code>stats::uniroot</code> and sets an absolute tolerance of 1e-06 and
stops the procedure after 10 iterations.
</p>
</li>
</ul>
<h3>Standard Errors</h3>

<p><code>boottest</code> does not calculate standard errors.
</p>


<h3>Stata, Julia and Python Implementations</h3>

<p>The fast wild cluster bootstrap algorithms are further implemented in the
following software packages:
</p>

<ul>
<li>
<p> Stata:<a href="https://github.com/droodman/boottest">boottest</a>
</p>
</li>
<li>
<p> Julia:<a href="https://github.com/droodman/WildBootTests.jl">WildBootTests.jl</a>
</p>
</li>
<li>
<p> Python:<a href="https://github.com/s3alfisc/wildboottest">wildboottest</a>
</p>
</li>
</ul>
<h3>References</h3>

<p>Roodman et al., 2019, "Fast and wild: Bootstrap inference in
STATA using boottest", The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>MacKinnon, James G., Morten Ørregaard Nielsen, and
Matthew D. Webb. Fast and reliable jackknife and bootstrap
methods for cluster-robust inference. No. 1485. 2022.
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
"Bootstrap-based improvements for inference with clustered errors."
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller.
"A practitioner's guide to cluster-robust inference"
Journal of Human Resources (2015) <a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. "Wild Bootstrap Tests for IV regression"
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
"The wild bootstrap for few (treated) clusters.
" The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
"Cluster-robust inference: A guide to empirical practice"
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. "Wild cluster bootstrap confidence intervals."
L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D. Reworking wild bootstrap based inference for
clustered errors. No. 1315. Queen's Economics Department Working Paper,
2013.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
  requireNamespace("lfe") 
  data(voters)
  felm_fit &lt;- felm(proposition_vote ~ treatment + ideology1 + log_income |
    Q1_immigration,
  data = voters
  )
  boot1 &lt;- boottest(felm_fit,
    B = 9999,
    param = "treatment",
    clustid = "group_id1"
  )
  boot2 &lt;- boottest(felm_fit,
    B = 9999,
    param = "treatment",
    clustid = c("group_id1", "group_id2")
  )
  boot3 &lt;- boottest(felm_fit,
    B = 9999,
    param = "treatment",
    clustid = c("group_id1", "group_id2"),
    fe = "Q1_immigration"
  )
  boot4 &lt;- boottest(felm_fit,
    B = 999,
    param = "treatment",
    clustid = c("group_id1", "group_id2"),
    fe = "Q1_immigration",
    sign_level = 0.2,
    r = 2
  )
  # test treatment + ideology1 = 2
  boot5 &lt;- boottest(felm_fit,
    B = 9999,
    clustid = c("group_id1", "group_id2"),
    param = c("treatment", "ideology1"),
    R = c(1, 1),
    r = 2
  )
  summary(boot1)
  print(boot1)
  plot(boot1)
  nobs(boot1)
  pval(boot1)
  confint(boot1)
  generics::tidy(boot1)
  
# run different bootstrap types following MacKinnon, Nielsen &amp; Webb (2022):

# default: the fnw algorithm
boot_fnw11 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1", 
  bootstrap_type = "fnw11"
)

# WCR 31 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "31"
)

# WCU33 
boot_WCR31 &lt;- boottest(lm_fit,
  B = 9999,
  param = "treatment",
  clustid = "group_id1",
  bootstrap_type = "33", 
  impose_null = FALSE
)

## End(Not run)

</code></pre>


</div>