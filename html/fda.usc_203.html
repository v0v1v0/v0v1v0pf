<div class="container">

<table style="width: 100%;"><tr>
<td>metric.lp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Approximates Lp-metric distances for functional data.</h2>

<h3>Description</h3>

<p>Measures the proximity between the functional data and curves approximating
Lp-metric. If <code>w = 1</code> approximates the Lp-metric by Simpson's rule. By
default it uses <code>lp = 2</code> and weights <code>w = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">metric.lp(fdata1, fdata2 = NULL, lp = 2, w = 1, dscale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdata1</code></td>
<td>
<p>Functional data 1 or curve 1. If <code>fdata</code> class, the
dimension of <code>fdata1$data</code> object is (<code>n1</code> x <code>m</code>), where
<code>n1</code> is the number of curves and <code>m</code> are the points observed in
each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fdata2</code></td>
<td>
<p>Functional data 2 or curve 2. If <code>fdata</code> class, the
dimension of <code>fdata2$data</code> object is (<code>n2</code> x <code>m</code>), where
<code>n2</code> is the number of curves and <code>m</code> are the points observed in
each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lp</code></td>
<td>
<p>Lp norm, by default it uses <code>lp = 2</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>Vector of weights with length <code>m</code>, If <code>w = 1</code>
approximates the metric Lp by Simpson's rule. By default it uses <code>w =
1</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dscale</code></td>
<td>
<p>If scale is a numeric, the distance matrix is divided by the
scale value. If scale is a function (as the mean for example) the distance
matrix is divided by the corresponding value from the output of the
function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default it uses the L2-norm with <code>lp = 2</code>.  </p>
<p style="text-align: center;"><code class="reqn">Let \ \ f(x)=
fdata1(x)-fdata2(x)</code>
</p>

<p style="text-align: center;"><code class="reqn">\left\|f\right\|_p=\left ( \frac{1}{\int_{a}^{b}w(x)dx} \int_{a}^{b}
\left|f(x)\right|^{p}w(x)dx \right)^{1/p}</code>
</p>
 <p><br> 
The observed points on each curve are equally spaced (by default) or not.
</p>
<p>The L<code class="reqn">\infty</code>-norm is computed with <code>lp = 0</code>.
</p>
<p style="text-align: center;"><code class="reqn">d(fdata1(x),fdata2(x))_{\infty}=sup
\left|fdata1(x)-fdata2(x)\right|</code>
</p>



<h3>Author(s)</h3>

<p>Manuel Febrero-Bande, Manuel Oviedo de la Fuente
<a href="mailto:manuel.oviedo@udc.es">manuel.oviedo@udc.es</a>
</p>


<h3>References</h3>

<p>Febrero-Bande, M., Oviedo de la Fuente, M. (2012).
<em>Statistical Computing in Functional Data Analysis: The R Package
fda.usc.</em> Journal of Statistical Software, 51(4), 1-28.
<a href="https://www.jstatsoft.org/v51/i04/">https://www.jstatsoft.org/v51/i04/</a>
</p>


<h3>See Also</h3>

<p>See also <code>semimetric.basis</code> and
<code>semimetric.NPFDA</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
#	INFERENCE PHONDAT
data(phoneme)
mlearn&lt;-phoneme$learn[1:100]
mtest&lt;-phoneme$test[1:100]
glearn&lt;-phoneme$classlearn[1:100]
gtest&lt;-phoneme$classtest[1:100]
# Matrix of distances of curves of DATA1
mdist1&lt;-metric.lp(mlearn)

# Matrix of distances between curves of DATA1 and curves of DATA2
mdist2&lt;-metric.lp(mlearn,mtest,lp=2)
# mdist with L1 norm and weigth=v
v=dnorm(seq(-3,3,len=dim(mlearn)[2]))
mdist3&lt;-metric.lp(mlearn,mtest,lp=1,w=v)
plot(1:100,mdist2[1,],type="l",ylim=c(1,max(mdist3[1,])))
lines(mdist3[1,],type="l",col="2")

# mdist with mlearn with different discretization points.
# mlearn2=mlearn
# mlearn2[["argvals"]]=seq(0,1,len=150)
# mdist5&lt;-metric.lp(mlearn,mlearn2)
# mdist6&lt;-metric.lp(mlearn2,mlearn) 
# sum(mdist5-mdist6)
# sum(mdist1-mdist6)

x&lt;-seq(0,2*pi,length=1001)
fx&lt;-fdata(sin(x)/sqrt(pi),x)
fx0&lt;-fdata(rep(0,length(x)),x)
metric.lp(fx,fx0)
# The same
integrate(function(x){(abs(sin(x)/sqrt(pi))^2)},0,2*pi)

## End(Not run)

</code></pre>


</div>