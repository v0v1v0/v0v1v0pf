<div class="container">

<table style="width: 100%;"><tr>
<td>mcmc-loop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to interact with the main loop</h2>

<h3>Description</h3>

<p>You can use these functions to read variables, store, and retrieve data
during the MCMC process.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ith_step(x)

set_userdata(...)

get_userdata()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Name of the element to retrieve. If missing, it will return the entire
environment in which the main MCMC loop is running.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Named values to be appended to the user data.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function <code>ith_step()</code> provides access to the following elements:
</p>

<ul>
<li> <p><code>i</code>            : (int) Step (iteration) number.
</p>
</li>
<li> <p><code>nsteps</code>       : (int) Number of steps.
</p>
</li>
<li> <p><code>chain_id</code>     : (int) Id of the chain (goes from 1 to -nchains-)
</p>
</li>
<li> <p><code>theta0</code>       : (double vector) Current state of the chain.
</p>
</li>
<li> <p><code>theta1</code>       : (double vector) Proposed state of the chain.
</p>
</li>
<li> <p><code>ans</code>          : (double matrix) Set of accepted states (it will be NA for rows &gt;= i).
</p>
</li>
<li> <p><code>draws</code>        : (double matrix) Set of proposed states (it will be NA for rows &gt;= i).
</p>
</li>
<li> <p><code>logpost</code>      : (double vector) Value of -fun- (it will be NA for elements &gt;= i).
</p>
</li>
<li> <p><code>R</code>            : (double vector) Random values from U(0,1). This is used with the Hastings ratio.
</p>
</li>
<li> <p><code>thin</code>         : (int) Thinning (applied after the last step).
</p>
</li>
<li> <p><code>burnin</code>       : (int) Burn-in (applied after the last step).
</p>
</li>
<li> <p><code>conv_checker</code> : (function) Convergence checker function.
</p>
</li>
<li> <p><code>kernel</code>       : (fmcmc_kernel) Kernel object.
</p>
</li>
<li> <p><code>fun</code>          : (function) Passed function to MCMC.
</p>
</li>
<li> <p><code>f</code>            : (function) Wrapper of -fun-.
</p>
</li>
<li> <p><code>initial</code>      : (double vector) Starting point of the chain.
</p>
</li>
</ul>
<p>The following objects always have fixed values (see ?ith_step): nchains, cl, multicore
</p>
<p>Other available objects: cnames, funargs, MCMC_OUTPUT, passedargs, progress
</p>
<p>The function <code>set_userdata()</code> returns <code>invisible()</code>. The only side
effect is appending the information by row.
</p>


<h3>Advanced usage</h3>

<p>The function <code>ith_step()</code> is a convenience function that provides
access to the environment within which the main loop of the MCMC call is
being evaluated. This is a wrapper of <code>MCMC_OUTPUT$loop_envir</code> that will
either return the value <code>x</code> or, if missing, the entire environment. If
<code>ith_step()</code> is called outside of the <code>MCMC</code> call, then it will return with
an error.
</p>
<p>For example, if you wanted to print information if the current value
of logpost is greater than the previous value of logpost, you could define
the objective function as follows:
</p>
<div class="sourceCode"><pre>f &lt;- function(p) {

  i            &lt;- ith_step("i")
  logpost_prev &lt;- ith_step("logpost")[i - 1L]
  logpost_curr &lt;- sum(dnorm(y - x*p, log = TRUE))
  
  if (logpost_prev &lt; logpost_curr)
    cat("At a higher point!\n")
    
  return(logpost_curr)

}
</pre></div>
<p>In the case of the objects <code>nchains</code>, <code>cl</code>, and <code>multicore</code>, the function will
always return the default values <code>1</code>, <code>NULL</code>, and <code>FALSE</code>, respectively. Thus, the
user shouldn't rely on these objects to provide information regarding runs
using multiple chains. More examples below.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#' # Getting the logpost -------------------------------------------------------
set.seed(23133)
x &lt;- rnorm(200)
y &lt;- x*2 + rnorm(200)
f &lt;- function(p) {
  sum(dnorm(y - x*p, log = TRUE))
}

ans &lt;- MCMC(fun = f, initial = c(0), nsteps=2000)
plot(get_logpost(), type = "l") # Plotting the logpost from the last run


# Printing information every 500 step ---------------------------------------
# for this we use ith_step()

f &lt;- function(p) {

  # Capturing info from within the loop
  i      &lt;- ith_step("i")
  nsteps &lt;- ith_step("nsteps")
  
  if (!(i %% 500)) {
  
    cat(
      "////////////////////////////////////////////////////\n",
      "Step ", i, " of ", nsteps,". Values in the loop:\n",
      "theta0: ", ith_step("theta0"), "\n",
      "theta1: ", ith_step()$theta1, "\n",
      sep = ""
    )
  }
    

  sum(dnorm(y - x*p, log = TRUE))
}

ans0 &lt;- MCMC(fun = f, initial = c(0), nsteps=2000, progress = FALSE, seed = 22)
# ////////////////////////////////////////////////////
# Step 500 of 2000. Values in the loop:
# theta0: 2.025379
# theta1: 1.04524
# ////////////////////////////////////////////////////
# Step 1000 of 2000. Values in the loop:
# theta0: 2.145967
# theta1: 0.2054037
# ////////////////////////////////////////////////////
# Step 1500 of 2000. Values in the loop:
# theta0: 2.211691
# theta1: 2.515361
# ////////////////////////////////////////////////////
# Step 2000 of 2000. Values in the loop:
# theta0: 1.998789
# theta1: 1.33034


# Printing information if the current logpost is greater than max -----------
f &lt;- function(p) {

  i            &lt;- ith_step("i")
  logpost_prev &lt;- max(ith_step("logpost")[1:(i-1)])
  logpost_curr &lt;- sum(dnorm(y - x*p, log = TRUE))
  
  # Only worthwhile after the first step
  if ((i &gt; 1L) &amp;&amp; logpost_prev &lt; logpost_curr)
    cat("At a higher point!:", logpost_curr, ", step:", i,"\n")
    
  return(logpost_curr)

}
ans1 &lt;- MCMC(fun = f, initial = c(0), nsteps=1000, progress = FALSE, seed = 22)
# At a higher point!: -357.3584 , step: 2 
# At a higher point!: -272.6816 , step: 6 
# At a higher point!: -270.9969 , step: 7 
# At a higher point!: -269.8128 , step: 24 
# At a higher point!: -269.7435 , step: 46 
# At a higher point!: -269.7422 , step: 543 
# At a higher point!: -269.7421 , step: 788 
# Saving extra information --------------------------------------------------
data("lifeexpect")

# Defining the logposterior
logpost &lt;- function(p) {

  # Reconding the sum of the parameters (just because) 
  # and the number of step.
  set_userdata(i = ith_step("i"), sum_of_p = sum(p))

  with(lifeexpect, {
    sum(dnorm(age - (p[1] + p[2]*smoke + p[3]*female), sd = p[4], log = TRUE))
  })
  
}

# A kernel where sd is positive, the first is average age, so we 
# make it positive too
kern &lt;- kernel_ram(lb = c(10, -20, -20, .0001), eps = .01)
ans &lt;- MCMC(
  initial = c(70, -2, 2, 1), fun = logpost, kernel = kern, nsteps = 1000, seed = 1
  )

# Retrieving the data
head(get_userdata())

# It also works using multiple chains
ans_two &lt;- MCMC(
  initial = c(70, -2, 2, 1), fun = logpost, kernel = kern, nsteps = 1000, seed = 1, nchains = 2
  )
  
user_dat &lt;- get_userdata()
lapply(user_dat, head)

</code></pre>


</div>