<div class="container">

<table style="width: 100%;"><tr>
<td>eval.monfd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Values of a Monotone Functional Data Object
</h2>

<h3>Description</h3>

<p>Evaluate a monotone functional data object at specified argument
values, or evaluate a derivative of the functional object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval.monfd(evalarg, Wfdobj, Lfdobj=int2Lfd(0), returnMatrix=FALSE)
## S3 method for class 'monfd'
predict(object, newdata=NULL, Lfdobj=0, returnMatrix=FALSE, ...)
## S3 method for class 'monfd'
fitted(object, ...)
## S3 method for class 'monfd'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>evalarg, newdata</code></td>
<td>

<p>a vector of argument values at which the functional data object is
to be evaluated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Wfdobj</code></td>
<td>

<p>an object of class <code>fd</code> that defines the monotone function
to be evaluated.  Only univariate functions are permitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lfdobj</code></td>
<td>

<p>a nonnegative integer specifying a derivative to be evaluated.  At
this time of writing, permissible derivative values are 0, 1, 2, or
3.  A linear differential operator is not allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object of class <code>monfd</code> that defines the monotone function
to be evaluated.  Only univariate functions are permitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>optional arguments required by <code>predict</code>;  not currently used.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A monotone function data object $h(t)$ is defined by $h(t) = [D^{-1}
exp Wfdobj](t)$.  In this equation, the operator  $D^{-1}$ means
taking the indefinite integral of the function to which it applies.
Note that this equation implies that the monotone function has a value
of zero at the lower limit of the arguments.  To actually fit monotone
data, it will usually be necessary to estimate an intercept and a
regression coefficient to be applied to $h(t)$, usually with the least
squares regression function <code>lsfit</code>.  The function <code>Wfdobj</code>
that defines the monotone function is usually estimated by monotone
smoothing function <code>smooth.monotone.</code>
</p>
<p><code>eval.monfd</code> only computes the standardized monotone form.
<code>predict.monfd</code> computes the scaled version using
<code>with(object, beta[1] + beta[2]*eval.monfd(...))</code> if Lfdobj = 0
or beta[2]*eval.monfd(...) if Lfdobj &gt; 0.
</p>


<h3>Value</h3>

<p>a matrix containing the monotone function values.  The first dimension
corresponds to the argument values in <code>evalarg</code> and the second to
replications.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>eval.fd</code>,
<code>smooth.monotone</code>
<code>eval.posfd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">oldpar &lt;- par(no.readonly=TRUE)
#  Estimate the acceleration functions for growth curves
#  See the analyses of the growth data.
#  Set up the ages of height measurements for Berkeley data
age &lt;- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
#  Range of observations
rng &lt;- c(1,18)
#  First set up a basis for monotone smooth
#  We use b-spline basis functions of order 6
#  Knots are positioned at the ages of observation.
norder &lt;- 6
nage   &lt;- length(age)
nbasis &lt;- nage + norder - 2
wbasis &lt;- create.bspline.basis(rng, nbasis, norder, age)
#  starting values for coefficient
cvec0 &lt;- matrix(0,nbasis,1)
Wfd0  &lt;- fd(cvec0, wbasis)
#  set up functional parameter object
Lfdobj    &lt;- 3          #  penalize curvature of acceleration
lambda    &lt;- 10^(-0.5)  #  smoothing parameter
growfdPar &lt;- fdPar(Wfd0, Lfdobj, lambda)
#  Smooth the data for the first girl
hgt1 &lt;- growth$hgtf[,1]
#   set conv = 0.1 and iterlim=1 to reduce the compute time
#   required for this test on CRAN;
#   We would not do this normally.
result &lt;- smooth.monotone(age, hgt1, growfdPar, conv=0.1,
                          iterlim=1)
#  Extract the functional data object and regression
#  coefficients
Wfd  &lt;- result$Wfdobj
beta &lt;- result$beta
#  Evaluate the fitted height curve over a fine mesh
agefine &lt;- seq(1,18,len=60)
hgtfine &lt;- beta[1] + beta[2]*eval.monfd(agefine, Wfd)
#  Plot the data and the curve
plot(age, hgt1, type="p")
lines(agefine, hgtfine)
#  Evaluate the acceleration curve
accfine &lt;- beta[2]*eval.monfd(agefine, Wfd, 2)
#  Plot the acceleration curve
plot(agefine, accfine, type="l")
lines(c(1,18),c(0,0),lty=4)

##
## using predict.monfd
##
hgtfit &lt;- with(result, beta[1]+beta[2]*eval.monfd(argvals, Wfdobj))
hgtfit. &lt;- fitted(result)

all.equal(hgtfit, hgtfit.)


accfine. &lt;- predict(result, agefine, Lfdobj=2)

all.equal(accfine, accfine.)


growthResid &lt;- resid(result)

all.equal(growthResid, with(result, y-hgtfit.))

par(oldpar)
</code></pre>


</div>