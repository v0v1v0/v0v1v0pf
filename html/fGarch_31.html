<div class="container">

<table style="width: 100%;"><tr>
<td>garchFit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Univariate or multivariate GARCH time series fitting</h2>

<h3>Description</h3>

<p>Estimates the parameters of a univariate ARMA-GARCH/APARCH process, or
— experimentally — of a multivariate GO-GARCH process model.  The
latter uses an algorithm based on <code>fastICA()</code>, inspired from
Bernhard Pfaff's package <a href="https://CRAN.R-project.org/package=gogarch"><span class="pkg">gogarch</span></a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">garchFit(formula = ~ garch(1, 1), data,
	init.rec = c("mci", "uev"),
	delta = 2, skew = 1, shape = 4,
	cond.dist = c("norm", "snorm", "ged", "sged",
                      "std", "sstd", "snig", "QMLE"),
	include.mean = TRUE, include.delta = NULL, include.skew = NULL,
        include.shape = NULL,
        leverage = NULL, trace = TRUE,
	
	algorithm = c("nlminb", "lbfgsb", "nlminb+nm", "lbfgsb+nm"),
	hessian = c("ropt", "rcd"),
        control = list(),
        title = NULL, description = NULL, ...)

garchKappa(cond.dist = c("norm", "ged", "std", "snorm", "sged", "sstd", "snig"),
           gamma = 0, delta = 2, skew = NA, shape = NA)

.gogarchFit(formula = ~garch(1, 1), data, init.rec = c("mci", "uev"),
            delta = 2, skew = 1, shape = 4,
            cond.dist = c("norm", "snorm", "ged", "sged",
                          "std", "sstd", "snig", "QMLE"),
            include.mean = TRUE, include.delta = NULL, include.skew = NULL,
            include.shape = NULL,
            leverage = NULL, trace = TRUE,
            algorithm = c("nlminb", "lbfgsb", "nlminb+nm", "lbfgsb+nm"),
            hessian = c("ropt", "rcd"),
            control = list(),
            title = NULL, description = NULL, ...)
</code></pre>


<h3>Arguments</h3>






<table>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>

<p>a string parameter that determines the algorithm used for maximum
likelihood estimation.







</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond.dist</code></td>
<td>

<p>a character string naming the desired conditional distribution.
Valid values are <code>"dnorm"</code>, <code>"dged"</code>, <code>"dstd"</code>,
<code>"dsnorm"</code>, <code>"dsged"</code>, <code>"dsstd"</code> and
<code>"QMLE"</code>. The default value is the normal distribution.  See
Details for more information.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>control parameters, the same as used for the functions from
<code>nlminb</code>, and 'bfgs' and 'Nelder-Mead' from <code>optim</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>an optional timeSeries or data frame object containing the variables
in the model.  If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from which
<code>armaFit</code> is called.  If <code>data</code> is an univariate series, then
the series is converted into a numeric vector and the name of the
response in the formula will be neglected.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>

<p>a numeric value, the exponent <code>delta</code> of the variance recursion.
By default, this value will be fixed, otherwise the exponent will be
estimated together with the other model parameters if
<code>include.delta=FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>description</code></td>
<td>
<p>optional character string with a brief description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>

<p><code>formula</code> object describing the mean and variance equation of the
ARMA-GARCH/APARCH model.  A pure GARCH(1,1) model is selected
e.g., for <code>formula = ~garch(1,1)</code>.  To specify an
ARMA(2,1)-APARCH(1,1) process, use <code> ~ arma(2,1) + aparch(1,1)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>

<p>APARCH leverage parameter entering into the formula for calculating
the expectation value.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>

<p>a string denoting how the Hessian matrix should be evaluated,
either <code>hessian ="rcd"</code>, or <code>"ropt"</code>.  The default,
<code>"rcd"</code>  is a central difference approximation implemented
in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> and <code>"ropt"</code> uses the internal R function <code>optimhess</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.delta</code></td>
<td>
<p>a <code>logical</code> determining if the
parameter for the recursion equation <code>delta</code> will be estimated
or not.  If false, the shape parameter will be kept fixed during the
process of parameter optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.mean</code></td>
<td>

<p>this flag determines if the parameter for the mean will be estimated
or not. If <code>include.mean=TRUE</code> this will be the case, otherwise
the parameter will be kept fixed durcing the process
of parameter optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.shape</code></td>
<td>

<p>a logical flag which determines if the parameter for the shape
of the conditional distribution will be estimated or not. If
<code>include.shape=FALSE</code> then the shape parameter will be kept
fixed during the process of parameter optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.skew</code></td>
<td>

<p>a logical flag which determines if the parameter for the skewness
of the conditional distribution will be estimated or not. If
<code>include.skew=FALSE</code> then the skewness parameter will be kept
fixed during the process of parameter optimization.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init.rec</code></td>
<td>

<p>a character string indicating the method how to initialize the
mean and varaince recursion relation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leverage</code></td>
<td>

<p>a logical flag for APARCH models. Should the model be leveraged?
By default <code>leverage=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shape</code></td>
<td>

<p>a numeric value, the shape parameter of the conditional distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skew</code></td>
<td>

<p>a numeric value, the skewness parameter of the conditional
distribution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>

<p>a logical flag. Should the optimization process of fitting the
model parameters be printed? By default <code>trace=TRUE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>additional arguments to be passed.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>"QMLE"</code> stands for Quasi-Maximum Likelihood Estimation, which
assumes normal distribution and uses robust standard errors for
inference. Bollerslev and Wooldridge (1992) proved that if the mean
and the volatility equations are correctly specified, the QML
estimates are consistent and asymptotically normally
distributed. However, the estimates are not efficient and “the
efficiency loss can be marked under asymmetric ... distributions”
(Bollerslev and Wooldridge (1992), p. 166). The robust
variance-covariance matrix of the estimates equals the (Eicker-White)
sandwich estimator, i.e.
</p>
<p style="text-align: center;"><code class="reqn">V = H^{-1} G^{\prime} G H^{-1},</code>
</p>

<p>where <code class="reqn">V</code> denotes the variance-covariance matrix, <code class="reqn">H</code>
stands for the Hessian and <code class="reqn">G</code> represents the matrix of
contributions to the gradient, the elements of which are defined as
</p>
<p style="text-align: center;"><code class="reqn">G_{t,i} = \frac{\partial l_{t}}{\partial \zeta_{i}},</code>
</p>

<p>where <code class="reqn">t_{t}</code> is the log likelihood of the t-th observation
and <code class="reqn">\zeta_{i}</code> is the i-th estimated parameter. See
sections 10.3 and 10.4 in Davidson and MacKinnon (2004) for a more
detailed description of the robust variance-covariance matrix.
</p>


<h3>Value</h3>

<p>for <code>garchFit</code>, an S4 object of class <code>"fGARCH"</code>.
Slot <code>@fit</code> contains the results from the optimization.
</p>
<p>for <code>.gogarchFit()</code>: Similar definition for GO-GARCH modeling.
Here, <code>data</code> must be <em>multivariate</em>.  Still
“preliminary”, mostly undocumented, and untested(!).  At least
mentioned here...
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port,<br>
R Core Team for the 'optim' <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port,<br>
Douglas Bates and Deepayan Sarkar for the 'nlminb' <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port,<br>
Bell-Labs for the underlying PORT Library,<br>
Ladislav Luksan for the underlying Fortran SQP Routine, <br>
Zhu, Byrd, Lu-Chen and Nocedal for the underlying L-BFGS-B Routine.
</p>
<p>Martin Maechler for cleaning up; <em>mentioning</em>
<code>.gogarchFit()</code>.
</p>


<h3>References</h3>

<p>ATT (1984);
<em>PORT Library Documentation</em>,
http://netlib.bell-labs.com/netlib/port/.
</p>
<p>Bera A.K., Higgins M.L. (1993);
<em>ARCH Models: Properties, Estimation and Testing</em>,
J. Economic Surveys 7, 305–362.
</p>
<p>Bollerslev T. (1986);
<em>Generalized Autoregressive Conditional Heteroscedasticity</em>,
Journal of Econometrics 31, 307–327.
</p>
<p>Bollerslev T., Wooldridge J.M. (1992);
<em>Quasi-Maximum Likelihood Estimation and Inference in Dynamic
Models with Time-Varying Covariance</em>,
Econometric Reviews 11, 143–172.
</p>
<p>Byrd R.H., Lu P., Nocedal J., Zhu C. (1995);
<em>A Limited Memory Algorithm for Bound Constrained Optimization</em>,
SIAM Journal of Scientific Computing 16, 1190–1208.
</p>
<p>Davidson R., MacKinnon J.G. (2004);
<em>Econometric Theory and Methods</em>,
Oxford University Press, New York.
</p>
<p>Engle R.F. (1982);
<em>Autoregressive Conditional Heteroscedasticity with Estimates
of the Variance of United Kingdom Inflation</em>,
Econometrica 50, 987–1008.
</p>
<p>Nash J.C. (1990);
<em>Compact Numerical Methods for Computers</em>,
Linear Algebra and Function Minimisation,
Adam Hilger.
</p>
<p>Nelder J.A., Mead R. (1965);
<em>A Simplex Algorithm for Function Minimization</em>,
Computer Journal 7, 308–313.
</p>
<p>Nocedal J., Wright S.J. (1999);
<em>Numerical Optimization</em>,
Springer, New York.
</p>


<h3>See Also</h3>

<p><code>garchSpec</code>,
<code>garchFitControl</code>,
class <code>"fGARCH"</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## UNIVARIATE TIME SERIES INPUT:
   # In the univariate case the lhs formula has not to be specified ...

   # A numeric Vector from default GARCH(1,1) - fix the seed:
   N = 200
   x.vec = as.vector(garchSim(garchSpec(rseed = 1985), n = N)[,1])
   garchFit(~ garch(1,1), data = x.vec, trace = FALSE)

   # An univariate timeSeries object with dummy dates:
   stopifnot(require("timeSeries"))
   x.timeSeries = dummyDailySeries(matrix(x.vec), units = "GARCH11")
   garchFit(~ garch(1,1), data = x.timeSeries, trace = FALSE)

## Not run: 
   # An univariate zoo object:
   require("zoo")
   x.zoo = zoo(as.vector(x.vec), order.by = as.Date(rownames(x.timeSeries)))
   garchFit(~ garch(1,1), data = x.zoo, trace = FALSE)

## End(Not run)

   # An univariate "ts" object:
   x.ts = as.ts(x.vec)
   garchFit(~ garch(1,1), data = x.ts, trace = FALSE)

## MULTIVARIATE TIME SERIES INPUT:
   # For multivariate data inputs the lhs formula must be specified ...

   # A numeric matrix binded with dummy random normal variates:
   X.mat = cbind(GARCH11 = x.vec, R = rnorm(N))
   garchFit(GARCH11 ~ garch(1,1), data = X.mat)

   # A multivariate timeSeries object with dummy dates:
   X.timeSeries = dummyDailySeries(X.mat, units = c("GARCH11", "R"))
   garchFit(GARCH11 ~ garch(1,1), data = X.timeSeries)

## Not run: 
   # A multivariate zoo object:
   X.zoo = zoo(X.mat, order.by = as.Date(rownames(x.timeSeries)))
   garchFit(GARCH11 ~ garch(1,1), data = X.zoo)

## End(Not run)

   # A multivariate "mts" object:
   X.mts = as.ts(X.mat)
   garchFit(GARCH11 ~ garch(1,1), data = X.mts)

## MODELING THE PERCENTUAL SPI/SBI SPREAD FROM LPP BENCHMARK:

   stopifnot(require("timeSeries"))
   X.timeSeries = as.timeSeries(data(LPP2005REC))
   X.mat = as.matrix(X.timeSeries)
   ## Not run: X.zoo = zoo(X.mat, order.by = as.Date(rownames(X.mat)))
   X.mts = ts(X.mat)
   garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.timeSeries)
   # The remaining are not yet supported ...
   # garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.mat)
   # garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.zoo)
   # garchFit(100*(SPI - SBI) ~ garch(1,1), data = X.mts)

## MODELING HIGH/LOW RETURN SPREADS FROM MSFT PRICE SERIES:

   X.timeSeries = MSFT
   garchFit(Open ~ garch(1,1), data = returns(X.timeSeries))
   garchFit(100*(High-Low) ~ garch(1,1), data = returns(X.timeSeries))

## GO-GARCH Modelling  (not yet!!) % FIXME

  ## data(DowJones30, package="fEcofin") # no longer exists
  ## X = returns(as.timeSeries(DowJones30)); head(X)
  ## N = 5; ans = .gogarchFit(data = X[, 1:N], trace = FALSE); ans
  ## ans@h.t

</code></pre>


</div>