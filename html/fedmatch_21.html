<div class="container">

<table style="width: 100%;"><tr>
<td>tier_match</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform an iterative match by tier</h2>

<h3>Description</h3>

<p>Constructs a tier_match by running <code>merge_plus</code> with different parameters sequentially
on the same data. Allows for sequential removal of observations after each tier.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tier_match(
  data1,
  data2,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  suffixes = c("_1", "_2"),
  check_merge = TRUE,
  unique_key_1,
  unique_key_2,
  tiers = list(),
  takeout = "both",
  match_type = "exact",
  clean = FALSE,
  clean_settings = build_clean_settings(),
  score_settings = NULL,
  filter = NULL,
  filter.args = list(),
  evaluate = match_evaluate,
  evaluate.args = list(),
  allow.cartesian = TRUE,
  fuzzy_settings = build_fuzzy_settings(),
  multivar_settings = build_multivar_settings(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data1</code></td>
<td>
<p>data.frame. First to-merge dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data2</code></td>
<td>
<p>data.frame. Second to-merge dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>character string. Variables to merge on (common across data 1 and data 2). See <code>merge</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.x</code></td>
<td>
<p>character string. Variable to merge on in data1. See <code>merge</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.y</code></td>
<td>
<p>character string. Variable to merge on in data2. See <code>merge</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffixes</code></td>
<td>
<p>see <code>merge</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_merge</code></td>
<td>
<p>logical. Checks that your unique_keys are indeed unique, and prevents merge from running if merge would result in data.frames larger than 5 million rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique_key_1</code></td>
<td>
<p>character vector. Primary key of data1 that uniquely identifies each row (can be multiple fields)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique_key_2</code></td>
<td>
<p>character vector. Primary key of data2 that uniquely identifies each row (can be multiple fields)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiers</code></td>
<td>
<p>list(). tier is a list of lists, where each list holds the parameters for creating that tier. All arguments to tier_match listed after this argument can either be supplied directly to tier_match, or indirectly via tiers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>takeout</code></td>
<td>
<p>character vector, either 'data1', 'data2', 'both', or 'neither'. Removes observations after each tier from the selected dataset.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match_type</code></td>
<td>
<p>string. If 'exact', match is exact, if 'fuzzy', match is fuzzy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean</code></td>
<td>
<p>Boolean, T/F, whether or not to clean strings prior to the match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean_settings</code></td>
<td>
<p>list. Settings for string cleaning. See <code>clean_strings</code> and <code>build_clean_settings</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score_settings</code></td>
<td>
<p>list. Settings for post-hoc matchscoring. See <code>build_score_settings</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>function or numeric. Filters a merged data1-data2 dataset. If a function, should take in
a data.frame (data1 and data2 merged by name1 and name2) and spit out a trimmed version
of the data.frame (fewer rows). Think of this function as applying other conditions
to matches, other than a match by name. The first argument of filter should be the data.frame.
If numeric, will drop all observations with a matchscore lower than or equal to filter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.args</code></td>
<td>
<p>list. Arguments passed to filter, if a function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate</code></td>
<td>
<p>Function to evaluate merge_plus output. see <code>evaluate_match</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate.args</code></td>
<td>
<p>list. Arguments passed to function specified by evaluate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow.cartesian</code></td>
<td>
<p>whether or not to allow many-many matches, see data.table::merge()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fuzzy_settings</code></td>
<td>
<p>additional arguments for amatch, to be used if match_type = 'fuzzy'. Suggested defaults provided. (see amatch, method='jw')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multivar_settings</code></td>
<td>
<p>list of settings to go to the multivar match if match_type
== 'multivar'. See <code>multivar-match</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>boolean, whether or not to print tier names and time to match each tier as the matching happens.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See the tier match vignette to get a clear understanding of the tier_match syntax.
</p>


<h3>Value</h3>

<p>list with matches, data1 and data2 minus matches, and match evaluation
</p>


<h3>See Also</h3>

<p>merge_plus clean_strings
</p>


</div>