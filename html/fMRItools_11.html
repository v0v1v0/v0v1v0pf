<div class="container">

<table style="width: 100%;"><tr>
<td>CompCor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Anatomical CompCor</h2>

<h3>Description</h3>

<p>The aCompCor algorithm for denoising fMRI data using noise ROIs data
</p>


<h3>Usage</h3>

<pre><code class="language-R">CompCor(
  X,
  ROI_data = "infer",
  ROI_noise = NULL,
  noise_nPC = 5,
  noise_erosion = NULL,
  center = TRUE,
  scale = TRUE,
  nuisance = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Wide numeric data matrix (<code class="reqn">T observations</code> by <code class="reqn">V variables</code>, <code class="reqn">T &lt;&lt; V</code>).
For example, if <code>X</code> represents an fMRI run, <code class="reqn">T</code> should be the number
of timepoints and <code class="reqn">V</code> should be the number of brainordinate vertices/voxels.
</p>
<p>Or, a 4D array or NIFTI or file path to a NIFTI (<code class="reqn">I</code> by <code class="reqn">J</code> by <code class="reqn">K</code> by <code class="reqn">T</code>
observations), in which case <code>ROI_data</code> must be provided.
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{in-mask} voxels</code>)
</p>
<p>Or, a <code>ciftiTools</code> <code>"xifti"</code> object or a file path to a CIFTI
(The vectorized data will be <code class="reqn">T timepoints</code> by <code class="reqn">V_{left+right+sub} grayordinates</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ROI_data</code></td>
<td>
<p>Indicates the data ROI. Allowed arguments depend on <code>X</code>:
</p>
<p>If <code>X</code> is a matrix, this must be a length <code class="reqn">V</code> logical vector, where
the data ROI is indicated by <code>TRUE</code> values. If <code>"infer"</code> (default), all
columns of <code>X</code> will be included in the data ROI (<code>rep(TRUE, V)</code>).
</p>
<p>If <code>X</code> is an array or NIFTI, this must be either a vector of values
to expect for out-of-mask voxels in <code>X</code>, or a (file path to a) 3D NIFTI.
In the latter case, each of the volume dimensions should match the first
three dimensions of <code>X</code>. Voxels in the data ROI should be indicated by
<code>TRUE</code> and all other voxels by <code>FALSE</code>. If <code>"infer"</code> (default),
will be set to <code>c(0, NA, NaN)</code> (include all voxels which are not constant
<code>0</code>, <code>NA</code>, or <code>NaN</code>).
</p>
<p>If <code>X</code> is a <code>"xifti"</code> this must be the <code>brainstructures</code>
argument to <code>ciftiTools::read_cifti</code>. If <code>"infer"</code> (default),
<code>brainstructures</code> will be set to <code>"all"</code> (use both left and right
cortex vertices, and subcortical voxels).
</p>
<p>If <code>NULL</code>, the data ROI will be empty. This is useful for obtaining just
the noise ROI, if the data and noise are located in separate files.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ROI_noise</code></td>
<td>
<p>Indicates the noise ROIs for aCompCor. Should be a list where
each entry corresponds to a distinct noise ROI. The names of the list should
be the ROI names, e.g. <code>"white_matter"</code> and <code>"csf"</code>. The expected
formats of the list entries depends on <code>X</code>:
</p>
<p>For all types of <code>X</code>, <code>ROI_noise</code> entries can be a matrix of noise
ROI data. The matrix should have <code class="reqn">T</code> rows, with each column being a
data location's timeseries.
</p>
<p>If <code>X</code> is a matrix, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a length <code class="reqn">V</code> logical vector with <code>TRUE</code> values
indicating locations in <code>X</code> within that noise ROI. Since the ROIs must
not overlap, the masks must be mutually exclusive with each other, and with
<code>ROI_data</code>.
</p>
<p>If <code>X</code> is an array or NIFTI, entries can also indicate a noise ROI within <code>X</code>.
These entries must be a logical array or (file path to) a 3D NIFTI with the
same spatial dimensions as <code>X</code>, and with <code>TRUE</code> values indicating
voxels inside the noise ROI. Since the ROIs must not overlap, the masks must
be mutually exclusive with each other, and with <code>ROI_data</code>.
</p>
<p>(If <code>X</code> is a <code>"xifti"</code>, entries must be data matrices, since no
grayordinate locations in <code>X</code> are appropriate noise ROIs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_nPC</code></td>
<td>
<p>The number of principal components to compute for each noise
ROI. Alternatively, values between 0 and 1, in which case they will
represent the minimum proportion of variance explained by the PCs used for
each noise ROI. The smallest number of PCs will be used to achieve this
proportion of variance explained.
</p>
<p>Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>5</code> (compute the top 5 PCs for
each noise ROI).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise_erosion</code></td>
<td>
<p>The number of voxel layers to erode the noise ROIs by.
Should be a list or numeric vector with the same length as <code>ROI_noise</code>.
It will be matched to each ROI based on the name of each entry, or if the
names are missing, the order of entries. If it is an unnamed vector, its
elements will be recycled. Default: <code>NULL</code>, which will use a value of
0 (do not erode the noise ROIs). Note that noise erosion can only be
performed if the noise ROIs are volumetric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>center, scale</code></td>
<td>
<p>Center the columns of the noise ROI data by their medians,
and scale by their MADs? Default: <code>TRUE</code> for both. Note that this argument
affects the noise ROI data and not the data that is being cleaned with aCompCor.
Centering and scaling of the data being cleaned can be done after this function call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nuisance</code></td>
<td>
<p>Nuisance signals to regress from each data column in addition
to the noise ROI PCs. Should be a <code class="reqn">T</code> by <code class="reqn">N</code> numeric matrix where
<code class="reqn">N</code> represents the number of nuisance signals. To not perform any nuisance
regression set this argument to <code>NULL</code>, <code>0</code>, or <code>FALSE</code>.
Default: <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>First, the principal components (PCs) of each noise region of interest (ROI)
are calculated. For each ROI, voxels are centered and scaled
(can be disabled with the arguments <code>center</code> and <code>scale</code>),
and then the PCs are calculated via the singular value decomposition.
</p>
<p>Next, aCompCor is performed to remove the shared variation between the noise ROI
PCs and each location in the data. This is accomplished by a nuisance regression
using a design matrix with the noise ROI PCs, any additional regressors specified
by <code>nuisance</code>, and an intercept term. (To detrend the data and perform aCompCor
in the same regression, <code>nuisance</code> can be set to DCT bases obtained with
the function <code>dct_bases</code>.)
</p>


<h3>Value</h3>

<p>A list with entries <code>"data"</code>, <code>"noise"</code>, and potentially
<code>"ROI_data"</code>.
</p>
<p>The entry <code>"data"</code> will be a <code>V x T</code> matrix where each row corresponds to a
data location (if it was originally an array, the locations will be voxels in spatial
order). Each row will be a time series with each noise PC regressed from it. This entry
will be <code>NULL</code> if there was no data.
</p>
<p>The entry <code>"noise"</code> is a list of noise PC scores, their corresponding variance,
and their ROI mask, for each noise ROI.
</p>
<p>If the data ROI is not all <code>TRUE</code>, the entry <code>"ROI_data"</code> will have
the ROI mask for the data.
</p>


<h3>References</h3>


<ul>
<li>
<p>Behzadi, Y., Restom, K., Liau, J. &amp; Liu, T. T. A component based noise correction method (CompCor) for BOLD and perfusion based fMRI. NeuroImage 37, 90-101 (2007).
</p>
</li>
<li>
<p>Muschelli, J. et al. Reduction of motion-related artifacts in resting state fMRI using aCompCor. NeuroImage 96, 22-35 (2014).
</p>
</li>
</ul>
<h3>See Also</h3>

<p>CompCor_HCP
</p>


</div>