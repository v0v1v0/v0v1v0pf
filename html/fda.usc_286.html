<div class="container">

<table style="width: 100%;"><tr>
<td>rp.flm.statistic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Statistics for testing the functional linear model using random projections</h2>

<h3>Description</h3>

<p>Computes the Cramer-von Mises (CvM) and Kolmogorv-Smirnov (kS) statistics on
the projected process </p>
<p style="text-align: center;"><code class="reqn">T_{n,h}(u)=\frac{1}{n}\sum_{i=1}^n (Y_i-\langle
X_i,\hat \beta\rangle)1_{\{\langle X_i, h\rangle\leq u\}},</code>
</p>

<p>designed to test the goodness-of-fit of a functional linear model with
scalar response.
<code>NA</code>'s are not allowed neither in the functional covariate nor in the
scalar response.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rp.flm.statistic(proj.X, residuals, proj.X.ord = NULL, F.code = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>proj.X</code></td>
<td>
<p>matrix of size <code>c(n, n.proj)</code> containing, for each
column, the projections of the functional data <code class="reqn">X_1,\ldots,X_n</code> into a
random direction <code class="reqn">h</code>. Not required if <code>proj.X.ord</code> is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the residuals of the fitted funtional linear model,
<code class="reqn">Y_i-\langle X_i,\hat \beta\rangle</code>.
Either a vector of length <code>n</code> (same residuals for all projections) or a
matrix of size <code>c(n.proj, n)</code> (each projection has an associated set
residuals).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proj.X.ord</code></td>
<td>
<p>matrix containing the row permutations of <code>proj.X</code>
which rearranges them increasingly, for each column. So, for example
<code>proj.X[proj.X.ord[, 1], 1]</code> equals <code>sort(proj.X[, 1])</code>. If not
provided, it is computed internally.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>F.code</code></td>
<td>
<p>whether to use faster <code>FORTRAN</code> code or <code>R</code> code.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing: 
</p>
 
<ul>
<li> <p>list("statistic") a matrix of size <code>c(n.proj, 2)</code> with the the CvM (first column) and KS (second)
statistics, for the <code>n.proj</code> different projections.
</p>
</li>
<li> <p>list("proj.X.ord")the computed row permutations of <code>proj.X</code>,
useful for recycling in subsequent calls to <code>rp.flm.statistic</code> with the
same projections but different residuals. 
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Eduardo Garcia-Portugues (<a href="mailto:edgarcia@est-econ.uc3m.es">edgarcia@est-econ.uc3m.es</a>) and
Manuel Febrero-Bande (<a href="mailto:manuel.febrero@usc.es">manuel.febrero@usc.es</a>).
</p>


<h3>References</h3>

<p>Cuesta-Albertos, J.A., Garcia-Portugues, E., Febrero-Bande, M.
and Gonzalez-Manteiga, W. (2017). Goodness-of-fit tests for the functional
linear model based on randomly projected empirical processes.
arXiv:1701.08363. <a href="https://arxiv.org/abs/1701.08363">https://arxiv.org/abs/1701.08363</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Simulated example
set.seed(345678)
t &lt;- seq(0, 1, l = 101)
n &lt;- 100
X &lt;- r.ou(n = n, t = t)
beta0 &lt;- fdata(mdata = cos(2 * pi * t) - (t - 0.5)^2, argvals = t,
               rangeval = c(0,1))
Y &lt;- inprod.fdata(X, beta0) + rnorm(n, sd = 0.1)

# Linear model
mod &lt;- fregre.pc(fdataobj = X, y = Y, l = 1:3)

# Projections
proj.X1 &lt;- inprod.fdata(X, r.ou(n = 1, t = t))
proj.X2 &lt;- inprod.fdata(X, r.ou(n = 1, t = t))
proj.X12 &lt;- cbind(proj.X1, proj.X2)

# Statistics
t1 &lt;- rp.flm.statistic(proj.X = proj.X1, residuals = mod$residuals)
t2 &lt;- rp.flm.statistic(proj.X = proj.X2, residuals = mod$residuals)
t12 &lt;- rp.flm.statistic(proj.X = proj.X12, residuals = mod$residuals)
t1$statistic
t2$statistic
t12$statistic

# Recycling proj.X.ord
rp.flm.statistic(proj.X.ord = t1$proj.X.ord, residuals = mod$residuals)$statistic
t1$statistic

# Sort in the columns
cbind(proj.X12[t12$proj.X.ord[, 1], 1], proj.X12[t12$proj.X.ord[, 2], 2]) -
apply(proj.X12, 2, sort)

# FORTRAN and R code
rp.flm.statistic(proj.X = proj.X1, residuals = mod$residuals)$statistic -
rp.flm.statistic(proj.X = proj.X1, residuals = mod$residuals, 
                 F.code = FALSE)$statistic

# Matrix and vector residuals
rp.flm.statistic(proj.X = proj.X12, residuals = mod$residuals)$statistic
rp.flm.statistic(proj.X = proj.X12, 
                 residuals = rbind(mod$residuals, mod$residuals * 2))$statistic

## End(Not run)

</code></pre>


</div>