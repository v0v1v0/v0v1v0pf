<div class="container">

<table style="width: 100%;"><tr>
<td>fkf.SP</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Kalman Filtering using Sequential Processing.</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p>The <code>fkf.SP</code> function performs fast and flexible Kalman filtering using sequential processing. It is designed for efficient parameter
estimation through maximum likelihood estimation. Sequential processing (SP) is a univariate treatment of a multivariate series of observations
that increases computational efficiency over traditional Kalman filtering in the general case. SP takes the additional assumption that the
variance of disturbances in the measurement equation are independent. <code>fkf.SP</code> is based from the <code>fkf</code> function of
the <code>FKF</code> package but is, in general, a faster Kalman filtering method.
<code>fkf</code> and <code>fkf.SP</code> share identical arguments (except for the <code>GGt</code> argument, see <b>Arguments</b>). <code>fkf.SP</code> is compatible with missing observations (i.e. NA's in argument <code>yt</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">fkf.SP(
  a0,
  P0,
  dt,
  ct,
  Tt,
  Zt,
  HHt,
  GGt,
  yt,
  verbose = FALSE,
  smoothing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a0</code></td>
<td>
<p>A <code>vector</code> giving the initial value/estimation of the state variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>P0</code></td>
<td>
<p>A <code>matrix</code> giving the variance of a0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>A <code>matrix</code> giving the intercept of the transition equation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ct</code></td>
<td>
<p>A <code>matrix</code> giving the intercept of the measurement equation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Tt</code></td>
<td>
<p>An <code>array</code> giving factor of the transition equation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Zt</code></td>
<td>
<p>An <code>array</code> giving the factor of the measurement equation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>HHt</code></td>
<td>
<p>An <code>array</code> giving the variance of the innovations of the transition equation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GGt</code></td>
<td>
<p>A <code>vector</code> giving the diagonal elements of the <code>matrix</code> for the variance of disturbances of the measurement equation. Covariance between disturbances
is not supported under the sequential processing method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yt</code></td>
<td>
<p>A <code>matrix</code> containing the observations. "NA"- values are allowed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>A <code>logical</code>. When <code>verbose = TRUE</code>, A <code>list</code> object is output, which provides filtered values of the Kalman filter (see <b>Value</b>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothing</code></td>
<td>
<p>A <code>logical</code>. When <code>smoothing = TRUE</code>, Kalman smoothing is additionally performed and smoothed values returned (see <b>Value</b>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><b>Parameters</b>:
</p>
<p>The <code>fkf.SP</code> function builds upon the <code>fkf</code> function of the <code>FKF</code> package by adjusting the Kalman filtering algorithm to
utilize sequential processing. Sequential processing can result in significant decreases in processing time over the traditional Kalman filter algorithm. Sequential processing has been
empirically shown to grow linearly with respect to the dimensions of \(y_t\), rather than exponentially as is the case with the traditional Kalman filter algorithm (Aspinall et al., 2022, P104).
</p>
<p>The <code>fkf.SP</code> and <code>fkf</code> functions feature highly similar
arguments for compatibility purposes; only argument <code>GGt</code> has changed from an <code>array</code> type object to a <code>vector</code> or <code>matrix</code> type object.
The <code>fkf.SP</code> function takes the additional assumption over the <code>fkf</code> function that the variance of the disturbances of the measurement
equation are independent; a requirement of SP (see below).
</p>
<p>Parameters can either be constant or deterministic
time-varying. Assume the number of discrete time observations is \(n\)
i.e. \(y = y_t\) where \(t = 1, \cdots, n\). Let \(m\) be the
dimension of the state variable and \(d\) the dimension of the observations. Then, the parameters admit the following
classes and dimensions:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>dt</code> </td>
<td style="text-align: left;"> either a \(m \times n\) (time-varying) or a \(m \times 1\) (constant) matrix. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Tt</code> </td>
<td style="text-align: left;"> either a \(m \times m \times n\) or a \(m \times m \times 1\) array. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>HHt</code> </td>
<td style="text-align: left;"> either a \(m \times m \times n\) or a \(m \times m \times 1\) array. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>ct</code> </td>
<td style="text-align: left;"> either a \(d \times n\) or a \(d \times 1\) matrix. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Zt</code> </td>
<td style="text-align: left;"> either a \(d \times m \times n\) or a \(d \times m \times 1\) array. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>GGt</code> </td>
<td style="text-align: left;"> either a \(d \times n\) (time-varying) or a \(d \times 1\) matrix. </td>
</tr>
<tr>
<td style="text-align: left;">
<code>yt</code> </td>
<td style="text-align: left;"> a \(d \times n\) matrix.
</td>
</tr>
</table>
<p><b>State Space Form</b>
</p>
<p>The following notation follows that of Koopman <em>et al.</em> (1999). The Kalman filter is characterized by the transition and measurement equations:
</p>
\[\alpha_{t + 1} = d_t + T_t \cdot \alpha_t + H_t \cdot \eta_t\]
\[y_t = c_t + Z_t \cdot \alpha_t + G_t \cdot \epsilon_t\]
<p>where \(\eta_t\) and \(\epsilon_t\) are i.i.d.
\(N(0, I_m)\) and i.i.d. \(N(0, I_d)\),
respectively, and \(\alpha_t\) denotes the state
vector. The parameters admit the following dimensions:
</p>

<table>
<tr>
<td style="text-align: left;">
\(a_t \in R^m\) </td>
<td style="text-align: left;"> \(d_t \in R^m\) </td>
<td style="text-align: left;"> \(\eta_t \in R^m\) </td>
</tr>
<tr>
<td style="text-align: left;">
\(T_t \in R^{m \times m}\) </td>
<td style="text-align: left;"> \(H_t \in R^{m \times m}\) </td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
\(y_t \in R^d\) </td>
<td style="text-align: left;"> \(c_t \in R^d\) </td>
<td style="text-align: left;"> \(\epsilon_t \in R^d\) </td>
</tr>
<tr>
<td style="text-align: left;">
\(Z_t \in R^{d \times m}\) </td>
<td style="text-align: left;"> \(G_t \in R^{d \times d}\) </td>
<td style="text-align: left;">
</td>
</tr>
</table>
<p>Note that <code>fkf.SP</code> takes as input <code>HHt</code> and <code>GGt</code> which corresponds to \(H_t H_t'\) and
\(diag(G_t)^2\) respectively.
</p>
<p><b>Sequential Processing Iteration</b>:
</p>
<p>Traditional Kalman filtering takes the entire observational vector \(y_t\) as the items for analysis. SP
is an alternate approach that filters the elements of \(y_t\) one at a time. Sequential processing is described in the textbook of Durbin and Koopman (2001) and is described below.
</p>
<p>Let \(p\) equal the number of observations at time \(t\) (i.e. when considering possible missing observations \(p \leq {d}\)).
The SP iteration involves treating the vector series: \(y_1,\cdots,y_n\) instead as the scalar series
\(y_{1,1},\cdots,y_{(1,p)},y_{2,1},\cdots,y_{(n,p_n)}\). This univariate treatment of the multivariate series
has the advantage that the function of the covariance matrix, \(F_t\), becomes \(1 \times 1\), avoiding the calculation of both the inverse and determinant of
a \(p \times p\) matrix. This can increase computational efficiency (especially under the case of many observations, i.e. \(p\) is large)
</p>
<p>For any time point, the observation vector is given by:
</p>
\[y_t'=(y_{(t,1)},\cdots,y_{(t,p)} )\]
<p>The filtering equations are written as:
</p>
\[a_{t,i+1} = a_{t,i} + K_{t,i} v_{t,i}\]
\[P_{t,i+1} = P_{t,i} - K_{t,i} F_{t,i} K_{t,i}'\]
<p>Where:
\[\hat y_{t,i} = c_t + Z_t \cdot a_{t,i}\]
\[v_{t,i}=y_{t,i}-\hat y_{t,i}\]
\[F_{t,i} = Z_{t,i} P_{t,i} Z_{t,i}'+ GGt_{t,i}\]
\[K_{t,i} = P_{t,i} Z_{t,i}' F_{t,i}^{-1}\]
\[i = 1, \cdots, p\]
</p>
<p>Transition from time \(t\) to \(t+1\) occurs through the standard transition equations.
</p>
\[\alpha_{t + 1,1} = d_t + T_t \cdot \alpha_{t,p}\]
\[P_{t + 1,1} = T_t \cdot P_{t,p} \cdot T_t' + HHt\]
<p>The log-likelihood at time \(t\) is given by:
</p>
\[log L_t = -\frac{p}{2}log(2\pi) - \frac{1}{2}\sum_{i=1}^p(log F_i + \frac{v_i^2}{F_i})\]
<p>Where the log-likelihood of observations is:
</p>
\[log L = \sum_t^n{log L_t}\]
<p><b>Compiled Code</b>:
</p>
<p><code>fkf.SP</code> wraps the C-functions <code>fkf_SP</code>,  <code>fkf_SP_verbose</code> and  <code>fkfs_SP</code>,  which each rely upon the linear algebra subroutines of BLAS (Basic Linear Algebra Subprograms).
These C-functions are called when <code>verbose = FALSE</code>, <code>verbose = TRUE</code> and <code>smoothing = TRUE</code>, respectively.
</p>
<p>The difference in these compiled functions are in the values returned from them. The <code>fkfs_SP</code> also performs Kalman filtering and subsequently smoothing
within the singular compiled C-code function.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> value corresponding to the log-likelihood calculated by the Kalman filter. Ideal for maximum likelihood estimation through optimization routines such as <code>optim</code>.
</p>
<p>When <code>verbose = TRUE</code>, an S3 class of type 'fkf.SP' with the following elements is also returned, corresponding to the filtered state variables and covariances of the Kalman filter algorithm:
</p>

<table>
<tr>
<td style="text-align: right;">
<code>att</code> </td>
<td style="text-align: left;"> A <i>m * n</i>-matrix containing the filtered state variables, i.e. <code>att[,t]</code> = <i>a(t|t)</i>.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>at</code> </td>
<td style="text-align: left;"> A <i>m * (n + 1)</i>-matrix containing the predicted state variables, i.e. <code>at[,t]</code> = <i>a(t)</i>.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>Ptt</code> </td>
<td style="text-align: left;"> A <i>m * m * n</i>-array containing the variance of att, i.e. <code>Ptt[,,t]</code> = <i>P(t|t)</i>.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>Pt</code> </td>
<td style="text-align: left;"> A <i>m * m * (n+1)</i>-array containing the variance of at, i.e. <code>Pt[,,t]</code> = <i>P(t)</i>.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>yt</code> </td>
<td style="text-align: left;"> A <i>d * n </i>-matrix containing the input observations.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>Tt</code> </td>
<td style="text-align: left;"> either a <i>m * m * n</i> or a <i>m * m * 1</i>-array, depending on the argument provided. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>Zt</code> </td>
<td style="text-align: left;"> either a <i>d * m * n</i> or a <i>d * m * 1</i>-array, depending on the argument provided. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>Ftinv</code> </td>
<td style="text-align: left;"> A <i>d * n </i>-matrix containing the scalar inverse of the prediction error variances. </td>
</tr>
<tr>
<td style="text-align: right;">
<code>vt</code> </td>
<td style="text-align: left;"> A <i>d * n </i>-matrix containing the observation error.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>Kt</code> </td>
<td style="text-align: left;"> A <i>m * d * n </i>-array containing the Kalman gain of state variables at each observation.</td>
</tr>
<tr>
<td style="text-align: right;">
<code>logLik</code> </td>
<td style="text-align: left;"> The log-likelihood.
</td>
</tr>
</table>
<p>In addition to the elements above, the following elements corresponding to the smoothed values output from Kalman smoothing are also returned when <code>smoothing = TRUE</code>.
The <code>fks.SP</code> provides more detail regarding Kalman smoothing.
</p>

<table>
<tr>
<td style="text-align: right;">
<code>ahatt</code> </td>
<td style="text-align: left;">  A <i>m * n</i>-matrix containing the
smoothed state variables, i.e. <code>ahatt[,t]</code> = \(a_{t|n}\)</td>
</tr>
<tr>
<td style="text-align: right;">
<code>Vt</code> </td>
<td style="text-align: left;">  A <i>m * m * n</i>-array
containing the variances of <code>ahatt</code>, i.e. <code>Vt[,,t]</code> = \(P_{t|n}\)
</td>
</tr>
</table>
<p><b>Log-Likelihood Values:</b>
</p>
<p>When there are no missing observations (i.e. "NA" values) in argument <code>yt</code>, the return of function <code>fkf.SP</code> and the <code>logLik</code>
object returned within the list of function <code>fkf</code> are identical. When NA's are present, however, log-likelihood values returned
by <code>fkf.SP</code> are always higher. This is due to low bias in the log-likelihood values output by <code>fkf</code>, but does not influence parameter
estimation. Further details are available within this package's vignette.
</p>


<h3>References</h3>

<p>Aspinall, T. W., Harris, G., Gepp, A., Kelly, S., Southam, C., and Vanstone, B. (2022). <em>The Estimation of Commodity Pricing Models with Applications in Capital Investments</em>. <a href="https://research.bond.edu.au/en/studentTheses/the-estimation-of-commodity-pricing-models-with-applications-in-c">Available Online</a>.
</p>
<p>Anderson, B. D. O. and Moore. J. B. (1979). <em>Optimal Filtering</em> Englewood Cliffs: Prentice-Hall.
</p>
<p>Fahrmeir, L. and tutz, G. (1994) <em>Multivariate Statistical Modelling Based on Generalized Linear Models.</em> Berlin: Springer.
</p>
<p>Koopman, S. J., Shephard, N., Doornik, J. A. (1999). Statistical algorithms for models in state space using SsfPack 2.2. <em>Econometrics Journal</em>, Royal Economic Society, vol. 2(1), pages 107-160.
</p>
<p>Durbin, James, and Siem Jan Koopman (2001). <em>Time series analysis by state space methods.</em> Oxford university press.
</p>
<p>David Luethi, Philipp Erb and Simon Otziger (2018). FKF: Fast Kalman Filter. R package version 0.2.3.
'https://CRAN.R-project.org/package=FKF
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## &lt;-------------------------------------------------------------------------------
##Example 1 - Filter a state space model - Nile data
## &lt;-------------------------------------------------------------------------------

# Observations must be a matrix:
yt &lt;- rbind(datasets::Nile)

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- yt[1]   # Estimation of the first year flow
P0 &lt;- matrix(100)       # Variance of 'a0'
## These can be estimated through MLE:
GGt &lt;- matrix(15000)
HHt &lt;- matrix(1300)

# 'verbose' returns the filtered values:
output &lt;- fkf.SP(a0 = a0, P0 = P0, dt = dt, ct = ct,
               Tt = Tt, Zt = Zt, HHt = HHt, GGt = GGt,
               yt = yt, verbose = TRUE)


## &lt;-------------------------------------------------------------------------------
##Example 2 - ARMA(2,1) model estimation.
## &lt;-------------------------------------------------------------------------------

#Length of series
n &lt;- 1000

#AR parameters
AR &lt;- c(ar1 = 0.6, ar2 = 0.2, ma1 = -0.2, sigma = sqrt(0.2))

## Sample from an ARMA(2, 1) process
a &lt;- stats::arima.sim(model = list(ar = AR[c("ar1", "ar2")], ma = AR["ma1"]), n = n,
innov = rnorm(n) * AR["sigma"])

##State space representation of the four ARMA parameters
arma21ss &lt;- function(ar1, ar2, ma1, sigma) {
Tt &lt;- matrix(c(ar1, ar2, 1, 0), ncol = 2)
Zt &lt;- matrix(c(1, 0), ncol = 2)
ct &lt;- matrix(0)
dt &lt;- matrix(0, nrow = 2)
GGt &lt;- matrix(0)
H &lt;- matrix(c(1, ma1), nrow = 2) * sigma
HHt &lt;- H %*% t(H)
a0 &lt;- c(0, 0)
P0 &lt;- matrix(1e6, nrow = 2, ncol = 2)
return(list(a0 = a0, P0 = P0, ct = ct, dt = dt, Zt = Zt, Tt = Tt, GGt = GGt,
            HHt = HHt))
            }

## The objective function passed to 'optim'
objective &lt;- function(theta, yt) {
sp &lt;- arma21ss(theta["ar1"], theta["ar2"], theta["ma1"], theta["sigma"])
 ans &lt;- fkf.SP(a0 = sp$a0, P0 = sp$P0, dt = sp$dt, ct = sp$ct, Tt = sp$Tt,
               Zt = sp$Zt, HHt = sp$HHt, GGt = sp$GGt, yt = yt)
 return(-ans)
}

## Parameter estimation - maximum likelihood estimation:
theta &lt;- c(ar = c(0, 0), ma1 = 0, sigma = 1)
ARMA_MLE &lt;- optim(theta, objective, yt = rbind(a), hessian = TRUE)


## &lt;-------------------------------------------------------------------------------
#Example 3 - Nile Model Estimation:
## &lt;-------------------------------------------------------------------------------

#Nile's annual flow:
yt &lt;- rbind(Nile)

##Incomplete Nile Data - two NA's are present:
yt[c(3, 10)] &lt;- NA

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- yt[1]   # Estimation of the first year flow
P0 &lt;- matrix(100)       # Variance of 'a0'

## Parameter estimation - maximum likelihood estimation:
##Unknown parameters initial estimates:
GGt &lt;- HHt &lt;- var(c(yt), na.rm = TRUE) * .5
#Perform maximum likelihood estimation
Nile_MLE &lt;- optim(c(HHt = HHt, GGt = GGt),
                fn = function(par, ...)
                -fkf.SP(HHt = matrix(par[1]), GGt = matrix(par[2]), ...),
                yt = yt, a0 = a0, P0 = P0, dt = dt, ct = ct,
                Zt = Zt, Tt = Tt)
## &lt;-------------------------------------------------------------------------------
#Example 4 - Dimensionless Treering Example:
## &lt;-------------------------------------------------------------------------------


## tree-ring widths in dimensionless units
y &lt;- treering

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- y[1]            # Estimation of the first width
P0 &lt;- matrix(100)     # Variance of 'a0'

## Parameter estimation - maximum likelihood estimation:
Treering_MLE &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                 GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                -fkf.SP(HHt = array(par[1],c(1,1,1)), GGt = matrix(par[2]), ...),
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

</code></pre>


</div>