<div class="container">

<table style="width: 100%;"><tr>
<td>fastglmPure</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>fast generalized linear model fitting</h2>

<h3>Description</h3>

<p>fast generalized linear model fitting
</p>


<h3>Usage</h3>

<pre><code class="language-R">fastglmPure(
  x,
  y,
  family = gaussian(),
  weights = rep(1, NROW(y)),
  offset = rep(0, NROW(y)),
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  method = 0L,
  tol = 1e-07,
  maxit = 100L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>input model matrix. Must be a matrix object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>numeric response vector of length nobs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. 
For <code>fastglmPure</code> this can only be the result of a call to a family function. 
(See <code>family</code> for details of family functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. Should be a numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. 
This should be a numeric vector of length equal to the number of cases</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mustart</code></td>
<td>
<p>values for the vector of means.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>an integer scalar with value 0 for the column-pivoted QR decomposition, 1 for the unpivoted QR decomposition,
2 for the LLT Cholesky, 3 for the LDLT Cholesky, 4 for the full pivoted QR decomposition, 5 for the Bidiagonal Divide and 
Conquer SVD</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>threshold tolerance for convergence. Should be a positive real number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>maximum number of IRLS iterations. Should be an integer</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the elements
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>a vector of coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>a vector of the standard errors of the coefficient estimates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rank</code></td>
<td>
<p>a scalar denoting the computed rank of the model matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df.residual</code></td>
<td>
<p>a scalar denoting the degrees of freedom in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>the vector of residuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>a numeric scalar - the root mean square for residuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>the vector of fitted values</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">
set.seed(1)
x &lt;- matrix(rnorm(1000 * 25), ncol = 25)
eta &lt;- 0.1 + 0.25 * x[,1] - 0.25 * x[,3] + 0.75 * x[,5] -0.35 * x[,6] #0.25 * x[,1] - 0.25 * x[,3]
y &lt;- 1 * (eta &gt; rnorm(1000))

yp &lt;- rpois(1000, eta ^ 2)
yg &lt;- rgamma(1000, exp(eta) * 1.75, 1.75)

# binomial
system.time(gl1 &lt;- glm.fit(x, y, family = binomial()))

system.time(gf1 &lt;- fastglmPure(x, y, family = binomial(), tol = 1e-8))

system.time(gf2 &lt;- fastglmPure(x, y, family = binomial(), method = 1, tol = 1e-8))

system.time(gf3 &lt;- fastglmPure(x, y, family = binomial(), method = 2, tol = 1e-8))

system.time(gf4 &lt;- fastglmPure(x, y, family = binomial(), method = 3, tol = 1e-8))

max(abs(coef(gl1) - gf1$coef))
max(abs(coef(gl1) - gf2$coef))
max(abs(coef(gl1) - gf3$coef))
max(abs(coef(gl1) - gf4$coef))

# poisson
system.time(gl1 &lt;- glm.fit(x, yp, family = poisson(link = "log")))

system.time(gf1 &lt;- fastglmPure(x, yp, family = poisson(link = "log"), tol = 1e-8))

system.time(gf2 &lt;- fastglmPure(x, yp, family = poisson(link = "log"), method = 1, tol = 1e-8))

system.time(gf3 &lt;- fastglmPure(x, yp, family = poisson(link = "log"), method = 2, tol = 1e-8))

system.time(gf4 &lt;- fastglmPure(x, yp, family = poisson(link = "log"), method = 3, tol = 1e-8))

max(abs(coef(gl1) - gf1$coef))
max(abs(coef(gl1) - gf2$coef))
max(abs(coef(gl1) - gf3$coef))
max(abs(coef(gl1) - gf4$coef))

# gamma
system.time(gl1 &lt;- glm.fit(x, yg, family = Gamma(link = "log")))

system.time(gf1 &lt;- fastglmPure(x, yg, family = Gamma(link = "log"), tol = 1e-8))

system.time(gf2 &lt;- fastglmPure(x, yg, family = Gamma(link = "log"), method = 1, tol = 1e-8))

system.time(gf3 &lt;- fastglmPure(x, yg, family = Gamma(link = "log"), method = 2, tol = 1e-8))

system.time(gf4 &lt;- fastglmPure(x, yg, family = Gamma(link = "log"), method = 3, tol = 1e-8))

max(abs(coef(gl1) - gf1$coef))
max(abs(coef(gl1) - gf2$coef))
max(abs(coef(gl1) - gf3$coef))
max(abs(coef(gl1) - gf4$coef))

</code></pre>


</div>