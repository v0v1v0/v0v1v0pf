<div class="container">

<table style="width: 100%;"><tr>
<td>FMGM_mc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Main function of fused MGM</h2>

<h3>Description</h3>

<p>Infers networks from 2-class mixed data
</p>


<h3>Usage</h3>

<pre><code class="language-R">FMGM_mc(
  data,
  ind_disc,
  group,
  t = 1,
  L = NULL,
  eta = 2,
  lambda_intra,
  lambda_intra_prior = NULL,
  lambda_inter,
  with_prior = FALSE,
  prior_list = NULL,
  converge_by_edge = TRUE,
  tol_edge = 3,
  tol_mgm = 1e-04,
  tol_g = 0.005,
  tol_fpa = 1e-12,
  maxit = 1e+06,
  polish = TRUE,
  tol_polish = 1e-12,
  cores = parallel::detectCores(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame with rows as observations and columns as variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind_disc</code></td>
<td>
<p>Indices of discrete variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>Group indices, must be provided with the observation names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t</code></td>
<td>
<p>Numeric. Initial value of coefficient that reflect 2 previous iterations in fast proximal gradient method. Default: 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Numeric. Initial guess of Lipschitz constant. Default: missing (use backtracking)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>Numeric. Multipliers for L in backtracking. Default: 2</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_intra</code></td>
<td>
<p>Vector with 3 numeric variables. Penalization parameters for network edge weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_intra_prior</code></td>
<td>
<p>Vector with 3 numeric variables. Penalization parameters for network edge weights, applied to the edges with prior information</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_inter</code></td>
<td>
<p>Vector with 3 numeric variables. Penalization parameters for network edge weight differences</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_prior</code></td>
<td>
<p>Logical. Is prior information provided? Default: FALSE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior_list</code></td>
<td>
<p>List of prior information. Each element must be a 3-column data frames, with the 1st and the 2nd columns being variable names and the 3rd column being prior confidence (0,1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converge_by_edge</code></td>
<td>
<p>Logical. The convergence should be judged by null differences of network edges after iteration. If FALSE, the rooted mean square difference (RMSD) of edge weights is used. Default: TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_edge</code></td>
<td>
<p>Integer. Number of consecutive iterations of convergence to stop the iteration. Default: 3</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_mgm</code></td>
<td>
<p>Numeric. Cutoff of network edge RMSD for convergence. Default: 1e-04</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_g</code></td>
<td>
<p>Numeric. Cutoff of iternations in prox-grad map calculation. Default: 5e-03</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_fpa</code></td>
<td>
<p>Numeric. Cutoff for fixed-point approach. Default: 1e-12</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>Integer. Maximum number of iterations in fixed-point approach. Default: 1000000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>polish</code></td>
<td>
<p>Logical. Should the edges with the weights below the cutoff should be discarded? Default: TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol_polish</code></td>
<td>
<p>Numeric. Cutoff of polishing the resulting network. Default: 1e-12</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Integer. Number of cores to use multi-core utilization. Default: maximum number of available cores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical. If TRUE, the procedures are reported in real-time manner. Default: FALSE</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If the value of Lipschitz constant, L, is not provided, the backtracking will be performed
</p>


<h3>Value</h3>

<p>The resulting networks, in the form of a list of MGMs
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(data_all) ;  # Example 500-by-100 simulation data
data(ind_disc) ;

group &lt;- rep(c(1,2), each=250) ;
names(group) &lt;- seq(500) ;

if (Sys.info()['sysname'] == 'Windows') {
  cores=1
} else {
  cores=parallel::detectCores() ;
}

res_FMGM &lt;- FMGM_mc(data_all, ind_disc, group, 
                    lambda_intra=c(0.2,0.15,0.1), lambda_inter=c(0.2,0.15,0.1), 
                    cores=cores, verbose=TRUE)

</code></pre>


</div>