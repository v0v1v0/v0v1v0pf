<div class="container">

<table style="width: 100%;"><tr>
<td>fnn.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fitting Functional Neural Networks</h2>

<h3>Description</h3>

<p>This is the main function in the <code>FuncNN</code> package. This function fits models of the form: f(z, b(x)) where
z are the scalar covariates and b(x) are the functional covariates. The form of f() is that of a neural network
with a generalized input space.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fnn.fit(
  resp,
  func_cov,
  scalar_cov = NULL,
  basis_choice = c("fourier"),
  num_basis = c(7),
  hidden_layers = 2,
  neurons_per_layer = c(64, 64),
  activations_in_layers = c("sigmoid", "linear"),
  domain_range = list(c(0, 1)),
  epochs = 100,
  loss_choice = "mse",
  metric_choice = list("mean_squared_error"),
  val_split = 0.2,
  learn_rate = 0.001,
  patience_param = 15,
  early_stopping = TRUE,
  print_info = TRUE,
  batch_size = 32,
  decay_rate = 0,
  func_resp_method = 1,
  covariate_scaling = TRUE,
  raw_data = FALSE,
  dropout = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>resp</code></td>
<td>
<p>For scalar responses, this is a vector of the observed dependent variable. For functional responses,
this is a matrix where each row contains the basis coefficients defining the functional response (for each observation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func_cov</code></td>
<td>
<p>The form of this depends on whether the <code>raw_data</code> argument is true or not. If true, then this is
a list of k matrices. The dimensionality of the matrices should be the same (n x p) where n is the number of
observations and p is the number of longitudinal observations. If <code>raw_data</code> is false, then the input should be a tensor
with dimensionality b x n x k where b is the number of basis functions used to define the functional covariates, n is
the number of observations, and k is the number of functional covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scalar_cov</code></td>
<td>
<p>A matrix contained the multivariate information associated with the data set. This is all of your
non-longitudinal data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis_choice</code></td>
<td>
<p>A vector of size k (the number of functional covariates) with either "fourier" or "bspline" as the inputs.
This is the choice for the basis functions used for the functional weight expansion. If you only specify one, with k &gt; 1,
then the argument will repeat that choice for all k functional covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_basis</code></td>
<td>
<p>A vector of size k defining the number of basis functions to be used in the basis expansion. Must be odd
for <code>fourier</code> basis choices. If you only specify one, with k &gt; 1, then the argument will repeat that choice for all
k functional covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden_layers</code></td>
<td>
<p>The number of hidden layers to be used in the neural network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neurons_per_layer</code></td>
<td>
<p>Vector of size = <code>hidden_layers</code>. The u-th element of the vector corresponds to the number of neurons
in the u-th hidden layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activations_in_layers</code></td>
<td>
<p>Vector of size = <code>hidden_layers</code>. The u-th element of the vector corresponds to the
activation choice in the u-th hidden layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain_range</code></td>
<td>
<p>List of size k. Each element of the list is a 2-dimensional vector containing the upper and lower
bounds of the k-th functional weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochs</code></td>
<td>
<p>The number of training iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss_choice</code></td>
<td>
<p>This parameter defines the loss function used in the learning process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric_choice</code></td>
<td>
<p>This parameter defines the printed out error metric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>val_split</code></td>
<td>
<p>A parameter that decides the percentage split of the inputted data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learn_rate</code></td>
<td>
<p>Hyperparameter that defines how quickly you move in the direction of the gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patience_param</code></td>
<td>
<p>A keras parameter that decides how many additional <code>epochs</code> are eclipsed with minimal change in
error before the learning process is stopped. This is only active if <code>early_stopping = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stopping</code></td>
<td>
<p>If TRUE, then learning process will be halted early if error improvement isn't seen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_info</code></td>
<td>
<p>If TRUE, function will output information about the model as it is trained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p>Size of the batch for stochastic gradient descent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decay_rate</code></td>
<td>
<p>A modification to the learning rate that decreases the learning rate as more and more learning
iterations are completed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func_resp_method</code></td>
<td>
<p>Set to 1 by default. In the future, this will be set to 2 for an alternative functional response
approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate_scaling</code></td>
<td>
<p>If TRUE, then data will be internally scaled before model development.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw_data</code></td>
<td>
<p>If TRUE, then user does not need to create functional observations beforehand. The function will
internally take care of that pre-processing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropout</code></td>
<td>
<p>Keras parameter that randomly drops some percentage of the neurons in a given layer.
If TRUE, then 0.1*layer_number will be dropped; instead, you can specify a vector equal to the number
of layers specifying what percentage to drop in each layer.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Updates coming soon.
</p>


<h3>Value</h3>

<p>The following are returned:
</p>
<p><code>model</code> – Full keras model that can be used with any functions that act on keras models.
</p>
<p><code>data</code> – Adjust data set after scaling and appending of scalar covariates.
</p>
<p><code>fnc_basis_num</code> – A return of the original input; describes the number of functions used in each of the k basis expansions.
</p>
<p><code>fnc_type</code> – A return of the original input; describes the basis expansion used to make the functional weights.
</p>
<p><code>parameter_info</code> – Information associated with hyperparameter choices in the model.
</p>
<p><code>per_iter_info</code> – Change in error over training iterations
</p>
<p><code>func_obs</code> – In the case when <code>raw_data</code> is <code>TRUE</code>, the user may want to see the internally developed functional observations.
This returns those functions.
</p>


<h3>Examples</h3>

<pre><code class="language-R"> 
# First, an easy example with raw_data = TRUE


# Loading in data
data("daily")

# Functional covariates (subsetting for time sake)
precip = t(daily$precav)
longtidunal_dat = list(precip)

# Scalar Response
total_prec = apply(daily$precav, 2, mean)

# Running model
fit1 = fnn.fit(resp = total_prec,
               func_cov = longtidunal_dat,
               scalar_cov = NULL,
               learn_rate = 0.0001,
               epochs = 10,
               raw_data = TRUE)
               
# Classification Example with raw_data = TRUE

# Loading data
tecator = FuncNN::tecator

# Making classification bins
tecator_resp = as.factor(ifelse(tecator$y$Fat &gt; 25, 1, 0))

# Non functional covariate
tecator_scalar = data.frame(water = tecator$y$Water)

# Splitting data
ind = sample(1:length(tecator_resp), round(0.75*length(tecator_resp)))
train_y = tecator_resp[ind]
test_y = tecator_resp[-ind]
train_x = tecator$absorp.fdata$data[ind,]
test_x = tecator$absorp.fdata$data[-ind,]
scalar_train = data.frame(tecator_scalar[ind,1])
scalar_test = data.frame(tecator_scalar[-ind,1])

# Making list element to pass in
func_covs_train = list(train_x)
func_covs_test = list(test_x)

# Now running model
fit_class = fnn.fit(resp = train_y,
                    func_cov = func_covs_train,
                    scalar_cov = scalar_train,
                    hidden_layers = 6,
                    neurons_per_layer = c(24, 24, 24, 24, 24, 58),
                    activations_in_layers = c("relu", "relu", "relu", "relu", "relu", "linear"),
                    domain_range = list(c(850, 1050)),
                    learn_rate = 0.001,
                    epochs = 100,
                    raw_data = TRUE,
                    early_stopping = TRUE)

# Running prediction, gets probabilities
predict_class = fnn.predict(fit_class,
                            func_cov = func_covs_test,
                            scalar_cov = scalar_test,
                            domain_range = list(c(850, 1050)),
                            raw_data = TRUE)

# Example with Pre-Processing (raw_data = FALSE)

# loading data
tecator = FuncNN::tecator

# libraries
library(fda)

# define the time points on which the functional predictor is observed.
timepts = tecator$absorp.fdata$argvals

# define the fourier basis
nbasis = 29
spline_basis = create.fourier.basis(tecator$absorp.fdata$rangeval, nbasis)

# convert the functional predictor into a fda object and getting deriv
tecator_fd =  Data2fd(timepts, t(tecator$absorp.fdata$data), spline_basis)
tecator_deriv = deriv.fd(tecator_fd)
tecator_deriv2 = deriv.fd(tecator_deriv)

# Non functional covariate
tecator_scalar = data.frame(water = tecator$y$Water)

# Response
tecator_resp = tecator$y$Fat

# Getting data into right format
tecator_data = array(dim = c(nbasis, length(tecator_resp), 3))
tecator_data[,,1] = tecator_fd$coefs
tecator_data[,,2] = tecator_deriv$coefs
tecator_data[,,3] = tecator_deriv2$coefs

# Splitting into test and train for third FNN
ind = 1:165
tec_data_train &lt;- array(dim = c(nbasis, length(ind), 3))
tec_data_test &lt;- array(dim = c(nbasis, nrow(tecator$absorp.fdata$data) - length(ind), 3))
tec_data_train = tecator_data[, ind, ]
tec_data_test = tecator_data[, -ind, ]
tecResp_train = tecator_resp[ind]
tecResp_test = tecator_resp[-ind]
scalar_train = data.frame(tecator_scalar[ind,1])
scalar_test = data.frame(tecator_scalar[-ind,1])

# Setting up network
tecator_fnn = fnn.fit(resp = tecResp_train,
                      func_cov = tec_data_train,
                      scalar_cov = scalar_train,
                      basis_choice = c("fourier", "fourier", "fourier"),
                      num_basis = c(5, 5, 7),
                      hidden_layers = 4,
                      neurons_per_layer = c(64, 64, 64, 64),
                      activations_in_layers = c("relu", "relu", "relu", "linear"),
                      domain_range = list(c(850, 1050), c(850, 1050), c(850, 1050)),
                      epochs = 300,
                      learn_rate = 0.002)

# Prediction example can be seen with ?fnn.fit()

# Functional Response Example:

# libraries
library(fda)

# Loading data
data("daily")

# Creating functional data
temp_data = array(dim = c(65, 35, 1))
tempbasis65  = create.fourier.basis(c(0,365), 65)
tempbasis7 = create.bspline.basis(c(0,365), 7, norder = 4)
timepts = seq(1, 365, 1)
temp_fd = Data2fd(timepts, daily$tempav, tempbasis65)
prec_fd = Data2fd(timepts, daily$precav, tempbasis7)
prec_fd$coefs = scale(prec_fd$coefs)

# Data set up
temp_data[,,1] = temp_fd$coefs
resp_mat = prec_fd$coefs

# Non functional covariate
weather_scalar = data.frame(total_prec = apply(daily$precav, 2, sum))

# Getting data into proper format
ind = 1:30
nbasis = 65
weather_data_train &lt;- array(dim = c(nbasis, ncol(temp_data), 1))
weather_data_train[,,1] = temp_data
scalar_train = data.frame(weather_scalar[,1])
resp_train = t(resp_mat)

# Running model
weather_func_fnn &lt;- fnn.fit(resp = resp_train,
                            func_cov = weather_data_train,
                            scalar_cov = scalar_train,
                            basis_choice = c("bspline"),
                            num_basis = c(7),
                            hidden_layers = 2,
                            neurons_per_layer = c(1024, 1024),
                            activations_in_layers = c("sigmoid", "linear"),
                            domain_range = list(c(1, 365)),
                            epochs = 300,
                            learn_rate = 0.01,
                            func_resp_method = 1)



</code></pre>


</div>