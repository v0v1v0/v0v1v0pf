<div class="container">

<table style="width: 100%;"><tr>
<td>kiener3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Asymmetric Kiener Distribution K3</h2>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation,
value-at-risk, expected shortfall (+ signed left/right tail mean) 
and additional formulae for asymmetric Kiener distribution K3.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dkiener3(x, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

pkiener3(q, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

qkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

rkiener3(n, m = 0, g = 1, k = 3.2, d = 0)

dpkiener3(p, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

dqkiener3(p, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

lkiener3(x, m = 0, g = 1, k = 3.2, d = 0)

dlkiener3(lp, m = 0, g = 1, k = 3.2, d = 0, log = FALSE)

qlkiener3(lp, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE)

varkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

ltmkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

rtmkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

dtmqkiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE)

eskiener3(p, m = 0, g = 1, k = 3.2, d = 0, lower.tail = TRUE,
  log.p = FALSE, signedES = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>numeric. The median.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>numeric. The scale parameter, preferably strictly positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>numeric. The tail parameter, preferably strictly positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>numeric. The distortion parameter between left and right tails.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>logical. If TRUE, densities are given in log scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>vector of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower.tail</code></td>
<td>
<p>logical. If TRUE, use p. If FALSE, use 1-p.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log.p</code></td>
<td>
<p>logical. If TRUE, probabilities p are given as log(p).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations. If length(n) &gt; 1, the length is
taken to be the number required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lp</code></td>
<td>
<p>vector of logit of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>signedES</code></td>
<td>
<p>logical. FALSE (default) returns positive numbers for 
left and right tails. TRUE returns negative number 
(= <code>ltmkiener3</code>) for left tail and positive number 
(= <code>rtmkiener3</code>) for right tail.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Kiener distributions use the following parameters, some of them being redundant. 
See <code>aw2k</code> and <code>pk2pk</code> for the formulas and 
the conversion between parameters:
</p>

<ul>
<li> <p><code>m</code> (mu) is the median of the distribution,. 
</p>
</li>
<li> <p><code>g</code> (gamma) is the scale parameter. 
</p>
</li>
<li> <p><code>a</code> (alpha) is the left tail parameter.  
</p>
</li>
<li> <p><code>k</code> (kappa) is the harmonic mean of <code>a</code> and <code>w</code> 
and describes a global tail parameter. 
</p>
</li>
<li> <p><code>w</code> (omega) is the right tail parameter.  
</p>
</li>
<li> <p><code>d</code> (delta) is the distortion parameter. 
</p>
</li>
<li> <p><code>e</code> (epsilon) is the eccentricity parameter. 
</p>
</li>
</ul>
<p>Kiener distributions <code>K3(m, g, k, d, ...)</code> are distributions 
with asymmetrical left and right fat tails described by a global tail 
parameter <code>k</code> and a distortion parameter <code>d</code>. 
</p>
<p>Distributions K3 (<code>kiener3</code>) 
with parameters <code>k</code> (kappa) and <code>d</code> (delta) and
distributions K4 (<code>kiener4</code>)
with parameters <code>k</code> (kappa) and <code>e</code> (epsilon))
have been created to disantangle the parameters 
<code>a</code> (alpha) and <code>w</code> (omega) of distributions of 
distribution K2 (<code>kiener2</code>). 
The tiny difference between distributions K3 and K4 (<code class="reqn">d = e/k</code>) 
has not yet been fully evaluated. Both should be tested at that moment.
</p>
<p><code>k</code> is the harmonic mean of <code>a</code> and <code>w</code> and represents a 
global tail parameter.
</p>
<p><code>d</code> is a distortion parameter between the left tail parameter
<code>a</code> and the right tail parameter <code>w</code>.
It verifies the inequality: <code class="reqn">-k &lt; d &lt; k</code> 
(whereas <code>e</code> of distribution K4 verifies <code class="reqn">-1 &lt; e &lt; 1</code>).
The conversion functions (see <code>aw2k</code>) are:
</p>
<p style="text-align: center;"><code class="reqn">1/k = (1/a + 1/w)/2 </code>
</p>

<p style="text-align: center;"><code class="reqn">  d = (-1/a + 1/w)/2 </code>
</p>
 
<p style="text-align: center;"><code class="reqn">1/a = 1/k - d </code>
</p>
 
<p style="text-align: center;"><code class="reqn">1/w = 1/k + d</code>
</p>

<p><code>d</code> (and <code>e</code>) should be of the same sign than the skewness. 
A negative value <code class="reqn"> d &lt; 0 </code> implies <code class="reqn"> a &lt; w </code> and indicates a left  
tail heavier than the right tail. A positive value <code class="reqn"> d &gt; 0 </code> implies 
<code class="reqn"> a &gt; w </code> and a right tail heavier than the left tail.  
</p>
<p><code>m</code> is the median of the distribution. <code>g</code> is the scale parameter 
and the inverse of the density at the median: <code class="reqn"> g = 1 / 8 / f(m) </code>.
As a first estimate, it is approximatively one fourth of the standard 
deviation <code class="reqn"> g  \approx \sigma / 4 </code> but is independant from it.
</p>
<p>The d, p functions have no explicit forms. They are provided here for 
convenience. They are estimated from a reverse optimization on the quantile 
function and can be (very) slow, depending the number of points to estimate. 
We recommand to use the quantile function as far as possible.
WARNING: Results may become inconsistent when <code>k</code> is
smaller than 1 or for very large absolute values of <code>d</code>. 
Hopefully, this case seldom happens in finance.
</p>
<p><code>qkiener3</code> function is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qkiener3(p, m, g, k, d) = 
              m + 2 * g * k * sinh(logit(p) / k) * exp(d * logit(p)) </code>
</p>

<p><code>rkiener3</code> generates <code>n</code> random quantiles.
</p>
<p>In addition to the classical d, p, q, r functions, the prefixes 
dp, dq, l, dl, ql are also provided.
</p>
<p><code>dpkiener3</code> is the density function calculated from the probability p. 
The formula is adapted from distribution K2. It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dpkiener3(p, m, g, k, d) = 
         p * (1 - p) / k / g / ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w </code>
</p>

<p>with <code>a</code> and <code>w</code> defined from <code>k</code> and <code>d</code> 
with the formula presented above.
</p>
<p><code>dqkiener3</code> is the derivate of the quantile function calculated from 
the probability p. The formula is adapted from distribution K2. 
It is defined for p in (0, 1) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dqkiener3(p, m, g, k, d) = 
         k * g / p / (1 - p) * ( exp(-logit(p)/a)/a + exp(logit(p)/w)/w ) </code>
</p>
 
<p>with <code>a</code> and <code>w</code> defined above. 
</p>
<p><code>lkiener3</code> function is estimated from a reverse optimization and can 
be (very) slow depending the number of points to estimate. Initialization 
is done with a symmetric distribution <code>lkiener1</code> 
of parameter <code>k</code> (thus <code class="reqn"> d = 0</code>). Then optimization is performed  
to take into account the true value of <code>d</code>. 
The results can then be compared to the empirical probability logit(p).
WARNING: Results may become inconsistent when <code>k</code> is
smaller than 1 or for very large absolute values of <code>d</code>. 
Hopefully, this case seldom happens in finance.
</p>
<p><code>dlkiener3</code> is the density function calculated from the logit of the 
probability lp = logit(p). The formula is adapted from distribution K2. 
it is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> dlkiener3(lp, m, g, k, d) = 
          p * (1 - p) / k / g / ( exp(-lp/a)/a + exp(lp/w)/w ) </code>
</p>

<p>with <code>a</code> and <code>w</code> defined above. 
</p>
<p><code>qlkiener3</code> is the quantile function calculated from the logit of the 
probability. It is defined for lp in (-Inf, +Inf) by: 
</p>
<p style="text-align: center;"><code class="reqn"> qlkiener3(lp, m, g, k, d) = 
          m + 2 * g * k * sinh(lp / k) * exp(d * lp) </code>
</p>

<p><code>varkiener3</code> designates the Value a-risk and turns negative numbers 
into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> varkiener3 &lt;- if(p &lt;= 0.5) { - qkiener3 } else { qkiener3 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.05</code>, <code>p = 0.95</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>ltmkiener3</code>, <code>rtmkiener3</code> and <code>eskiener3</code> are respectively the 
left tail mean, the right tail mean and the expected shortfall of the distribution 
(sometimes called average VaR, conditional VaR or tail VaR). 
Left tail mean is the integrale from <code>-Inf</code> to <code>p</code> of the quantile function 
<code>qkiener3</code> divided by <code>p</code>.
Right tail mean is the integrale from <code>p</code> to <code>+Inf</code> of the quantile function 
<code>qkiener3</code> divided by 1-p.
Expected shortfall turns negative numbers into positive numbers with the following rule:
</p>
<p style="text-align: center;"><code class="reqn"> eskiener3 &lt;- if(p &lt;= 0.5) { - ltmkiener3 } else { rtmkiener3 } </code>
</p>

<p>Usual values in finance are <code>p = 0.01</code>, <code>p = 0.025</code>, <code>p = 0.975</code> and 
<code>p = 0.99</code>. <code>lower.tail = FALSE</code> uses <code>1-p</code> rather than <code>p</code>.
</p>
<p><code>dtmqkiener3</code> is the difference between the left tail mean and the quantile 
when (p &lt;= 0.5) and the difference between the right tail mean and the quantile 
when (p &gt; 0.5). It is in quantile unit and is an indirect measure of the tail curvature.
</p>


<h3>References</h3>

<p>P. Kiener, Explicit models for bilateral fat-tailed distributions and 
applications in finance with the package FatTailsR, 8th R/Rmetrics Workshop 
and Summer School, Paris, 27 June 2014. Download it from:  
<a href="https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2014-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
Download it from: 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>
<p>C. Acerbi, D. Tasche, Expected shortfall: a natural coherent alternative to 
Value at Risk, 9 May 2001. Download it from: 
<a href="https://www.bis.org/bcbs/ca/acertasc.pdf">https://www.bis.org/bcbs/ca/acertasc.pdf</a>
</p>


<h3>See Also</h3>

<p>Symmetric Kiener distribution K1 <code>kiener1</code>, 
asymmetric Kiener distributions K2, K4 and K7
<code>kiener2</code>, <code>kiener4</code>, <code>kiener7</code>, 
conversion functions <code>aw2k</code>,  
estimation function <code>fitkienerX</code>, 
regression function <code>regkienerLX</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
require(graphics)

### Example 1
pp &lt;- c(ppoints(11, a = 1), NA, NaN) ; pp
lp &lt;- logit(pp) ; lp
qkiener3(  p = pp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
qlkiener3(lp = lp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
dpkiener3( p = pp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
dlkiener3(lp = lp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))
dqkiener3( p = pp, m = 2, g = 1.5, k = aw2k(4, 6), d = aw2d(4, 6))


### Example 2
k       &lt;- 4.8
d       &lt;- 0.042
set.seed(2014)
mainTC  &lt;- paste("qkiener3(p, m = 0, g = 1, k = ", k, ", d = ", d, ")")
mainsum &lt;- paste("cumulated qkiener3(p, m = 0, g = 1, k = ", k, ", d = ", d, ")")
T       &lt;- 500
C       &lt;- 4
TC      &lt;- qkiener3(p = runif(T*C), m = 0, g = 1, k = k, d = d)
matTC   &lt;- matrix(TC, nrow = T, ncol = C, dimnames = list(1:T, letters[1:C]))
head(matTC)
plot.ts(matTC, main = mainTC)
#
matsum  &lt;- apply(matTC, MARGIN=2, cumsum) 
head(matsum)
plot.ts(matsum, plot.type = "single", main = mainsum)
### End example 2


### Example 3 (four plots: probability, density, logit, logdensity)
x     &lt;- q  &lt;- seq(-15, 15, length.out=101)
k     &lt;- 3.2
d     &lt;- c(-0.1, -0.03, -0.01, 0.01, 0.03, 0.1) ; names(d) &lt;- d
olty  &lt;- c(2, 1, 2, 1, 2, 1, 1)
olwd  &lt;- c(1, 1, 2, 2, 3, 3, 2)
ocol  &lt;- c(2, 2, 4, 4, 3, 3, 1)
lleg  &lt;- c("logit(0.999) = 6.9", "logit(0.99)   = 4.6", "logit(0.95)   = 2.9", 
           "logit(0.50)   = 0", "logit(0.05)   = -2.9", "logit(0.01)   = -4.6", 
           "logit(0.001) = -6.9  ")
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(x, pkiener3(x, k = 3.2, d = 0), type = "l", lwd = 3, ylim = c(0, 1),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "pkiener3(q, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(x, pkiener3(x, k = 3.2, d = d[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, dkiener3(x, k = 3.2, d = 0), type = "l", lwd = 3, ylim = c(0, 0.14),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dkiener3(q, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(x, dkiener3(x, k = 3.2, d = d[i]), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topright", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )

plot(x, lkiener3(x, k = 3.2, d = 0), type = "l", lwd =3, ylim = c(-7.5, 7.5), 
     yaxt="n", xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "logit(pkiener3(q, m, g, k=3.2, d=...))")
axis(2, las=1, at=c(-6.9, -4.6, -2.9, 0, 2.9, 4.6, 6.9) )
for (i in 1:length(d)) lines(x, lkiener3(x, k = 3.2, d = d[i]),  
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", legend = lleg, cex = 0.7, inset = 0.02 )
legend("bottomright", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = c(olty), lwd = c(olwd), col = c(ocol) )

plot(x, dkiener3(x, k = 3.2, d = 0, log = TRUE), type = "l", lwd = 3, 
     ylim = c(-8, -1.5), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "log(dkiener3(q, m, g, k=2, d=...))")
for (i in 1:length(d)) lines(x, dkiener3(x, k = 3.2, d = d[i], log=TRUE), 
       lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("bottom", title = expression(delta), legend = c(d, "0"), 
       cex = 0.7, inset = 0.02, lty = olty, lwd = olwd, col = ocol )
### End example 3


### Example 4 (four plots: quantile, derivate, density and quantiles from p)
p     &lt;- ppoints(199, a=0)
d     &lt;- c(-0.1, -0.03, -0.01, 0.01, 0.03, 0.1) ; names(d) &lt;- d
op    &lt;- par(mfrow=c(2,2), mgp=c(1.5,0.8,0), mar=c(3,3,2,1))

plot(p, qlogis(p, scale = 2), type = "l", lwd = 2, xlim = c(0, 1),
      ylim = c(-15, 15), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(p, qkiener3(p, k = 3.2, d = d[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(delta), legend = c(d, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(p, 2/p/(1-p), type = "l", lwd = 2, xlim = c(0, 1), ylim = c(0, 100),
     xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "dqkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(p, dqkiener3(p, k = 3.2, d = d[i]), 
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("top", title = expression(delta), legend = c(d, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p*(1-p)/2, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 0.14), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "qkiener3, dpkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) { 
     lines(qkiener3(p, k = 3.2, d = d[i]), dpkiener3(p, k = 3.2, d = d[i]),
           lty = olty[i], lwd = olwd[i], col = ocol[i] ) }
legend("topleft", title = expression(delta), legend = c(d, "p*(1-p)/2"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )

plot(qlogis(p, scale = 2), p, type = "l", lwd = 2, xlim = c(-15, 15), 
     ylim = c(0, 1), xaxs = "i", yaxs = "i", xlab = "", ylab = "", 
     main = "inverse axis qkiener3(p, m, g, k=3.2, d=...)")
for (i in 1:length(d)) lines(qkiener3(p, k = 3.2, d = d[i]), p,
          lty = olty[i], lwd = olwd[i], col = ocol[i] )
legend("topleft", title = expression(delta), legend = c(d, "qlogis(x/2)"), 
          inset = 0.02, lty = olty, lwd = olwd, col = ocol, cex = 0.7 )
### End example 4


### Example 5 (q and VaR, ltm, rtm, and ES)
pp &lt;- c(0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 
        0.10, 0.20, 0.35, 0.5, 0.65, 0.80, 0.90,
        0.95, 0.975, 0.99, 0.995, 0.9975, 0.999)
m &lt;- -10 ; g &lt;- 1 ; k &lt;- 4 ; d &lt;- 0.06 
a &lt;- dk2a(d, k) ; w &lt;- dk2w(d, k) ; e &lt;- dk2e(d, k)
round(c(m = m, g = g, a = a, k = k, w = w, d = d, e = e), 2) 
plot(qkiener3(  pp, m=m, k=k, d=d), pp, type ="b")
round(cbind(p = pp, "1-p" = 1-pp,
	q   =   qkiener3(pp, m, g, k, d),
	ltm = ltmkiener3(pp, m, g, k, d),
	rtm = rtmkiener3(pp, m, g, k, d),
	ES  =  eskiener3(pp, m, g, k, d),
	VaR = varkiener3(pp, m, g, k, d)), 4)
round(kmean(c(m, g, k, d), model = "K3"), 4) # limit value for ltm and rtm
round(cbind(p = pp, "1-p" = 1-pp,
	q   =   qkiener3(pp, m, g, k, d, lower.tail = FALSE),
	ltm = ltmkiener3(pp, m, g, k, d, lower.tail = FALSE),
	rtm = rtmkiener3(pp, m, g, k, d, lower.tail = FALSE),
	ES  =  eskiener3(pp, m, g, k, d, lower.tail = FALSE),
	VaR = varkiener3(pp, m, g, k, d, lower.tail = FALSE)), 4)
### End example 5


</code></pre>


</div>