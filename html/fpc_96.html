<div class="container">

<table style="width: 100%;"><tr>
<td>prediction.strength</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction strength for estimating number of clusters</h2>

<h3>Description</h3>

<p>Computes the prediction strength of a clustering of a dataset into
different numbers of components. The prediction strength is
defined according to Tibshirani and Walther (2005), who recommend to
choose as optimal number of cluster the largest number of clusters
that leads to a prediction strength above 0.8 or 0.9. See details.
</p>
<p>Various clustering methods can be used, see argument
<code>clustermethod</code>. In  Tibshirani and Walther (2005), only
classification to the nearest centroid is discussed, but more methods
are offered here, see argument <code>classification</code>.  
</p>


<h3>Usage</h3>

<pre><code class="language-R">  prediction.strength(xdata, Gmin=2, Gmax=10, M=50,
                      clustermethod=kmeansCBI,
                                classification="centroid", centroidname = NULL,
                                cutoff=0.8,nnk=1,
                      distances=inherits(xdata,"dist"),count=FALSE,...)
  ## S3 method for class 'predstr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p>data (something that can be coerced into a matrix).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gmin</code></td>
<td>
<p>integer. Minimum number of clusters. Note that the
prediction strength for 1 cluster is trivially 1, which is
automatically included if <code>GMin&gt;1</code>. Therefore <code>GMin&lt;2</code> is
useless.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gmax</code></td>
<td>
<p>integer. Maximum number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>integer. Number of times the dataset is divided into two
halves.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustermethod</code></td>
<td>
<p>an interface function (the function name, not a
string containing the name, has to be provided!). This defines the
clustering method. See the "Details"-section of <code>clusterboot</code>
and <code>kmeansCBI</code> for the format. Clustering methods for
<code>prediction.strength</code> must have a <code>k</code>-argument for the number of
clusters, must operate on n times p data matrices
and must otherwise follow the specifications in
<code>clusterboot</code>
Note that <code>prediction.strength</code> won't work
with CBI-functions that implicitly already estimate the number of
clusters such as <code>pamkCBI</code>; use <code>claraCBI</code>
if you want to run it for pam/clara clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>classification</code></td>
<td>
<p>string.
This determines how non-clustered points are classified to given
clusters. Options are explained in <code>classifnp</code> and
<code>classifdist</code>, the latter for dissimilarity data.
Certain classification methods are connected to certain clustering
methods. <code>classification="averagedist"</code> is recommended for
average linkage, <code>classification="centroid"</code> is recommended for
k-means, clara and pam (with distances it will work with
<code>claraCBI</code> only), <code>classification="knn"</code> with
<code>nnk=1</code> is recommended for single linkage and
<code>classification="qda"</code> is recommended for Gaussian mixtures
with flexible covariance matrices. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centroidname</code></td>
<td>
<p>string. Indicates the name of the component of
<code>CBIoutput$result</code> that contains the cluster centroids in case of
<code>classification="centroid"</code>, where <code>CBIoutput</code> is the
output object of <code>clustermethod</code>. If <code>clustermethod</code> is
<code>kmeansCBI</code> or <code>claraCBI</code>, centroids are recognised
automatically if <code>centroidname=NULL</code>. If
<code>centroidname=NULL</code> and <code>distances=FALSE</code>, cluster means
are computed as the cluster centroids.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>numeric between 0 and 1. The optimal number of clusters
is the maximum one with prediction strength above <code>cutoff</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnk</code></td>
<td>
<p>number of nearest neighbours if
<code>classification="knn"</code>, see <code>classifnp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distances</code></td>
<td>
<p>logical. If <code>TRUE</code>, data will be interpreted as
dissimilarity matrix, passed on to clustering methods as
<code>"dist"</code>-object, and <code>classifdist</code> will be used for
classification.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>count</code></td>
<td>
<p>logical. <code>TRUE</code> will print current number of
clusters and simulation run number on the screen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>predstr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to be passed on to the clustering method.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The prediction strength for a certain number of clusters k under a
random partition of the dataset in halves A and B is defined as
follows. Both halves are clustered with k clusters. Then the points of
A are classified to the clusters of B. In the original paper
this is done by assigning every
observation in A to the closest cluster centroid in B (corresponding
to <code>classification="centroid"</code>), but other methods are possible,
see <code>classifnp</code>. A pair of points A in
the same A-cluster is defined to be correctly predicted if both points
are classified into the same cluster on B. The same is done with the
points of B relative to the clustering on A. The prediction strength
for each of the clusterings is the minimum (taken over all clusters)
relative frequency of correctly predicted pairs of points of that
cluster. The final mean prediction strength statistic is the mean over
all 2M clusterings.
</p>


<h3>Value</h3>

<p><code>prediction.strength</code> gives out an object of class
<code>predstr</code>, which is a
list with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>predcorr</code></td>
<td>
<p>list of vectors of length <code>M</code> with relative
frequencies of correct predictions (clusterwise minimum). Every list
entry refers to a certain number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean.pred</code></td>
<td>
<p>means of <code>predcorr</code> for all numbers of
clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimalk</code></td>
<td>
<p>optimal number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>see above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>a string identifying the clustering method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Gmax</code></td>
<td>
<p>see above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>see above.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Tibshirani, R. and Walther, G. (2005) Cluster Validation by 
Prediction Strength, <em>Journal of Computational and Graphical 
Statistics</em>, 14, 511-528.
</p>


<h3>See Also</h3>

<p><code>kmeansCBI</code>, <code>classifnp</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  options(digits=3)
  set.seed(98765)
  iriss &lt;- iris[sample(150,20),-5]
  prediction.strength(iriss,2,3,M=3)
  prediction.strength(iriss,2,3,M=3,clustermethod=claraCBI)
# The examples are fast, but of course M should really be larger.
</code></pre>


</div>