<div class="container">

<table style="width: 100%;"><tr>
<td>predict.flexsurvreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Predictions from flexible survival models</h2>

<h3>Description</h3>

<p>Predict outcomes from flexible survival models at the covariate values
specified in <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'flexsurvreg'
predict(
  object,
  newdata,
  type = "response",
  times,
  start = 0,
  conf.int = FALSE,
  conf.level = 0.95,
  se.fit = FALSE,
  p = c(0.1, 0.9),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Output from <code>flexsurvreg</code> or
<code>flexsurvspline</code>, representing a fitted survival model object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Data frame containing covariate values at which to produce
fitted values. There must be a column for every covariate in the model
formula used to fit <code>object</code>, and one row for every combination of
covariate values at which to obtain the fitted predictions.
</p>
<p>If <code>newdata</code> is omitted, then the original data used to fit the model
are used, as extracted by <code>model.frame(object)</code>. However this will
currently not work if the model formula contains functions, e.g.
<code>~ factor(x)</code>. The names of the model frame must correspond to
variables in the original data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character vector for the type of predictions desired.
</p>

<ul>
<li> <p><code>"response"</code> for mean survival time (the default). <code>"mean"</code> is
an acceptable synonym
</p>
</li>
<li> <p><code>"quantile"</code> for quantiles of the survival distribution as specified
by <code>p</code>
</p>
</li>
<li> <p><code>"rmst"</code> for restricted mean survival time
</p>
</li>
<li> <p><code>"survival"</code> for survival probabilities
</p>
</li>
<li> <p><code>"cumhaz"</code> for cumulative hazards
</p>
</li>
<li> <p><code>"hazard"</code> for hazards
</p>
</li>
<li> <p><code>"link"</code> for fitted values of the location parameter, analogous to
the linear predictor in generalized linear models (<code>type = "lp"</code> and
<code>type = "linear"</code> are acceptable synonyms). This is on the natural
scale of the parameter, not the log scale.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>Vector of time horizons at which to compute fitted values.
Only applies when <code>type</code> is <code>"survival"</code>, <code>"cumhaz"</code>,
<code>"hazard"</code>, or <code>"rmst"</code>. Will be silently ignored for all other
types.
</p>
<p>If not specified, predictions for <code>"survival"</code>, <code>"cumhaz"</code>, and
<code>"hazard"</code> will be made at each observed event time in
<code>model.frame(object)</code>.
</p>
<p>For <code>"rmst"</code>, when <code>times</code> is not specified predictions will be
made at the maximum observed event time from the data used to fit
<code>object</code>. Specifying <code>times = Inf</code> is valid, and will return
mean survival (equal to <code>type = "response"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Optional left-truncation time or times. The returned
survival, hazard, or cumulative hazard will be conditioned on survival up
to this time. <code>start</code> must be length 1 or the same length as <code>times</code>.
Predicted times returned with <code>type</code> <code>"rmst"</code> or <code>"quantile"</code>
will be times since time zero, not times since the <code>start</code> time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.int</code></td>
<td>
<p>Logical. Should confidence intervals be returned?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>Width of symmetric confidence intervals, relative to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se.fit</code></td>
<td>
<p>Logical. Should standard errors of fitted values be returned?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Vector of quantiles at which to return fitted values when
<code>type = "quantile"</code>. Default is <code>c(0.1, 0.9)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>tibble</code> with same number of rows as
<code>newdata</code> and in the same order. If multiple predictions are
requested, a <code>tibble</code> containing a single list-column
of data frames.
</p>
<p>For the list-column of data frames - the dimensions of each data frame
will be identical. Rows are added for each value of <code>times</code> or
<code>p</code> requested.
</p>
<p>This function is a wrapper around <code>summary.flexsurvreg</code>,
designed to help <span class="pkg">flexsurv</span> to integrate with the "tidymodels"
ecosystem, in particular the <span class="pkg">censored</span> package.
<code>summary.flexsurvreg</code> returns the same results but in a more
conventional format.
</p>


<h3>Author(s)</h3>

<p>Matthew T. Warkentin (<a href="https://github.com/mattwarkentin">https://github.com/mattwarkentin</a>)
</p>


<h3>See Also</h3>

<p><code>summary.flexsurvreg</code>,
<code>residuals.flexsurvreg</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
fitg &lt;- flexsurvreg(formula = Surv(futime, fustat) ~ age, data = ovarian, dist = "gengamma")

## Simplest prediction: mean or median, for covariates defined by original dataset
predict(fitg)
predict(fitg, type = "quantile", p = 0.5)

## Simple prediction for user-defined covariate values
predict(fitg, newdata = data.frame(age = c(40, 50, 60)))
predict(fitg, type = "quantile", p = 0.5, newdata = data.frame(age = c(40,50,60)))

## Predict multiple quantiles and unnest
require(tidyr)
pr &lt;- predict(fitg, type = "survival", times = c(600, 800))
tidyr::unnest(pr, .pred)

</code></pre>


</div>