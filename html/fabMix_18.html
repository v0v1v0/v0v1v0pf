<div class="container">

<table style="width: 100%;"><tr>
<td>fabMix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Main function
</h2>

<h3>Description</h3>

<p>This function runs parallel chains under a prior tempering scheme of the Dirichlet prior distribution of mixture weights. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">fabMix(model, nChains, dirPriorAlphas, rawData, outDir, Kmax, mCycles, 
	burnCycles, g, h, alpha_sigma, beta_sigma, q, normalize,  
	thinning, zStart, nIterPerCycle, gibbs_z, 
	warm_up_overfitting, warm_up, overfittingInitialization, 
	progressGraphs, gwar, rmDir, parallelModels, lowerTriangular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>

<p>Any subset of "UUU" "CUU" "UCU" "CCU" "UCC" "UUC" "CUC", "CCC" indicating the fitted models. By default, all models are fitted. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nChains</code></td>
<td>

<p>The number of parallel heated chains. When 'dirPriorAlphas' is supplied, 'nChains' can be ignored.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dirPriorAlphas</code></td>
<td>

<p>vector of length <code>nChains</code> in the form of an increasing sequence of positive scalars. Each entry contains the (common) prior Dirichlet parameter for the corresponding chain. Default: <code>dirPriorAlphas = c(1, 1 + dN*(2:nChains - 1))/Kmax</code>, where <code>dN = 1</code>, for <code>nChains &gt; 1</code>. Otherwise, <code>dirPriorAlphas = 1/Kmax</code>. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rawData</code></td>
<td>

<p>The observed data as an <code class="reqn">n\times p</code> matrix. Clustering is performed on the rows of the matrix.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outDir</code></td>
<td>

<p>Name of the output folder. An error is thrown if the directory already exists inside the current working directory. Note: it should NOT correspond to an absolute path, e.g.: <code>outDir = `fabMix_example`</code> is acceptable, but <code>outDir = `C:\Username\Documents\fabMix_example`</code> is not. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kmax</code></td>
<td>

<p>Number of components in the overfitted mixture. Default: 20.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mCycles</code></td>
<td>

<p>Number of MCMC cycles. Each cycle consists of <code>nIterPerCycle</code> MCMC iterations. At the end of each cycle a swap of the state of two randomly chosen adjacent chains is attempted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnCycles</code></td>
<td>

<p>Number of cycles that will be discarded as burn-in period.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>

<p>Prior parameter <code class="reqn">g</code>. Default value: <code class="reqn">g = 0.5</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>Prior parameter <code class="reqn">h</code>. Default value: <code class="reqn">h = 0.5</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha_sigma</code></td>
<td>

<p>Prior parameter <code class="reqn">\alpha</code>. Default value: <code class="reqn">\alpha = 0.5</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta_sigma</code></td>
<td>

<p>Prior parameter <code class="reqn">\beta</code>. Default value: <code class="reqn">\beta = 0.5</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>

<p>A vector containing the number of factors to be fitted.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>

<p>Should the observed data be normalized? Default value: TRUE. (Recommended) 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>

<p>Optional integer denoting the thinning of the keeped MCMC cycles.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zStart</code></td>
<td>

<p>Optional starting value for the allocation vector.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nIterPerCycle</code></td>
<td>

<p>Number of iteration per MCMC cycle. Default value: 10.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gibbs_z</code></td>
<td>

<p>Select the gibbs sampling scheme for updating latent allocations of mixture model. Default value: 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm_up_overfitting</code></td>
<td>

<p>Number of iterations for the overfitting initialization scheme. Default value: 500.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warm_up</code></td>
<td>

<p>Number of iterations that will be used to initialize the models before starting proposing switchings. Default value: 5000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overfittingInitialization</code></td>
<td>

<p>Logical value indicating whether the chains are initialized via the overfitting initialization scheme. Default: TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressGraphs</code></td>
<td>

<p>Logical value indicating whether to plot successive states of the chains while the sampler runs. Default: FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gwar</code></td>
<td>

<p>Initialization parameter. Default: 0.05.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rmDir</code></td>
<td>

<p>Logical value indicating whether to delete the <code>outDir</code> directory. Default: TRUE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallelModels</code></td>
<td>

<p>Model-level parallelization: An optional integer specifying the number of cores that will be used in order to fit in parallel each member of <code>model</code>. Default: NULL (no model-level parallelization).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowerTriangular</code></td>
<td>

<p>logical value indicating whether a lower triangular parameterization should be imposed on the matrix of factor loadings (if TRUE) or not. Default: TRUE.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">\boldsymbol{X}_i</code>; <code class="reqn">i =1,\ldots,n</code> denote independent <code class="reqn">p</code>-dimensional random vectors. Let <code class="reqn">Y_i\in  R^q</code> with <code class="reqn">q &lt; p</code> denote the latent factor for observation <code class="reqn">i = 1,\ldots,n</code>. In the typical factor analysis model, each observation is modelled as <code class="reqn">\boldsymbol{X}_i = \boldsymbol{\mu} + \boldsymbol{\Lambda} \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i </code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\boldsymbol{\Sigma})</code>, where <code class="reqn">\boldsymbol{\varepsilon}_i</code> and <code class="reqn">Y_i</code> are assumed independent, <code class="reqn">i =1,\ldots,n</code>. The <code class="reqn">p\times q</code> matrix <code class="reqn">\Lambda</code> consists of the factor loadings. Assume that there are <code class="reqn">K</code> clusters and let <code class="reqn">Z_i</code> denotes the latent allocation of observation <code class="reqn">i</code> to one amongs the  <code class="reqn">k</code> clusters, with prior probability <code class="reqn">P(Z_i = k) = w_k</code>, <code class="reqn">k = 1,\ldots,K</code>, independent for <code class="reqn">i=1,\ldots,n</code>.  Following McNicholas et al (2008), the following parameterizations are used:
</p>
<p>UUU model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda}_k \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\boldsymbol{\Sigma}_k)</code>
</p>
<p>UCU model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda}_k \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\boldsymbol{\Sigma})</code>
</p>
<p>UUC model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda}_k \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\sigma_k \boldsymbol{I}_p)</code>
</p>
<p>UCC model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda}_k \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\sigma \boldsymbol{I}_p)</code>
</p>
<p>CUU model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda} \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\boldsymbol{\Sigma}_k)</code>
</p>
<p>CCU model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda} \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\boldsymbol{\Sigma})</code>
</p>
<p>CUC model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda} \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\sigma_k \boldsymbol{I}_p)</code>
</p>
<p>CCC model: <code class="reqn">(\boldsymbol{X}_i|Z_i = k) = \boldsymbol{\mu}_k + \boldsymbol{\Lambda} \boldsymbol{Y}_i + \boldsymbol{\varepsilon}_i</code>, with <code class="reqn">\boldsymbol{\varepsilon}_i \sim \mathcal N(0,\sigma \boldsymbol{I}_p)</code>
</p>
<p>In all cases, <code class="reqn">\boldsymbol{\varepsilon}_i</code> and <code class="reqn">\boldsymbol{Y}_i</code> are assumed independent, <code class="reqn">i =1,\ldots,n</code>. Note that <code class="reqn">\boldsymbol{\Sigma}_k</code> and <code class="reqn">\boldsymbol{\Sigma}</code> denote positive definite matrices, <code class="reqn">\boldsymbol{I}_p</code> denotes the <code class="reqn">p\times p</code> identity matrix and <code class="reqn">\sigma_k</code>, <code class="reqn">\sigma</code> denote positive scalars. 
</p>


<h3>Value</h3>

<p>An object of class <code>fabMix.object</code>, that is, a list consisting of the following entries:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>bic </code></td>
<td>
<p>Bayesian Information Criterion per model and number of factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class </code></td>
<td>
<p>The estimated single best clustering of the observations according to the selected model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_Clusters_per_model </code></td>
<td>
<p>The most probable number of clusters (number of non-empty components of the overfitted mixture) per model and number of factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>posterior_probability </code></td>
<td>
<p>The posterior probability of the estimated allocations according to the selected model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariance_matrix </code></td>
<td>
<p>The estimated posterior mean of the covariance matrix per cluster according to the selected model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu </code></td>
<td>
<p>The estimated posterior mean of the mean per cluster according to the selected model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights </code></td>
<td>
<p>The estimated posterior mean of the mixing proportions according to the selected model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selected_model </code></td>
<td>
<p>Data frame containing the parameterization, number of clusters and factors of the selected model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mcmc </code></td>
<td>
<p>A list containing the MCMC draws for the parameters of the selected model. Each entry is returned as an <code>mcmc</code> object, a class imported from the <code>coda</code> package (Plummer et al, 2006). All component-specific parameters have been reordered according to the ECR algorithm in order to undo the label switching problem. However, the output corresponding to factor scores and factor loadings is not identifiable due to sign-switching across the MCMC trace.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data </code></td>
<td>
<p>The observed data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regularizedExpression</code></td>
<td>
<p>The regularized expressions of variable scores to each factor per cluster  (see Papastamoulis 2018, CSDA). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Kmap_prob</code></td>
<td>
<p>The posterior probability of the Maximum A Posteriori number of alive clusters for each parameterization and factor level.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>It is recommended to use: <code>normalize = TRUE</code> (default). Tuning of <code>dirPriorAlphas</code> may be necessary to achieve reasonable acceptance rates of chain swaps. Note that the output is reordered in order to deal with the label switching problem, according to the ECR algorithm applied by <code>dealWithLabelSwitching</code> function. 
</p>
<p>Parallelization is enabled in both the chain-level as well as the model-level. By default all heated chains (specified by the <code>nchains</code> argument) run in parallel using (at most) the same number of threads (if available). If <code>parallelModels = NULL</code> (default), then the selected parameterizations will run (serially) on the same thread. Otherwise, if <code>parallelModels = x</code> (where <code>x</code> denotes a positive integer), the algorithm will first use <code>x</code> threads to fit the specified model parameterizations in parallel, and furthermore will also parallelize the heated chains (according to the remaining free cores on the user's system). The user should combine <code>parallelModels</code> with <code>nChains</code> efficiently, for example: if the number of available threads equals 12 and the user wishes to run 3 heated chains per model (recall that there are 8 parameterizations in total), then, an ideal allocation would be <code>parallelModels = 4</code> and <code>nChains = 3</code> because all available threads will be constantly busy. If the user wishes to run <code>nChains = 4</code> heated chains per model using 12 threads, then an ideal allocation would be <code>parallelModels = 3</code> models running in parallel. In the case where <code>parallelModels*nChains</code> &gt; <code>m</code>, with <code>m</code> denoting the available number of threads, the algorithm will first allocate min(<code>parallelModels</code>, <code>m</code>) threads to run the same number of parameterizations in parallel, and then the remaining threads (if any) will be used to process the parallel heated chains. If no other threads are available, the heated chains will be allocated to single threads. 
</p>


<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Martyn Plummer, Nicky Best, Kate Cowles and Karen Vines (2006). CODA: Convergence Diagnosis and Output Analysis for MCMC, R News, vol 6, 7-11.
</p>
<p>McNicholas, P.D. and Murphy, T.B. Stat Comput (2008) 18: 285. https://doi.org/10.1007/s11222-008-9056-0.
</p>
<p>Papastamoulis, P. (2018). Overfitting Bayesian mixtures of factor analyzers with an unknown number of components. Computational Statistics and Data Analysis, 124: 220-234. DOI: 10.1016/j.csda.2018.03.007.
</p>
<p>Papastamoulis, P (2019).  Clustering multivariate data using factor analytic Bayesian mixtures with an unknown number of components. Statistics and Computing, doi: 10.1007/s11222-019-09891-z.
</p>


<h3>See Also</h3>

<p><code>plot.fabMix.object</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># TOY EXAMPLE (very small numbers... only for CRAN check purposes)

#################################################################
# (a) using 2 cores in parallel, each one running 2 heated chains.
#################################################################
library('fabMix')

n = 8                # sample size
p = 5                # number of variables
q = 2                # number of factors
K = 2		     # true number of clusters

sINV_diag = 1/((1:p))	 # diagonal of inverse variance of errors
set.seed(100)
syntheticDataset &lt;- simData(sameLambda=TRUE,K.true = K, n = n, q = q, p = p, 
			sINV_values = sINV_diag)
colnames(syntheticDataset$data) &lt;- paste0("x_",1:p)

# Run `fabMix` for a _small_ number of iterations 
#	but considering only the `UUU` (maximal model),
# 	using the default prior parallel heating parameters `dirPriorAlphas`.
#	NOTE: `dirPriorAlphas` may require some tuning in general.


qRange &lt;- 2	# values for the number of factors (only the true number 
#                                                    is considered here)
Kmax &lt;- 2	# number of components for the overfitted mixture model
nChains &lt;- 2	# number of parallel heated chains

set.seed(1)
fm &lt;- fabMix( model = "UUU", nChains = nChains, 
	rawData = syntheticDataset$data, outDir = "toyExample",
        Kmax = Kmax, mCycles = 4, burnCycles = 1, q = qRange,
        g = 0.5, h = 0.5, alpha_sigma = 0.5, beta_sigma = 0.5, 
        warm_up_overfitting = 2, warm_up = 5) 

# WARNING: the following parameters: 
#  Kmax, nChains, mCycles, burnCycles, warm_up_overfitting, warm_up 
#	 should take (much) _larger_ values. E.g. a typical implementation consists of:
#        Kmax = 20, nChains &gt;= 3, mCycles = 1100, burnCycles = 100, 
#        warm_up_overfitting = 500, warm_up = 5000. 

# You may also print and plot
# print(fm)
# plot(fm)

#################################################################
# (b) using 12 cores_____________________________________________
#_______4 models with 3 heated chains running in parallel________
#_______considering all 8 model parameterizations________________
#################################################################
## Not run: 
library('fabMix')
set.seed(99)
n = 200                # sample size
p = 30                # number of variables
q = 2                # number of factors
K = 5		     # number of clusters
sINV_diag = rep(1/20,p) 	# diagonal of inverse variance of errors
syntheticDataset &lt;- simData(sameLambda=FALSE,K.true = K, n = n, q = q, p = p, 
			sINV_values = sINV_diag)
colnames(syntheticDataset$data) &lt;- paste0("x_",1:p)
qRange &lt;- 1:3	# range of values for the number of factors
Kmax &lt;- 20	# number of components for the overfitted mixture model
nChains &lt;- 3	# number of parallel heated chains

# the next command takes ~ 2 hours in a Linux machine with 12 threads.

fm &lt;- fabMix( parallelModels = 4, 
	nChains = nChains, 
	model = c("UUU","CUU","UCU","CCU","UCC","UUC","CUC","CCC"), 
	rawData = syntheticDataset$data, outDir = "toyExample_b",
        Kmax = Kmax, mCycles = 1100, burnCycles = 100, q = qRange) 

print(fm)
plot(fm, what = "BIC")
# see also
# plot(fm); summary(fm)


## End(Not run)


</code></pre>


</div>