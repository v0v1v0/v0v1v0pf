<div class="container">

<table style="width: 100%;"><tr>
<td>xpd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Expands formula macros</h2>

<h3>Description</h3>

<p>Create macros within formulas and expand them with character vectors or other formulas.
</p>


<h3>Usage</h3>

<pre><code class="language-R">xpd(fml, ..., add = NULL, lhs, rhs, data = NULL, frame = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fml</code></td>
<td>
<p>A formula containing macros variables. Each macro variable must start with two dots.
The macro variables can be set globally using <code>setFixest_fml</code>, or can be defined in <code>...</code>.
Special macros of the form <code>..("regex")</code> can be used to fetch, through a regular expression,
variables directly in a character vector (or in column names) given in the argument <code>data</code> (note
that the algorithm tries to "guess" the argument data when nested in function calls [see
example]). You can negate the regex by starting with a <code>"!"</code>. Square brackets have a special
meaning: Values in them are evaluated and parsed accordingly. Example: <code>y~x.[1:2] + z.[i]</code> will
lead to <code>y~x1+x2+z3</code> if <code>i==3</code>. You can trigger the auto-completion of variables by using the
<code>'..'</code> suffix, like in <code>y ~ x..</code> which would include <code>x1</code> and <code>x2</code>, etc. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Definition of the macro variables. Each argument name corresponds to the name of the
macro variable. It is required that each macro variable name starts with two dots
(e.g. <code>..ctrl</code>). The value of each argument must be a one-sided formula or a character vector,
it is the definition of the macro variable. Example of a valid call:
<code>setFixest_fml(..ctrl = ~ var1 + var2)</code>. In the function <code>xpd</code>, the default macro variables are
taken from <code>getFixest_fml</code>, any variable in <code>...</code> will replace these values. You can enclose
values in <code>.[]</code>, if so they will be evaluated from the current environment.
For example <code>..ctrl = ~ x.[1:2] + .[z]</code> will lead to <code>~x1 + x2 + var</code> if <code>z</code> is equal to <code>"var"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>Either a character scalar or a one-sided formula. The elements will be added to the
right-hand-side of the formula, before any macro expansion is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lhs</code></td>
<td>
<p>If present then a formula will be constructed with <code>lhs</code> as the full left-hand-side.
The value of <code>lhs</code> can be a one-sided formula, a call, or a character vector. Note that the
macro variables wont be applied. You can use it in combination with the argument <code>rhs</code>. Note
that if <code>fml</code> is not missing, its LHS will be replaced by <code>lhs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rhs</code></td>
<td>
<p>If present, then a formula will be constructed with <code>rhs</code> as the full
right-hand-side. The value of <code>rhs</code> can be a one-sided formula, a call, or a character vector.
Note that the macro variables wont be applied. You can use it in combination with the argument
<code>lhs</code>. Note that if <code>fml</code> is not missing, its RHS will be replaced by <code>rhs</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Either a character vector or a data.frame. This argument will only be used if a
macro of the type <code>..("regex")</code> is used in the formula of the argument <code>fml</code>. If so, any
variable name from <code>data</code> that matches the regular expression will be added to the formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frame</code></td>
<td>
<p>The environment containing the values to be expanded with the dot square bracket
operator. Default is <code>parent.frame()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In <code>xpd</code>, the default macro variables are taken from <code>getFixest_fml</code>. Any value in the <code>...</code>
argument of <code>xpd</code> will replace these default values.
</p>
<p>The definitions of the macro variables will replace in verbatim the macro variables. Therefore,
you can include multi-part formulas if you wish but then beware of the order of the macros
variable in the formula. For example, using the <code>airquality</code> data, say you want to set as
controls the variable <code>Temp</code> and <code>Day</code> fixed-effects, you can do
<code>setFixest_fml(..ctrl = ~Temp | Day)</code>, but then <code>feols(Ozone ~ Wind + ..ctrl, airquality)</code>
will be quite different from <code>feols(Ozone ~ ..ctrl + Wind, airquality)</code>, so beware!
</p>


<h3>Value</h3>

<p>It returns a formula where all macros have been expanded.
</p>


<h3>Dot square bracket operator in formulas</h3>

<p>In a formula, the dot square bracket (DSB) operator can: i) create manifold variables at once,
or ii) capture values from the current environment and put them verbatim in the formula.
</p>
<p>Say you want to include the variables <code>x1</code> to <code>x3</code> in your formula. You can use
<code>xpd(y ~ x.[1:3])</code> and you'll get <code>y ~ x1 + x2 + x3</code>.
</p>
<p>To summon values from the environment, simply put the variable in square brackets. For example:
<code>for(i in 1:3) xpd(y.[i] ~ x)</code> will create the formulas <code>y1 ~ x</code> to <code>y3 ~ x</code> depending on the
value of <code>i</code>.
</p>
<p>You can include a full variable from the environment in the same way:
<code>for(y in c("a", "b")) xpd(.[y] ~ x)</code> will create the two formulas <code>a ~ x</code> and <code>b ~ x</code>.
</p>
<p>The DSB can even be used within variable names, but then the variable must be nested in
character form. For example <code>y ~ .["x.[1:2]_sq"]</code> will create <code>y ~ x1_sq + x2_sq</code>. Using the
character form is important to avoid a formula parsing error. Double quotes must be used. Note
that the character string that is nested will be parsed with the function <code>dsb</code>, and thus it
will return a vector.
</p>
<p>By default, the DSB operator expands vectors into sums. You can add a comma, like in <code>.[, x]</code>,
to expand with commas–the content can then be used within functions. For instance:
<code>c(x.[, 1:2])</code> will create <code>c(x1, x2)</code> (and <em>not</em> <code>c(x1 + x2)</code>).
</p>
<p>In all <code>fixest</code> estimations, this special parsing is enabled, so you don't need to use <code>xpd</code>.
</p>
<p>One-sided formulas can be expanded with the DSB operator: let <code>x = ~sepal + petal</code>, then
<code>xpd(y ~ .[x])</code> leads to <code>color ~ sepal + petal</code>.
</p>
<p>You can even use multiple square brackets within a single variable, but then the use of nesting
is required. For example, the following <code>xpd(y ~ .[".[letters[1:2]]_.[1:2]"])</code> will create
<code>y ~ a_1 + b_2</code>. Remember that the nested character string is parsed with <code>dsb</code>,
which explains this behavior.
</p>
<p>When the element to be expanded i) is equal to the empty string or, ii) is of length 0, it is
replaced with a neutral element, namely <code>1</code>. For example, <code style="white-space: pre;">⁠x = "" ; xpd(y ~ .[x])⁠</code> leads to
<code>y ~ 1</code>.
</p>


<h3>Regular expressions</h3>

<p>You can catch several variable names at once by using regular expressions. To use regular
expressions, you need to enclose it in the dot-dot or the regex function: <code>..("regex")</code> or
<code>regex("regex")</code>. For example, <code>regex("Sepal")</code> will catch both the variables <code>Sepal.Length</code> and
<code>Sepal.Width</code> from the <code>iris</code> data set. In a <code>fixest</code> estimation, the variables names from which
the regex will be applied come from the data set. If you use <code>xpd</code>, you need to provide either a
data set or a vector of names in the argument <code>data</code>.
</p>
<p>By default the variables are aggregated with a sum. For example in a data set with the variables
x1 to x10, <code style="white-space: pre;">⁠regex("x(1|2)"⁠</code> will yield <code>x1 + x2 + x10</code>. You can instead ask for "comma"
aggregation by using a comma first, just before the regular expression:
<code>y ~ sw(regex(,"x(1|2)"))</code> would lead to <code>y ~ sw(x1, x2, x10)</code>.
</p>
<p>Note that the dot square bracket operator (DSB, see before) is applied before the regular
expression is evaluated. This means that <code>regex("x.[3:4]_sq")</code> will lead, after evaluation of
the DSB, to <code>regex("x3_sq|x4_sq")</code>. It is a handy way to insert range of numbers in a regular
expression.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p><code>setFixest_fml</code> to set formula macros, and <code>dsb</code> to modify character strings with the DSB operator.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Small examples with airquality data
data(airquality)
# we set two macro variables
setFixest_fml(..ctrl = ~ Temp + Day,
              ..ctrl_long = ~ poly(Temp, 2) + poly(Day, 2))

# Using the macro in lm with xpd:
lm(xpd(Ozone ~ Wind + ..ctrl), airquality)
lm(xpd(Ozone ~ Wind + ..ctrl_long), airquality)

# You can use the macros without xpd() in fixest estimations
a = feols(Ozone ~ Wind + ..ctrl, airquality)
b = feols(Ozone ~ Wind + ..ctrl_long, airquality)
etable(a, b, keep = "Int|Win")


# Using .[]

base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
i = 2:3
z = "species"
lm(xpd(y ~ x.[2:3] + .[z]), base)

# No xpd() needed in feols
feols(y ~ x.[2:3] + .[z], base)

#
# Auto completion with '..' suffix
#

# You can trigger variables autocompletion with the '..' suffix
# You need to provide the argument data
base = setNames(iris, c("y", "x1", "x2", "x3", "species"))
xpd(y ~ x.., data = base)

# In fixest estimations, this is automatically taken care of
feols(y ~ x.., data = base)


#
# You can use xpd for stepwise estimations
#

# Note that for stepwise estimations in fixest, you can use
# the stepwise functions: sw, sw0, csw, csw0
# -&gt; see help in feols or in the dedicated vignette

# we want to look at the effect of x1 on y
# controlling for different variables

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")

# We first create a matrix with all possible combinations of variables
my_args = lapply(names(base)[-(1:2)], function(x) c("", x))
(all_combs = as.matrix(do.call("expand.grid", my_args)))

res_all = list()
for(i in 1:nrow(all_combs)){
  res_all[[i]] = feols(xpd(y ~ x1 + ..v, ..v = all_combs[i, ]), base)
}

etable(res_all)
coefplot(res_all, group = list(Species = "^^species"))

#
# You can use macros to grep variables in your data set
#

# Example 1: setting a macro variable globally

data(longley)
setFixest_fml(..many_vars = grep("GNP|ployed", names(longley), value = TRUE))
feols(Armed.Forces ~ Population + ..many_vars, longley)

# Example 2: using ..("regex") or regex("regex") to grep the variables "live"

feols(Armed.Forces ~ Population + ..("GNP|ployed"), longley)

# Example 3: same as Ex.2 but without using a fixest estimation

# Here we need to use xpd():
lm(xpd(Armed.Forces ~ Population + regex("GNP|ployed"), data = longley), longley)

# Stepwise estimation with regex: use a comma after the parenthesis
feols(Armed.Forces ~ Population + sw(regex(,"GNP|ployed")), longley)

# Multiple LHS
etable(feols(..("GNP|ployed") ~ Population, longley))


#
# lhs and rhs arguments
#

# to create a one sided formula from a character vector
vars = letters[1:5]
xpd(rhs = vars)

# Alternatively, to replace the RHS
xpd(y ~ 1, rhs = vars)

# To create a two sided formula
xpd(lhs = "y", rhs = vars)

#
# argument 'add'
#

xpd(~x1, add = ~ x2 + x3)

# also works with character vectors
xpd(~x1, add = c("x2", "x3"))

# only adds to the RHS
xpd(y ~ x, add = ~bon + jour)

#
# Dot square bracket operator
#

# The basic use is to add variables in the formula
x = c("x1", "x2")
xpd(y ~ .[x])

# Alternatively, one-sided formulas can be used and their content will be inserted verbatim
x = ~x1 + x2
xpd(y ~ .[x])

# You can create multiple variables at once
xpd(y ~ x.[1:5] + z.[2:3])

# You can summon variables from the environment to complete variables names
var = "a"
xpd(y ~ x.[var])

# ... the variables can be multiple
vars = LETTERS[1:3]
xpd(y ~ x.[vars])

# You can have "complex" variable names but they must be nested in character form
xpd(y ~ .["x.[vars]_sq"])

# DSB can be used within regular expressions
re = c("GNP", "Pop")
xpd(Unemployed ~ regex(".[re]"), data = longley)

# =&gt; equivalent to regex("GNP|Pop")

# Use .[,var] (NOTE THE COMMA!) to expand with commas
# !! can break the formula if missused
vars = c("wage", "unemp")
xpd(c(y.[,1:3]) ~ csw(.[,vars]))


# Example of use of .[] within a loop
res_all = list()
for(p in 1:3){
  res_all[[p]] = feols(Ozone ~ Wind + poly(Temp, .[p]), airquality)
}

etable(res_all)

# The former can be compactly estimated with:
res_compact = feols(Ozone ~ Wind + sw(.[, "poly(Temp, .[1:3])"]), airquality)

etable(res_compact)

# How does it work?
# 1)  .[, stuff] evaluates stuff and, if a vector, aggregates it with commas
#     Comma aggregation is done thanks to the comma placed after the square bracket
#     If .[stuff], then aggregation is with sums.
# 2) stuff is evaluated, and if it is a character string, it is evaluated with
# the function dsb which expands values in .[]
#
# Wrapping up:
# 2) evaluation of dsb("poly(Temp, .[1:3])") leads to the vector:
#    c("poly(Temp, 1)", "poly(Temp, 2)", "poly(Temp, 3)")
# 1) .[, c("poly(Temp, 1)", "poly(Temp, 2)", "poly(Temp, 3)")] leads to
#    poly(Temp, 1), poly(Temp, 2), poly(Temp, 3)
#
# Hence sw(.[, "poly(Temp, .[1:3])"]) becomes:
#       sw(poly(Temp, 1), poly(Temp, 2), poly(Temp, 3))


#
# In non-fixest functions: guessing the data allows to use regex
#

# When used in non-fixest functions, the algorithm tries to "guess" the data
# so that ..("regex") can be directly evaluated without passing the argument 'data'
data(longley)
lm(xpd(Armed.Forces ~ Population + ..("GNP|ployed")), longley)

# same for the auto completion with '..'
lm(xpd(Armed.Forces ~ Population + GN..), longley)


</code></pre>


</div>