<div class="container">

<table style="width: 100%;"><tr>
<td>fit_glmpca_pois</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit Poisson GLM-PCA Model to Count Data</h2>

<h3>Description</h3>

<p>Fit a Poisson GLM-PCA model by maximum-likelihood.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit_glmpca_pois(
  Y,
  K,
  fit0 = init_glmpca_pois(Y, K),
  verbose = TRUE,
  control = list()
)

fit_glmpca_pois_control_default()

init_glmpca_pois(
  Y,
  K,
  U,
  V,
  X = numeric(0),
  Z = numeric(0),
  B = numeric(0),
  W = numeric(0),
  fixed_b_cols = numeric(0),
  fixed_w_cols = numeric(0),
  col_size_factor = TRUE,
  row_intercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>The n x m matrix of counts; all entries of <code>Y</code> should
be non-negative. It can be a sparse matrix (class
<code>"dgCMatrix"</code>) or dense matrix (class <code>"matrix"</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>Integer 1 or greater specifying the rank of the matrix
factorization. This should only be provided if the initial fit
(<code>fit0</code>) is not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit0</code></td>
<td>
<p>Initial model fit. It should be an object of class
“glmpca_fit_pois”, such as an output from
<code>init_glmpca_pois</code> or a previous call to
<code>fit_glmpca_pois</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, information about the
algorithm's progress is printed after each update.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>List of control parameters to modify behavior of
the optimization algorithm; see “Details”.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>An optional argument giving the initial estimate of the
loadings matrix. It should be an n x K matrix, where n is the
number of rows in the counts matrix <code>Y</code>, and K &gt; 0 is the rank
of the matrix factorization. When <code>U</code> and <code>V</code> are not
provided, input argument <code>K</code> should be specified instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>An optional argument giving is the initial estimate of the
factors matrix. It should be a m x K matrix, where m is the number
of columns in the counts matrix <code>Y</code>, and K &gt; 0 is the rank of
the matrix factorization. When <code>U</code> and <code>V</code> are not
provided, input argument <code>K</code> should be specified instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Optional argument giving row covariates of the count
matrix <code>Y</code>. It should be an n x nx matrix, where nx is
the number of row covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>Optional argument giving column covariates of the count
matrix <code>Y</code>. It should be an m x nz matrix, where nz is the
number of column covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Optional argument giving the initial estimates for the
coefficients of the row covariates. It should be an m x nx matrix,
where nx is the number of row covariates.
This argument is ignored if X is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Optional argument giving the initial estimates for the
coefficients of the column covariates.  It should be an n x nz matrix,
where nz is the number of column covariates.
This argument is ignored if Z is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_b_cols</code></td>
<td>
<p>Optional numeric vector specifying which
columns of <code>B</code> (if any) should be fixed during
optimization. This argument is ignored if X is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed_w_cols</code></td>
<td>
<p>Optional numeric vector specifying which
columns of <code>W</code> (if any) should be fixed during
optimization. This argument is ignored if Z is not provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_size_factor</code></td>
<td>
<p>If <code>col_size_factor = TRUE</code>, add a
fixed factor accounting for average differences in Poisson rates
across columns of <code>Y</code>. Setting <code>col_size_factor = TRUE</code>
and <code>row_intercept = TRUE</code> is intended to replicate the
default behavior of <code>glmpca</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_intercept</code></td>
<td>
<p>If <code>row_intercept = TRUE</code>, add a fixed
factor accounting for average differences in Poisson rates across
rows of <code>Y</code>. Setting <code>col_size_factor = TRUE</code>
and <code>row_intercept = TRUE</code> is intended to replicate the
default behavior of <code>glmpca</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In generalized principal component analysis (GLM-PCA)
based on a Poisson likelihood, the counts <code class="reqn">y_{ij}</code> stored in an
<code class="reqn">n \times m</code> matrix <code class="reqn">Y</code> are modeled as </p>
<p style="text-align: center;"><code class="reqn">y_{ij}
\sim Pois(\lambda_{ij}),</code>
</p>
<p> in which the logarithm of each rate
parameter <code class="reqn">\lambda_{ij}</code> is defined as a linear combination of
rank-K matrices to be estimated from the data: </p>
<p style="text-align: center;"><code class="reqn">\log
\lambda_{ij} = (UDV')_{ij},</code>
</p>
<p> where <code class="reqn">U</code> and <code class="reqn">V</code> are
orthogonal matrices of dimension <code class="reqn">n \times K</code> and <code class="reqn">m
\times K</code>, respectively, and <code class="reqn">D</code> is a diagonal <code class="reqn">K
\times K</code> matrix in which the entries along its diagonal are
positive and decreasing. <code class="reqn">K</code> is a tuning parameter specifying
the rank of the matrix factorization. This is the same as the
low-rank matrix decomposition underlying PCA (that is, the singular
value decomposition), but because we are not using a linear
(Gaussian) model, this is called “generalized PCA” or
“GLM PCA”.
</p>
<p>To allow for additional components that may be fixed,
<code>fit_glmpca_pois</code> can also fit the more general model
</p>
<p style="text-align: center;"><code class="reqn">\log \lambda_{ij} = (UDV' + XB' + WZ')_{ij},</code>
</p>
<p> in which
<code class="reqn">X</code>, <code class="reqn">Z</code> are fixed matrices of dimension <code class="reqn">n \times
n_x</code> and <code class="reqn">m \times n_z</code>, respectively, and
<code class="reqn">B</code>, <code class="reqn">W</code> are matrices of dimension <code class="reqn">m \times n_x</code> and <code class="reqn">n \times n_z</code> to be estimated from the data.
</p>
<p><code>fit_glmpca_pois</code> computes maximum-likelihood estimates (MLEs)
of <code class="reqn">U</code>, <code class="reqn">V</code>, <code class="reqn">D</code>, <code class="reqn">B</code> and <code class="reqn">W</code> satistifying the
orthogonality constraints for <code class="reqn">U</code> and <code class="reqn">V</code> and the
additional constraints on <code class="reqn">D</code> that the entries are positive and
decreasing. This is accomplished by iteratively fitting a series of
Poisson GLMs, where each of these individual Poissons GLMs is fitted
using a fast “cyclic co-ordinate descent” (CCD) algorithm.
</p>
<p>The <code>control</code> argument is a list in which any of the following
named components will override the default optimization algorithm
settings (as they are defined by
<code>fit_glmpca_pois_control_default</code>). Additional control
arguments not listed here can be used to control the behaviour of
<code>fpiter</code> or <code>daarem</code>; see
the help accompanying these functions for details.
</p>

<dl>
<dt><code>use_daarem</code></dt>
<dd>
<p>If <code>use_daarem = TRUE</code>, the updates
are accelerated using DAAREM; see <code>daarem</code> for
details.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>This is the value of the “tol” control
argument for <code>fpiter</code> or
<code>daarem</code> that determines when to stop the
optimization. In brief, the optimization stops when the change in
the estimates or in the log-likelihood between two successive
updates is less than “tol”.</p>
</dd>
<dt><code>maxiter</code></dt>
<dd>
<p>This is the value of the “maxiter”
control argument for <code>fpiter</code> or
<code>daarem</code>. In brief, it sets the upper limit on
the number of CCD updates.</p>
</dd>
<dt><code>convtype</code></dt>
<dd>
<p>This is the value of the “convtype”
control argument for <code>daarem</code>. It determines
whether the stopping criterion is based on the change in the
estimates or the change in the log-likelihood between two
successive updates.</p>
</dd>
<dt><code>mon.tol</code></dt>
<dd>
<p>This is the value of the “mon.tol”
control argument for <code>daarem</code>. This setting
determines to what extent the monotonicity condition can be
violated.</p>
</dd>
<dt><code>num_ccd_iter</code></dt>
<dd>
<p>Number of co-ordinate descent updates to
be made to parameters at each iteration of the algorithm.</p>
</dd>
<dt><code>line_search</code></dt>
<dd>
<p>If <code>line_search = TRUE</code>, a
backtracking line search is performed at each iteration of CCD to
guarantee improvement in the objective (the log-likelihood).</p>
</dd>
<dt><code>ls_alpha</code></dt>
<dd>
<p>alpha parameter for backtracking line search.
(Should be a number between 0 and 0.5, typically a number near
zero.)</p>
</dd>
<dt><code>ls_beta</code></dt>
<dd>
<p>beta parameter for backtracking line search
controlling the rate at which the step size is decreased.
(Should be a number between 0 and 0.5.)</p>
</dd>
<dt><code>calc_deriv</code></dt>
<dd>
<p>If <code>calc_deriv = TRUE</code>, the maximum
gradient of <code class="reqn">U</code> and <code class="reqn">V</code> is calculated and stored after each
update. This may be useful for assessing convergence of the
optimization, though increases overhead.</p>
</dd>
<dt><code>calc_max_diff</code></dt>
<dd>
<p>If <code>calc_max_diff = TRUE</code>, the
largest change in <code class="reqn">U</code> and <code class="reqn">V</code> after each update is
calculated and stored. This may be useful for monitoring progress
of the optimization algorithm.</p>
</dd>
<dt><code>orthonormalize</code></dt>
<dd>
<p>If <code>orthonormalize = TRUE</code>, the
matrices <code class="reqn">U</code> and <code class="reqn">V</code> are made to be orthogonal after each
update step. This improves the speed of convergence without the
DAAREM acceleration; however, should not be used when
<code>use_daarem = TRUE</code>.</p>
</dd>
</dl>
<p>You may use function <code>set_fastglmpca_threads</code> to adjust
the number of threads used in performing the updates.
</p>


<h3>Value</h3>

<p>An object capturing the state of the model fit. It contains
estimates of <code class="reqn">U</code>, <code class="reqn">V</code> and <code class="reqn">D</code> (stored as matrices
<code>U</code>, <code>V</code> and a vector of diagonal entries <code>d</code>,
analogous to the <code>svd</code> return value); the other
parameters (<code class="reqn">X</code>, <code class="reqn">B</code>, <code class="reqn">Z</code>, <code class="reqn">W</code>); the log-likelihood
achieved (<code>loglik</code>); information about which columns of
<code class="reqn">B</code> and <code class="reqn">W</code> are fixed (<code>fixed_b_cols</code>,
<code>fixed_w_cols</code>); and a data frame <code>progress</code> storing
information about the algorithm's progress after each update.
</p>


<h3>References</h3>

<p>Townes, F. W., Hicks, S. C., Aryee, M. J. and Irizarry,
R. A. (2019). Feature selection and dimension reduction for
single-cell RNA-Seq based on a multinomial model. <em>Genome Biology</em>
<b>20</b>, 295. <a href="https://doi.org/10.1186/s13059-019-1861-6">doi:10.1186/s13059-019-1861-6</a>
</p>
<p>Collins, M., Dasgupta, S. and Schapire, R. E. (2002). A
generalization of principal components analysis to the exponential
family. In <em>Advances in Neural Information Processing Systems</em> 14.
</p>


<h3>See Also</h3>

<p><code>fit_glmpca_pois</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n &lt;- 200
p &lt;- 100
K &lt;- 3
dat  &lt;- generate_glmpca_data_pois(n,p,K)
fit0 &lt;- init_glmpca_pois(dat$Y,K)
fit  &lt;- fit_glmpca_pois(dat$Y,fit0 = fit0)

</code></pre>


</div>