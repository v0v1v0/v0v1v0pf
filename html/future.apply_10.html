<div class="container">

<table style="width: 100%;"><tr>
<td>future_eapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a Function over a List or Vector via Futures</h2>

<h3>Description</h3>

<p><code>future_lapply()</code> implements <code>base::lapply()</code> using futures with perfect
replication of results, regardless of future backend used.
Analogously, this is true for all the other <code>future_nnn()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">future_eapply(
  env,
  FUN,
  ...,
  all.names = FALSE,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.label = "future_eapply-%d"
)

future_lapply(
  X,
  FUN,
  ...,
  future.envir = parent.frame(),
  future.stdout = TRUE,
  future.conditions = "condition",
  future.globals = TRUE,
  future.packages = NULL,
  future.seed = FALSE,
  future.scheduling = 1,
  future.chunk.size = NULL,
  future.label = "future_lapply-%d"
)

future_replicate(
  n,
  expr,
  simplify = "array",
  future.seed = TRUE,
  ...,
  future.envir = parent.frame(),
  future.label = "future_replicate-%d"
)

future_sapply(
  X,
  FUN,
  ...,
  simplify = TRUE,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.label = "future_sapply-%d"
)

future_tapply(
  X,
  INDEX,
  FUN = NULL,
  ...,
  default = NA,
  simplify = TRUE,
  future.envir = parent.frame(),
  future.label = "future_tapply-%d"
)

future_vapply(
  X,
  FUN,
  FUN.VALUE,
  ...,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.label = "future_vapply-%d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> environment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function taking at least one argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all.names</code></td>
<td>
<p>If <code>TRUE</code>, the function will also be applied to variables
that start with a period (<code>.</code>), otherwise not.
See <code>base::eapply()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>USE.NAMES</code></td>
<td>
<p>See <code>base::sapply()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.envir</code></td>
<td>
<p>An environment passed as argument <code>envir</code> to
<code>future::future()</code> as-is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.label</code></td>
<td>
<p>If a character string, then each future is assigned
a label <code>sprintf(future.label, chunk_idx)</code>.  If TRUE, then the
same as <code>future.label = "future_lapply-%d"</code>.  If FALSE, no labels
are assigned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> object for which a <code>split</code> method
exists.  Typically vector-like, allowing subsetting with
<code>[</code>, or a data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.stdout</code></td>
<td>
<p>If <code>TRUE</code> (default), then the standard output of the
underlying futures is captured, and re-outputted as soon as possible.
If <code>FALSE</code>, any output is silenced (by sinking it to the null device
as it is outputted).
If <code>NA</code> (not recommended), output is <em>not</em> intercepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.conditions</code></td>
<td>
<p>A character string of conditions classes to be
captured and relayed.  The default is the same as the <code>condition</code>
argument of <code>future::Future()</code>.
To not intercept conditions, use <code>conditions = character(0L)</code>.
Errors are always relayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.globals</code></td>
<td>
<p>A logical, a character vector, or a named list for
controlling how globals are handled. For details, see below section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the R environment evaluating the future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven),
or a list of <code>length(X)</code> with pre-generated random seeds.
For details, see below section.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.scheduling</code></td>
<td>
<p>Average number of futures ("chunks") per worker.
If <code>0.0</code>, then a single future is used to process all elements
of <code>X</code>.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures
(if there are enough elements in <code>X</code>).
If <code>Inf</code> or <code>FALSE</code>, then one future per element of
<code>X</code> is used.
Only used if <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.chunk.size</code></td>
<td>
<p>The average number of elements per future ("chunk").
If <code>Inf</code>, then all elements are processed in a single future.
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of replicates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>An <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> expression to evaluate repeatedly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>See <code>base::sapply()</code> and <code>base::tapply()</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>INDEX</code></td>
<td>
<p>A list of one or more factors, each of same length as <code>X</code>.
The elements are coerced to <code>factor</code>s by
<code>as.factor()</code>. Can also be a formula, which
is useful if <code>X</code> is a data frame; see the <code>f</code> argument in
<code>split()</code> for interpretation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default</code></td>
<td>
<p>See <code>base::tapply()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN.VALUE</code></td>
<td>
<p>A template for the required return value from
each <code>FUN(X[ii], ...)</code>.
Types may be promoted to a higher type within the ordering
logical &lt; integer &lt; double &lt; complex, but not demoted.
See <code>base::vapply()</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) Additional arguments passed to <code>FUN()</code>.
For <code>future_*apply()</code> functions and <code>replicate()</code>, any <code style="white-space: pre;">⁠future.*⁠</code> arguments
part of <code style="white-space: pre;">⁠\ldots⁠</code> are passed on to <code>future_lapply()</code> used internally.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A named (unless <code>USE.NAMES = FALSE</code>) list.
See <code>base::eapply()</code> for details.
</p>
<p>For <code>future_lapply()</code>, a list with same length and names as <code>X</code>.
See <code>base::lapply()</code> for details.
</p>
<p><code>future_replicate()</code> is a wrapper around <code>future_sapply()</code> and return
simplified object according to the <code>simplify</code> argument.
See <code>base::replicate()</code> for details.
Since <code>future_replicate()</code> usually involves random number generation (RNG),
it uses <code>future.seed = TRUE</code> by default in order produce sound random
numbers regardless of future backend and number of background workers used.
</p>
<p>For <code>future_sapply()</code>, a vector with same length and names as <code>X</code>.
See <code>base::sapply()</code> for details.
</p>
<p><code>future_tapply()</code> returns an array with mode <code>"list"</code>, unless
<code>simplify = TRUE</code> (default) <em>and</em> <code>FUN</code> returns a scalar, in which
case the mode of the array is the same as the returned scalars.
See <code>base::tapply()</code> for details.
</p>
<p>For <code>future_vapply()</code>, a vector with same length and names as <code>X</code>.
See <code>base::vapply()</code> for details.
</p>


<h3>Global variables</h3>

<p>Argument <code>future.globals</code> may be used to control how globals
should be handled similarly how the <code>globals</code> argument is used with
<code>future()</code>.
Since all function calls use the same set of globals, this function can do
any gathering of globals upfront (once), which is more efficient than if
it would be done for each future independently.
If <code>TRUE</code> (default), then globals are automatically identified and gathered.
If a character vector of names is specified, then those globals are gathered.
If a named list, then those globals are used as is.
In all cases, <code>FUN</code> and any <code style="white-space: pre;">⁠\ldots⁠</code> arguments are automatically
passed as globals to each future created as they are always needed.
</p>


<h3>Reproducible random number generation (RNG)</h3>

<p>Unless <code>future.seed</code> is <code>FALSE</code> or <code>NULL</code>, this function guarantees to
generate the exact same sequence of random numbers <em>given the same initial
seed / RNG state</em> - this regardless of type of futures, scheduling
("chunking") strategy, and number of workers.
</p>
<p>RNG reproducibility is achieved by pregenerating the random seeds for all
iterations (over <code>X</code>) by using L'Ecuyer-CMRG RNG streams.  In each
iteration, these seeds are set before calling <code>FUN(X[[ii]], ...)</code>.
<em>Note, for large <code>length(X)</code> this may introduce a large overhead.</em>
</p>
<p>If <code>future.seed = TRUE</code>, then <code>.Random.seed</code>
is used if it holds a L'Ecuyer-CMRG RNG seed, otherwise one is created
randomly.
</p>
<p>If <code>future.seed = FALSE</code>, it is expected that none of the
<code>FUN(X[[ii]], ...)</code> function calls use random number generation.
If they do, then an informative warning or error is produces depending
on settings. See future::future for more details.
Using <code>future.seed = NULL</code>, is like <code>future.seed = FALSE</code> but without
the check whether random numbers were generated or not.
</p>
<p>As input, <code>future.seed</code> may also take a fixed initial seed (integer),
either as a full L'Ecuyer-CMRG RNG seed (vector of 1+6 integers), or
as a seed generating such a full L'Ecuyer-CMRG seed. This seed will
be used to generated <code>length(X)</code> L'Ecuyer-CMRG RNG streams.
</p>
<p>In addition to the above, it is possible to specify a pre-generated
sequence of RNG seeds as a list such that
<code>length(future.seed) == length(X)</code> and where each element is an
integer seed vector that can be assigned to
<code>.Random.seed</code>.  One approach to generate a
set of valid RNG seeds based on fixed initial seed (here <code>42L</code>) is:
</p>
<div class="sourceCode r"><pre>seeds &lt;- future_lapply(seq_along(X), FUN = function(x) .Random.seed,
                       future.chunk.size = Inf, future.seed = 42L)
</pre></div>
<p><strong>Note that <code>as.list(seq_along(X))</code> is <em>not</em> a valid set of such
<code>.Random.seed</code> values.</strong>
</p>
<p>In all cases but <code>future.seed = FALSE</code> and <code>NULL</code>, the RNG state of the
calling R processes after this function returns is guaranteed to be
"forwarded one step" from the RNG state that was before the call and
in the same way regardless of <code>future.seed</code>, <code>future.scheduling</code>
and future strategy used.  This is done in order to guarantee that an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
script calling <code>future_lapply()</code> multiple times should be numerically
reproducible given the same initial seed.
</p>


<h3>Control processing order of elements</h3>

<p>Attribute <code>ordering</code> of <code>future.chunk.size</code> or <code>future.scheduling</code> can
be used to control the ordering the elements are iterated over, which
only affects the processing order and <em>not</em> the order values are returned.
This attribute can take the following values:
</p>

<ul>
<li>
<p> index vector - an numeric vector of length <code>length(X)</code>
</p>
</li>
<li>
<p> function     - an function taking one argument which is called as
<code>ordering(length(X))</code> and which must return an
index vector of length <code>length(X)</code>, e.g.
<code>function(n) rev(seq_len(n))</code> for reverse ordering.
</p>
</li>
<li> <p><code>"random"</code>   - this will randomize the ordering via random index
vector <code>sample.int(length(X))</code>.
For example, <code>future.scheduling = structure(TRUE, ordering = "random")</code>.
<em>Note</em>, when elements are processed out of order, then captured standard
output and conditions are also relayed in that order, that is out of order.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>The implementations of <code>future_replicate()</code>, <code>future_sapply()</code>, and
<code>future_tapply()</code> are adopted from the source code of the corresponding
base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> functions, which are licensed under GPL (&gt;= 2) with
'The R Core Team' as the copyright holder.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ---------------------------------------------------------
## lapply(), sapply(), tapply()
## ---------------------------------------------------------
x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
y0 &lt;- lapply(x, FUN = quantile, probs = 1:3/4)
y1 &lt;- future_lapply(x, FUN = quantile, probs = 1:3/4)
print(y1)
stopifnot(all.equal(y1, y0))

y0 &lt;- sapply(x, FUN = quantile)
y1 &lt;- future_sapply(x, FUN = quantile)
print(y1)
stopifnot(all.equal(y1, y0))

y0 &lt;- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
y1 &lt;- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
print(y1)
stopifnot(all.equal(y1, y0))


## ---------------------------------------------------------
## Parallel Random Number Generation
## ---------------------------------------------------------

## Regardless of the future plan, the number of workers, and
## where they are, the random numbers produced are identical

plan(multisession)
set.seed(0xBEEF)
y1 &lt;- future_lapply(1:5, FUN = rnorm, future.seed = TRUE)
str(y1)

plan(sequential)
set.seed(0xBEEF)
y2 &lt;- future_lapply(1:5, FUN = rnorm, future.seed = TRUE)
str(y2)

stopifnot(all.equal(y1, y2))



## ---------------------------------------------------------
## Process chunks of data.frame rows in parallel
## ---------------------------------------------------------
iris &lt;- datasets::iris
chunks &lt;- split(iris, seq(1, nrow(iris), length.out = 3L))
y0 &lt;- lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length))
y0 &lt;- do.call(sum, y0)
y1 &lt;- future_lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length))
y1 &lt;- do.call(sum, y1)
print(y1)
stopifnot(all.equal(y1, y0))



</code></pre>


</div>