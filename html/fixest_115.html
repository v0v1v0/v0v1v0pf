<div class="container">

<table style="width: 100%;"><tr>
<td>ref</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Refactors a variable</h2>

<h3>Description</h3>

<p>Takes a variables of any types, transforms it into a factors, and modifies the values
of the factors. Useful in estimations when you want to set some value of a vector as a reference.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ref(x, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector of any type (must be atomic though).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ref</code></td>
<td>
<p>A vector or a list, or special binning values (explained later). If a vector,
it must correspond to (partially matched) values of the vector <code>x</code>. The vector <code>x</code> which
will be transformed into a factor and these values will be placed first in the levels.
That's the main usage of this function. You can also bin on-the-fly the values of <code>x</code>,
using the same syntax as the function <code>bin</code>. To create a new value from old values,
use <code>ref = list("new_value"=old_values)</code> with <code>old_values</code> a vector of existing values.
You can use <code>.()</code> for <code>list()</code>.
It accepts regular expressions, but they must start with an <code>"@"</code>, like in <code>ref="@Aug|Dec"</code>.
It accepts one-sided formulas which must contain the variable <code>x</code>,
e.g. <code>ref=list("&lt;2" = ~x &lt; 2)</code>.
The names of the list are the new names. If the new name is missing, the first
value matched becomes the new name. In the name, adding <code>"@d"</code>, with <code>d</code> a digit,
will relocate the value in position <code>d</code>: useful to change the position of factors.
If the vector <code>x</code> is numeric, you can use the special value <code>"bin::digit"</code> to group
every <code>digit</code> element.
For example if <code>x</code> represents years, using <code>ref="bin::2"</code> creates bins of two years.
With any data, using <code>"!bin::digit"</code> groups every digit consecutive values starting
from the first value.
Using <code>"!!bin::digit"</code> is the same but starting from the last value.
With numeric vectors you can: a) use <code>"cut::n"</code> to cut the vector into <code>n</code> equal parts,
b) use <code>"cut::a]b["</code> to create the following bins: <code style="white-space: pre;">⁠[min, a]⁠</code>, <code style="white-space: pre;">⁠]a, b[⁠</code>, <code style="white-space: pre;">⁠[b, max]⁠</code>.
The latter syntax is a sequence of number/quartile (q0 to q4)/percentile (p0 to p100)
followed by an open or closed square bracket. You can add custom bin names by
adding them in the character vector after <code>'cut::values'</code>. See details and examples.
Dot square bracket expansion (see <code>dsb</code>) is enabled.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>It returns a factor of the same length as <code>x</code>, where levels have been modified according
to the argument <code>ref</code>.
</p>


<h3>"Cutting" a numeric vector</h3>

<p>Numeric vectors can be cut easily into: a) equal parts, b) user-specified bins.
</p>
<p>Use <code>"cut::n"</code> to cut the vector into <code>n</code> (roughly) equal parts. Percentiles are
used to partition the data, hence some data distributions can lead to create less
than <code>n</code> parts (for example if P0 is the same as P50).
</p>
<p>The user can specify custom bins with the following syntax: <code>"cut::a]b]c]"</code>. Here
the numbers <code>a</code>, <code>b</code>, <code>c</code>, etc, are a sequence of increasing numbers, each followed
by an open or closed square bracket. The numbers can be specified as either
plain numbers (e.g. <code>"cut::5]12[32["</code>), quartiles (e.g. <code>"cut::q1]q3["</code>),
or percentiles (e.g. <code>"cut::p10]p15]p90]"</code>). Values of different types can be mixed:
<code>"cut::5]q2[p80["</code> is valid provided the median (<code>q2</code>) is indeed greater
than <code>5</code>, otherwise an error is thrown.
</p>
<p>The square bracket right of each number tells whether the numbers should be included
or excluded from the current bin. For example, say <code>x</code> ranges from 0 to 100,
then <code>"cut::5]"</code> will create two  bins: one from 0 to 5 and a second from 6 to 100.
With <code>"cut::5["</code> the bins would have been 0-4 and 5-100.
</p>
<p>A factor is always returned. The labels always report the min and max values in each bin.
</p>
<p>To have user-specified bin labels, just add them in the character vector
following <code>'cut::values'</code>. You don't need to provide all of them, and <code>NA</code> values
fall back to the default label. For example, <code>bin = c("cut::4", "Q1", NA, "Q3")</code>
will modify only the first and third label that will be displayed as <code>"Q1"</code> and <code>"Q3"</code>.
</p>


<h3>
<code>bin</code> vs <code>ref</code>
</h3>

<p>The functions <code>bin</code> and <code>ref</code> are able to do the same thing, then why use one
instead of the other? Here are the differences:
</p>

<ul>
<li> <p><code>ref</code> always returns a factor. This is in contrast with <code>bin</code> which returns,
when possible, a vector of the same type as the vector in input.
</p>
</li>
<li> <p><code>ref</code> always places the values modified in the first place of the factor levels.
On the other hand, <code>bin</code> tries to not modify the ordering of the levels. It is possible
to make <code>bin</code> mimic the behavior of <code>ref</code> by adding an <code>"@"</code> as the first element of
the list in the argument <code>bin</code>.
</p>
</li>
<li>
<p> when a vector (and not a list) is given in input, <code>ref</code> will place each element of
the vector in the first place of the factor levels. The behavior of <code>bin</code> is
totally different, <code>bin</code> will transform all the values in the vector into a single
value in <code>x</code> (i.e. it's binning).
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>See Also</h3>

<p>To bin the values of a vector: <code>bin</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(airquality)

# A vector of months
month_num = airquality$Month
month_lab = c("may", "june", "july", "august", "september")
month_fact = factor(month_num, labels = month_lab)
table(month_num)
table(month_fact)

#
# Main use
#

# Without argument: equivalent to as.factor
ref(month_num)

# Main usage: to set a level first:
# (Note that partial matching is enabled.)
table(ref(month_fact, "aug"))

# You can rename the level on-the-fly
# (Northern hemisphere specific!)
table(ref(month_fact, .("Hot month"="aug",
                        "Late summer" = "sept")))


# Main use is in estimations:
a = feols(Petal.Width ~ Petal.Length + Species, iris)

# We change the reference
b = feols(Petal.Width ~ Petal.Length + ref(Species, "vers"), iris)

etable(a, b)


#
# Binning
#

# You can also bin factor values on the fly
# Using @ first means a regular expression will be used to match the values.
# Note that the value created is placed first.
# To avoid that behavior =&gt; use the function "bin"
table(ref(month_fact, .(summer = "@jul|aug|sep")))

# Please refer to the example in the bin help page for more example.
# The syntax is the same.


#
# Precise relocation
#

# You can place a factor at the location you want
#  by adding "@digit" in the name first:
table(ref(month_num, .("@5"=5)))

# Same with renaming
table(ref(month_num, .("@5 five"=5)))


</code></pre>


</div>