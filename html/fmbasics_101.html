<div class="container">

<table style="width: 100%;"><tr>
<td>CurrencyPairMethods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>CurrencyPair methods</h2>

<h3>Description</h3>

<p>A collection of methods related to currency pairs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">is_t1(x)

to_spot(dates, x)

to_spot_next(dates, x)

to_forward(dates, tenor, x)

to_today(dates, x)

to_tomorrow(dates, x)

to_fx_value(dates, tenor, x)

invert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a <code>CurrencyPair</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dates</code></td>
<td>
<p>a vector of dates from which forward dates are calculated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tenor</code></td>
<td>
<p>the tenor of the value date which can be one of the following:
"spot", "spot_next", "today", "tomorrow" and the usual "forward" dates (e.g.
<code>lubridate::months(3)</code>)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The methods are summarised as follows:
</p>

<ul>
<li> <p><code>is_t1</code>: Returns <code>TRUE</code> if the currency pair settles one good day after
trade. This includes the following currencies crossed with the USD: CAD, TRY,
PHP, RUB, KZT and PKR
</p>
</li>
<li> <p><code>to_spot</code>: The spot dates are usually two non-NY good day after today.
<code>is_t1()</code> identifies the pairs whose spot dates are conventionally one good
non-NYC day after today. In both cases, if those dates are not a good NYC
day, they are rolled to good NYC and non-NYC days using the Following
convention.
</p>
</li>
<li> <p><code>to_spot_next</code>: The spot next dates are one good NYC and non-NYC day after
spot rolled using the Following convention if necessary.
</p>
</li>
<li> <p><code>to_forward</code>: Forward dates are determined using the calendar's <code>shift()</code>
method rolling bad NYC and non-NYC days using the Following convention. The
end-to-end convention applies.
</p>
</li>
<li> <p><code>to_today</code>: Today is simply dates which are good NYC and non-NYC days.
Otherwise today is undefined and returns <code>NA</code>.
</p>
</li>
<li> <p><code>to_tomorrow</code>: Tomorrow is one good NYC and non-NYC day except where that
is on or after spot. In that case, is is undefined and returns <code>NA</code>.
</p>
</li>
<li> <p><code>to_value</code>: Determine common value dates. The supported value date <code>tenors</code>
are: "spot", "spot_next", "today", "tomorrow" and the usual
"forward" dates (e.g. <code>lubridate::months(3)</code>).
</p>
</li>
<li> <p><code>invert</code>: Inverts the currency pair and returns new <code>CurrencyPair</code> object.
</p>
</li>
<li> <p><code>is.CurrencyPair</code>:  Returns <code>TRUE</code> if <code>x</code> inherits from the <code>CurrencyPair</code>
class; otherwise <code>FALSE</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(lubridate)
is_t1(AUDUSD())
dts &lt;- lubridate::ymd(20170101) + lubridate::days(0:30)
to_spot(dts, AUDUSD())
to_spot_next(dts, AUDUSD())
to_today(dts, AUDUSD())
to_tomorrow(dts, AUDUSD())
to_fx_value(dts, months(3), AUDUSD())
</code></pre>


</div>