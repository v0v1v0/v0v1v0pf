<div class="container">

<table style="width: 100%;"><tr>
<td>ddm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of 5-Parameter DDM</h2>

<h3>Description</h3>

<p>Fit the 5-parameter DDM (Diffusion Decision Model) via maximum likelihood
estimation. The model for each DDM parameter can be specified symbolically
using R's formula interface. With the exception of the drift rate (which is
always estimated) all parameters can be either fixed or estimates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ddm(
  drift,
  boundary = ~1,
  ndt = ~1,
  bias = 0.5,
  sv = 0,
  data,
  optim = "nlminb",
  args_optim = list(init = NULL, lo_bds = NULL, up_bds = NULL, control = list()),
  args_ddm = list(err_tol = 1e-06),
  use_gradient = TRUE,
  compiled_model = TRUE,
  model = TRUE,
  mmatrix = TRUE,
  response = TRUE,
  na.action,
  subset,
  contrasts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>drift</code></td>
<td>
<p>Two-sided formula. The left-hand side describes the response,
the right-hand side provides a symbolic description of the regression model
underlying the drift rate (v). The left-hand side needs to specify the
column in the data containing response time and corresponding binary
decision, concatenated by <code>+</code> , e.g., <code>rt + response ~ ...</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary, ndt, bias, sv</code></td>
<td>
<p>Either a one-sided formula providing a symbolic
description of the regression model or a scalar number given the value this
parameter should be fixed to. Boundary separation (a), non-decision time
(t0), relative initial bias (w), or inter-trial variability in the drift
rate (sv)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data, na.action, subset</code></td>
<td>
<p>arguments controlling formula processing via
<code>model.frame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>character string or fitting function indicating which numerical
optimization method should be used. The default <code>"nlminb"</code> uses the
corresponding function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args_optim</code></td>
<td>
<p>named list of additional arguments for the optimization
function. The available options are:
</p>

<ul>
<li> <p><code>init</code> vector containing the initial values to be used in the
optimization for each coefficient. Note that the number and type of
coefficients used (i.e., intercept or difference) is determined by
the model matrices, which are in turn determined by the formulas
assigned to each DDM parameter (see the Details section for an
overview of formulas and coefficients). For an example, run the
<code>ddm()</code> function with parameter set to its default value, and
view the initial value vector via the slot
<code>$optim_info$args_optim$init</code>. By default for intercept
coefficients, the initial values for the drift rate (v), boundary
separation (a), and non-decision time (t0) will be generated using
EZ-Diffusion (Wagenmakers et al. 2007); bias (w) is initialized to
<code>0.5</code>; inter-trial variability in the drift rate (sv) is
initialized to <code>0.0</code>. Difference coefficients are initialized
to <code>0.0</code>.
</p>
</li>
<li> <p><code>lo_bds</code> vector containing the lower bounds to be used in the
optimization for each coefficient. The same consideration of
coefficient types occurs here as it does with <code>init</code>. The
defaults for intercept coefficients are: drift rate
<code>v &gt; -Inf</code>, boundary separation <code>a &gt; 0</code>, non-decision
time <code>t0 &gt; 0</code>, bias <code>w &gt; 0</code>, inter-trial variability in
the drift rate <code>sv</code> <code class="reqn"> \le 0</code>. All difference coefficients
have a lower bound of <code>-Inf</code>.
</p>
</li>
<li> <p><code>up_bds</code> vector containing the upper bounds to be used in the
optimization for each coefficient. The same consideration of
coefficient types occurs here as it does with <code>init</code>. The
defaults for intercept coefficients are: drift rate
<code>v &lt; Inf</code>, boundary separation <code>a &lt; Inf</code>, non-decision
time <code>t0 &lt; Inf</code>, bias <code>w &lt; 1</code>, inter-trial variability in
the drift rate <code>sv &lt; Inf</code>. All difference coefficients have a
upper bound of <code>Inf</code>.
</p>
</li>
<li> <p><code>control</code> additional control arguments passed to
<code>control</code> argument of optimization function specified in
<code>optim</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args_ddm</code></td>
<td>
<p>named list of additional arguments passed to density function
calculation. Currently, the only option for this is <code>err_tol</code>, the
desired error tolerance used in the density function calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_gradient</code></td>
<td>
<p>logical. Should gradient be used during numerical
optimization? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compiled_model, model, mmatrix, response</code></td>
<td>
<p>logicals. If <code>TRUE</code> the
corresponding components of the fit (the compiled model object, the model
frame, the model matrix, the response matrix) are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrasts</code></td>
<td>
<p>optional list. See the contrasts.arg of
<code>model.matrix.default</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>ddm</code> uses <code>model.matrix</code> for transforming the
symbolic description of the regression model underlying each parameter into
estimated coefficients. The following provides a few examples:
</p>

<ul>
<li> <p><code>~ 1</code> estimates a single coefficient, named <code>(Intercept)</code>
</p>
</li>
<li> <p><code>~ condition</code> estimates the intercept plus k - 1 coefficients
for a factor with k levels (e.g., intercept plus one coefficient if
condition has two levels). The interpretation of the coefficients
depend on the factor contrasts employed, which are usually based on
the contrasts specified in <code>options("contrasts")</code>. For the
default <code>treatment</code> contrasts (<code>contr.treatment</code>),
the intercept corresponds to the first factor level and the
additional coefficients correspond to the difference from the
intercept (i.e., first factor level). When using <code>contr.sum</code>
the intercept corresponds to the grand mean and the additional
coefficients correspond to the differences from the grand mean.
</p>
</li>
<li> <p><code>~ 0 + condition</code> estimates no intercept but one coefficient
per factor level. This specification can also be used to get one
coefficient per cell for a multi-factorial design, e.g.,
<code>~ 0 + condition1:condition2</code>.
</p>
</li>
<li> <p><code>~ 0 + condition1 + condition1:condition2</code> estimates one
"intercept" per level of <code>condition1</code> factor (which is not
called intercept) plus k - 1 difference parameters from the
condition-specific intercept for the k-levels of <code>condition2</code>.
The interpretation of the difference parameters again depends on
the contrasts used (e.g., treatment vs. sum-to-zero contrasts, see
examples). This formula specification can often make sense for the
drift rate when <code>condition1</code> is the factor (such as item type)
mapped to upper and lower response boundary of the DDM and
<code>condition2</code> is another factor by which we want the drift rate
to differ. This essentially gives one overall drift rate per
response boundary plus the differences from this overall one (note
again that with treatment contrasts this overall drift rate is the
first factor level of <code>condition2</code>).
</p>
</li>
</ul>
<p>To get meaningful results it is necessary to estimate separate drift rates
for the different condition/item-types that are mapped onto the upper and
lower boundary of the diffusion model.
</p>
<p>If a non-default fitting function is used, it needs to minimize the
negative log-likelihood, accept the following arguments,
<code>init, objective, gradient, lower, upper, control</code> , and return a list
with the following arguments <code>coefficients, loglik, converged, optim</code>
(where <code>converged</code> is boolean and <code>optim</code> can be an arbitrary
list with additional information).
</p>


<h3>Value</h3>

<p>Object of class <code>ddm</code> (i.e., a list with components as listed
below) for which a number of common methods such as <code>print</code>,
<code>coef</code>, and <code>logLik</code> are implemented, see
<code>ddm-methods</code>.
</p>

<ul>
<li> <p><code>coefficients</code> a named list whose elements are the values of
the estimated model parameters
</p>
</li>
<li> <p><code>dpar</code> a character vector containing the names of the
estimated model parameters
</p>
</li>
<li> <p><code>fixed_dpar</code> a named list whose elements are the values of the
fixed model parameters
</p>
</li>
<li> <p><code>loglik</code> the value of the log-likelihood function at the
optimized parameter values
</p>
</li>
<li> <p><code>hessians</code> a named list whose elements are the individual
Hessians for each of the model parameters
</p>
</li>
<li> <p><code>vcov</code> a named list whose elements are the individual
variance-covariance matrices for each of the model parameters
</p>
</li>
<li> <p><code>nobs</code> the number of observations in the data used for fitting
</p>
</li>
<li> <p><code>npar</code> the number of parameters used to fit the model (i.e.,
the estimated model parameters plus any hyperparameters)
</p>
</li>
<li> <p><code>df.residual</code> the residual degrees of freedom (the number of
observations - the number of parameters)
</p>
</li>
<li> <p><code>call</code> the original function call to <code>ddm</code>
</p>
</li>
<li> <p><code>formula</code> the formulas used in the model (<code>1</code> indicates
that the model parameter was estimated with a single coefficient;
<code>0</code> indicates that the model parameter was fixed)
</p>
</li>
<li> <p><code>dpar_formulas</code> a named list whose elements are the formulas
for the model parameters (<code>1</code> indicates that the model
parameter was estimated with a single coefficient; <code>0</code>
indicates that the model parameter was fixed)
</p>
</li>
<li> <p><code>na.action</code> na.action
</p>
</li>
<li> <p><code>terms</code> a named list whose elements are the model parameters,
except the last element is named <code>full</code> and shows the
breakdown of the model with all model parameters
</p>
</li>
<li> <p><code>levels</code> a named list whose elements are the levels associated
with any parameters that are factors (the elements are <code>NULL</code>
if the parameter is not a factor), and whose last element is named
<code>FULL</code> and shows all of the levels used in the model
</p>
</li>
<li> <p><code>contrasts</code> a named list whose elements are the type of
contrasts used in the model
</p>
</li>
<li> <p><code>args_ddm</code> a named list whose elements are the optional
arguments used in the calculation of the DDM log-likelihood
function
</p>
</li>
<li> <p><code>link</code> a named list whose elements show information about the
link function used for each model parameter (currently the only
link function is the identity function)
</p>
</li>
<li> <p><code>converged</code> a logical indicating whether the optimization
converged (<code>TRUE</code>) or not (<code>FALSE</code>)
</p>
</li>
<li> <p><code>optim_info</code> a named list whose elements are information about
the optimization process (e.g., the name of the algorithm used,
the final value of the objective function, the number of
evaluations of the gradient function, etc.)
</p>
</li>
<li> <p><code>model</code> the data used in the model (might need to check this)
</p>
</li>
<li> <p><code>response</code> the response data used in the model
</p>
</li>
<li> <p><code>mmatrix</code> a named list whose elements are the model matrices
for each of the estimated parameters
</p>
</li>
<li> <p><code>compiled_model</code> C++ object that contains the compiled model
(see list below for more details)
</p>
</li>
</ul>
<p>The C++ object accessible via the <code>compiled_model</code> component of the
above R object of class <code>ddm</code> contains the following components:
</p>

<ul>
<li> <p><code>rt</code> a numeric vector of the response time data used in the
model
</p>
</li>
<li> <p><code>response</code> an integer vector of the response data used in the
model (coded such that <code>1</code> corresponds to the "lower" boundary
and <code>2</code> corresponds to the "upper" boundary)
</p>
</li>
<li> <p><code>err_tol</code> the error tolerance used in the calculations for
fitting the DDM
</p>
</li>
<li> <p><code>coefficients</code> a numeric vector containing the current set of
coefficients for the formulas provided to the <code>ddm()</code> function
call; the coefficients correspond to the DDM parameters in the
following order: <code>v</code>, <code>a</code>, <code>t0</code>, <code>w</code>, <code>sv</code>
</p>
</li>
<li> <p><code>likelihood</code> a double containing the log-likelihood for the
current set of <code>coefficients</code> (note this can be changed by
calling the function <code>calculate_loglik()</code> below)
</p>
</li>
<li> <p><code>modmat_v</code> a numeric matrix containing the model matrix for
<code>v</code>, the drift rate, determined by the formula input to the
argument <code>drift</code> in the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>modmat_a</code> a numeric matrix containing the model matrix for
<code>a</code>, the boundary separation, determined by the formula input
to the argument <code>boundary</code> in the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>modmat_t0</code> a numeric matrix containing the model matrix for
<code>t0</code>, the non-decision time, determined by the formula input
to the argument <code>ndt</code> in the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>modmat_w</code> a numeric matrix containing the model matrix for
<code>w</code>, the inital bias, determined by the formula input to the
argument <code>bias</code> in the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>modmat_sv</code> a numeric matrix containing the model matrix for
<code>sv</code>, the inter-trial variability in the drift rate,
determined by the formula input to the argument <code>sv</code> in the
<code>ddm()</code> function call
</p>
</li>
<li> <p><code>hess_v</code> a numeric matrix containing the Hessian for <code>v</code>,
the drift rate, whose dimensions are determined by the formula
input to the argument <code>drift</code> in the <code>ddm()</code> function
call
</p>
</li>
<li> <p><code>hess_a</code> a numeric matrix containing the Hessian for <code>a</code>,
the boundary separation, whose dimensions are determined by the
formula input to the argument <code>drift</code> in the <code>ddm()</code>
function call
</p>
</li>
<li> <p><code>hess_t0</code> a numeric matrix containing the Hessian for
<code>t0</code>, the non-decision time, whose dimensions are determined
by the formula input to the argument <code>drift</code> in the
<code>ddm()</code> function call
</p>
</li>
<li> <p><code>hess_w</code> a numeric matrix containing the Hessian for <code>w</code>,
the initial bias, whose dimensions are determined by the formula
input to the argument <code>drift</code> in the <code>ddm()</code> function
call
</p>
</li>
<li> <p><code>hess_sv</code> a numeric matrix containing the Hessian for
<code>sv</code>, the inter-trial variability in the drift rate, whose
dimensions are determined by the formula input to the argument
<code>drift</code> in the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>vcov_v</code> a numeric matrix containing the variance-covariance
matrix for <code>v</code>, the drift rate, whose dimensions are
determined by the formula input to the argument <code>drift</code> in the
<code>ddm()</code> function call
</p>
</li>
<li> <p><code>vcov_a</code> a numeric matrix containing the variance-covariance
matrix for <code>a</code>, the boundary separation, whose dimensions are
determined by the formula input to the argument <code>boundary</code> in
the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>vcov_t0</code> a numeric matrix containing the variance-covariance
matrix for <code>t0</code>, the non-decision time, whose dimensions are
determined by the formula input to the argument <code>ndt</code> in the
<code>ddm()</code> function call
</p>
</li>
<li> <p><code>vcov_w</code> a numeric matrix containing the variance-covariance
matrix for <code>w</code>, the inital bias, whose dimensions are
determined by the formula input to the argument <code>bias</code> in the
<code>ddm()</code> function call
</p>
</li>
<li> <p><code>vcov_sv</code> a numeric matrix containing the variance-covariance
matrix for <code>v</code>, the inter-trial variability in the drift rate,
whose dimensions are determined by the formula input to the
argument <code>sv</code> in the <code>ddm()</code> function call
</p>
</li>
<li> <p><code>calculate_loglik</code> calculates and returns a double containing
the negated log-likelihood (note that this will overwrite the
<code>likelihood</code> component of the C++ object)
</p>
</li>
<li> <p><code>calculate_gradient</code> calculates and returns a numeric vector
of the negated gradients for the provided coefficient values; the
gradients are stored in the same manner as their corresponding
<code>coefficents</code> (note that this will overwrite the
<code>likelihood</code>) component of the C++ object)
</p>
</li>
<li> <p><code>calculate_hessians</code> calculates and returns a named list of
the negated Hessians for each model parameter for the provided
coefficient values (note that this will overwrite the
<code>likelihood</code>, <code>hess_v</code>, <code>hess_a</code>, <code>hess_t0</code>,
<code>hess_w</code>, and <code>hess_sv</code> components of the C++ object)
</p>
</li>
<li> <p><code>calculate_vcov</code> calculates and returns a named list of the
variance-covariance matrices for each model parameter for the
stored <code>coefficients</code> (note that this will overwrite the
<code>likelihood</code>, <code>hess_v</code>, <code>hess_a</code>, <code>hess_t0</code>,
<code>hess_w</code>, <code>hess_sv</code>, <code>vcov_v</code>, <code>vcov_a</code>,
<code>vcov_t0</code>, <code>vcov_w</code>, and <code>vcov_sv</code> components of the
C++ object)
</p>
</li>
<li> <p><code>calculate_standard_error</code> calculates and returns a numeric
vector of the standard errors of the stored <code>coefficients</code>;
the standard errors are stored in the same manner as their
corresponding <code>coefficients</code> (note that this will overwrite
the <code>likelihood</code>, <code>hess_v</code>, <code>hess_a</code>,
<code>hess_t0</code>, <code>hess_w</code>, <code>hess_sv</code>, <code>vcov_v</code>,
<code>vcov_a</code>, <code>vcov_t0</code>, <code>vcov_w</code>, and <code>vcov_sv</code>
components of the C++ object)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># prepare data
data(med_dec, package = "fddm")
med_dec &lt;- med_dec[which(med_dec[["rt"]] &gt;= 0), ] ## only use valid RTs
## select data from one participant
p1 &lt;- med_dec[med_dec[["id"]] == 2 &amp; med_dec[["group"]] == "experienced", ]
head(p1)


##----------------------------------------------
##        Easiest: Fitting using emmeans       -
##----------------------------------------------

## Because we use an ANOVA approach, we set orthogonal sum-to-zero contrasts
op &lt;- options(contrasts = c('contr.sum', 'contr.poly'))

fit0 &lt;- ddm(rt + response ~ classification*difficulty, data = p1)
summary(fit0)

## for more tests, we use emmeans:
if (requireNamespace("emmeans")) {
# for ANOVA table:
emmeans::joint_tests(fit0)
# get conditional main effects of difficulty (for each level of classification):
emmeans::joint_tests(fit0, by = "classification")

# get mean drift rates per condition:
em1 &lt;- emmeans::emmeans(fit0, "difficulty", by = "classification")
em1
# compare mean drift rates per condition
pairs(em1)
update(pairs(em1), by = NULL, adjust = "holm")
}

options(op) # reset contrasts


##----------------------------------------------------------------
##              Fitting with custom parametrisation              -
##----------------------------------------------------------------

## one drift rate per classification by difficulty design cell
fit1 &lt;- ddm(rt + response ~ 0 + classification:difficulty, data = p1)
summary(fit1)

## set default contrasts (just in case contrasts have been changed)
op &lt;- options(contrasts = c('contr.treatment', 'contr.poly'))
## one drift rate "intercept" per classification condition (blast vs. non-blast)
## corresponding to first level of difficulty factor (easy)
## plus one further coefficient per classification condition corresponding to
## difference from "intercept" (hard - easy)
fit1b &lt;- ddm(rt + response ~ 0 + classification + classification:difficulty,
             data = p1, args_optim = list(control = list(iter.max = 1000,
                                                         eval.max = 1000)))
summary(fit1b)
options(op) # reset contrasts

## set orthogonal sum-to-zero contrasts
op &lt;- options(contrasts = c('contr.sum', 'contr.poly'))
## one drift rate "intercept" per classification condition (blast vs. non-blast)
## corresponding to mean drift rate for the classification condition
## plus one further coefficient per classification condition corresponding to
## difference from "intercept" (hard/easy - mean drift rate)
fit1c &lt;- ddm(rt + response ~ 0 + classification + classification:difficulty,
             data = p1)
summary(fit1c)
options(op) ## reset contrasts

## all variants produce same fit, only meaning of parameters differs
logLik(fit1)
logLik(fit1b)
logLik(fit1c)
logLik(fit0) ## also model above

## all models estimate same drift rates, but in different parametrisation:
coef(fit1)  ## drift rates per design cell
## same drift rates based on fit1b:
c(coef(fit1b)[1:2],
  coef(fit1b)[1] + coef(fit1b)[3], coef(fit1b)[2] + coef(fit1b)[4])
## same drift rates based on fit1c:
c(coef(fit1c)[1] + coef(fit1c)[3], coef(fit1c)[2] + coef(fit1c)[4],
  coef(fit1c)[1] - coef(fit1c)[3], coef(fit1c)[2] - coef(fit1c)[4])

# we can estimate a model that freely estimates response bias
# (instead of fixing it at 0.5)
fit2 &lt;- ddm(rt + response ~ 0 + classification:difficulty, bias = ~1, data = p1)
summary(fit2)
## Note: estimating bias only makes sense in situations like here where the
## response boundaries do not correspond to correct/incorrect but to the
## actual responses participants gave (here: blast vs. non-blast classification)

## now let's perform a likelihood ratio test to check if estimating response
## bias freely leads to a significant increase in model fit?
if (requireNamespace("lmtest")) { ## requires package lmtest
  lmtest::lrtest(fit1, fit2)
  ## does not look like it (p = 0.1691)
}


# we can also make a DDM parameter, such as boundary, depend on a numeric
# variable, such as block number
fit3 &lt;- ddm(rt + response ~ 0 + classification:difficulty,
            boundary = ~ block, data = p1)
summary(fit3)

## does making boundary depend on block leads to a significant increase in model
## fit?
if (requireNamespace("lmtest")) { ## requires package lmtest
  lmtest::lrtest(fit1, fit3)
  ## does not look like it (p = 0.198)
}


##----------------------------------------------------------------
##              Fitting with optimization arguments              -
##----------------------------------------------------------------
## example of how to use your own initial values and bounds for the optimization
## of the coefficients (determined by the model matrices/formulas)
options(op) # reset contrasts

# this uses the default generated initial values and bounds
fitex0 &lt;- ddm(rt + response ~ 0 + classification:difficulty, data = p1)

# we can see the number of coefficients (and thus the number of initial values
# and bounds) required if we wish to use our own
fitex0$optim_info$args_optim$init
fitex0$optim_info$args_optim$lo_bds
fitex0$optim_info$args_optim$up_bds
# -1.9270279  2.5408864 -1.9270279  0.3181987  1.7907438  0.1264035
# -Inf        -Inf      -Inf        -Inf       0          0
# Inf         Inf       Inf         Inf        Inf        0.461
# the first four coefficients are for the drift rate (given by the formula we
# provided), and the last two are for the boundary separation and non-decision
# time, respectively (note that the default is to estimate these two model
# parameters with a single coefficient).

# to use our own initial values, we can include them in the `args_optim` list,
# but note that they must be within the generated bounds
fitex1 &lt;- ddm(rt + response ~ 0 + classification:difficulty, data = p1,
              args_optim = list(init = c(-1.5, 1, -1, 1, 1.5, 0.3)))

# to use our own bounds, we again can include them in the `args_optim` list,
# but note that they must contain the generated initial values
fitex2 &lt;- ddm(rt + response ~ 0 + classification:difficulty, data = p1,
              args_optim = list(lo_bds = c(-20, -20, -20, -20, 0, 0),
                                up_bds = c(20, 20, 20, 20, 10, 0.5)))

# to use both our own initial values and bounds, we include them in the
# `args_optim` list, and the bounds must contain the initial values
fitex3 &lt;- ddm(rt + response ~ 0 + classification:difficulty, data = p1,
              args_optim = list(init = c(-1.5, 1, -1, 1, 1.5, 0.3),
                                lo_bds = c(-20, -20, -20, -20, 0, 0),
                                up_bds = c(20, 20, 20, 20, 10, 0.5)))

# the only other option in the `args_optim` list is the control parameters
# directly used by the optimization function (e.g., the maximum number of
# iterations); here we'll set the maximum number of iterations and function
# evaluations
fitex4 &lt;- ddm(rt + response ~ 0 + classification:difficulty, data = p1,
              args_optim = list(control = list(iter.max = 1000,
                                               eval.max = 1000)))
</code></pre>


</div>