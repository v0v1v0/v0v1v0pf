<div class="container">

<table style="width: 100%;"><tr>
<td>cvts</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross validation for time series</h2>

<h3>Description</h3>

<p>Perform cross validation on a time series.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cvts(
  x,
  FUN = NULL,
  FCFUN = NULL,
  rolling = FALSE,
  windowSize = 84,
  maxHorizon = 5,
  horizonAverage = FALSE,
  xreg = NULL,
  saveModels = ifelse(length(x) &gt; 500, FALSE, TRUE),
  saveForecasts = ifelse(length(x) &gt; 500, FALSE, TRUE),
  verbose = TRUE,
  num.cores = 2L,
  extraPackages = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the input time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>the model function used. Custom functions are allowed. See details and examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FCFUN</code></td>
<td>
<p>a function that process point forecasts for the model function. This defaults
to <code>forecast</code>. Custom functions are allowed. See details and examples. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rolling</code></td>
<td>
<p>should a rolling procedure be used? If TRUE, non-overlapping windows
of size <code>maxHorizon</code> will be used for fitting each model. If FALSE, the size
of the dataset used for training will grow by one each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>windowSize</code></td>
<td>
<p>length of the window to build each model. When <code>rolling == FALSE</code>,
the each model will be fit to a time series of this length, and when <code>rolling == TRUE</code>
the first model will be fit to a series of this length and grow by one each iteration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxHorizon</code></td>
<td>
<p>maximum length of the forecast horizon to use for computing errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>horizonAverage</code></td>
<td>
<p>should the final errors be an average over all forecast horizons
up to <code>maxHorizon</code> instead of producing
metrics for each individual horizon?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>
<p>External regressors to be used to fit the model. Only used if FUN accepts xreg
as an argument. FCFUN is also expected to accept it (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveModels</code></td>
<td>
<p>should the individual models be saved? Set this to <code>FALSE</code> on long
time series to save memory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>saveForecasts</code></td>
<td>
<p>should the individual forecast from each model be saved? Set this
to <code>FALSE</code> on long time series to save memory.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>should the current progress be printed to the console?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.cores</code></td>
<td>
<p>the number of cores to use for parallel fitting. If the underlying model
that is being fit also utilizes parallelization, the number of cores it is using multiplied
by 'num.cores' should not exceed the number of cores available on your machine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extraPackages</code></td>
<td>
<p>on Windows if a custom 'FUN' or 'FCFUN' is being used that requires
loaded, these can be passed here so that they can be passed to parallel socket workers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to be passed to the model function FUN</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Cross validation of time series data is more complicated than regular
k-folds or leave-one-out cross validation of datasets
without serial correlation since observations <code class="reqn">x_t</code> and <code class="reqn">x_{t+n}</code>
are not independent. The <code>cvts()</code> function overcomes
this obstacle using two methods: 1) rolling cross validation where an initial training window
is used along with a forecast horizon
and the initial window used for training grows by one observation each round until the training
window and the forecast horizon capture the
entire series or 2) a non-rolling approach where a fixed training length is used that
is shifted forward by the forecast horizon after each iteration.
</p>
<p>For the rolling approach, training points are heavily recycled, both in terms of used for fitting
and in generating forecast errors at each of the forecast horizons from <code>1:maxHorizon</code>.
In contrast, the models fit with
the non-rolling approach share less overlap, and the predicted forecast values are also
only compared to the actual values once.
The former approach is similar to leave-one-out cross validation while the latter resembles
k-fold cross validation. As a result,
rolling cross validation requires far more iterations and computationally takes longer
to complete, but a disadvantage of the
non-rolling approach is the greater variance and general instability of cross-validated errors.
</p>
<p>The <code>FUN</code> and <code>FCFUN</code> arguments specify which function to use
for generating a model and forecasting, respectively. While the functions
from the "forecast" package can be used, user-defined functions can also
be tested, but the object returned by <code>FCFUN</code> must
accept the argument <code>h</code> and contain the point forecasts out to
this horizon <code>h</code> in slot <code>$mean</code> of the returned object. An example is given with
a custom model and forecast.
</p>
<p>For small time series (default <code>length &lt;= 500</code>), all of the individual fit models
are included in the final
<code>cvts</code> object that is returned. This can grow quite large since functions
such as <code>auto.arima</code> will
save fitted values, residual values, summary statistics, coefficient matrices, etc.
Setting <code>saveModels = FALSE</code>
can be safely done if there is no need to examine individual models fit at every stage
of cross validation since the
forecasts from each fold and the associated residuals are always saved.
</p>
<p>External regressors are allowed via the <code>xreg</code> argument. It is assumed that both
<code>FUN</code> and <code>FCFUN</code> accept the <code>xreg</code> parameter if <code>xreg</code> is not <code>NULL</code>.
If <code>FUN</code> does not accept the <code>xreg</code> parameter a warning will be given.
No warning is provided if <code>FCFUN</code> does not use the <code>xreg</code> parameter.
</p>


<h3>Author(s)</h3>

<p>David Shaub
</p>


<h3>See Also</h3>

<p><code>accuracy.cvts</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">series &lt;- subset(AirPassengers, end = 50)
cvmod1 &lt;- cvts(series, FUN = snaive,
               windowSize = 25, maxHorizon = 12)
accuracy(cvmod1)

# We can also use custom model functions for modeling/forecasting
stlmClean &lt;- function(x) stlm(tsclean(x))
series &lt;- subset(austres, end = 38)
cvmodCustom &lt;- cvts(series, FUN = stlmClean, windowSize = 26, maxHorizon = 6)
accuracy(cvmodCustom)


# Use the rwf() function from the "forecast" package.
# This function does not have a modeling function and
# instead calculates a forecast on the time series directly
series &lt;- subset(AirPassengers, end = 26)
rwcv &lt;- cvts(series, FCFUN = rwf, windowSize = 24, maxHorizon = 1)

# Don't return the model or forecast objects
cvmod2 &lt;- cvts(USAccDeaths, FUN = stlm,
               saveModels = FALSE, saveForecasts = FALSE,
               windowSize = 36, maxHorizon = 12)

# If we don't need prediction intervals and are using the nnetar model, turning off PI
# will make the forecasting much faster
series &lt;- subset(AirPassengers, end=40)
cvmod3 &lt;- cvts(series, FUN = hybridModel,
               FCFUN = function(mod, h) forecast(mod, h = h, PI = FALSE),
               rolling = FALSE, windowSize = 36,
               maxHorizon = 2)

</code></pre>


</div>