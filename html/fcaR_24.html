<div class="container">

<table style="width: 100%;"><tr>
<td>ImplicationSet</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>R6 Class for Set of implications</h2>

<h3>Description</h3>

<p>This class implements the structure needed to store implications and the methods associated.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ImplicationSet-new"><code>ImplicationSet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-get_attributes"><code>ImplicationSet$get_attributes()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-bracket"><code>ImplicationSet$[()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-to_arules"><code>ImplicationSet$to_arules()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-add"><code>ImplicationSet$add()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-cardinality"><code>ImplicationSet$cardinality()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-is_empty"><code>ImplicationSet$is_empty()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-size"><code>ImplicationSet$size()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-closure"><code>ImplicationSet$closure()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-recommend"><code>ImplicationSet$recommend()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-apply_rules"><code>ImplicationSet$apply_rules()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-to_basis"><code>ImplicationSet$to_basis()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-print"><code>ImplicationSet$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-to_latex"><code>ImplicationSet$to_latex()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-get_LHS_matrix"><code>ImplicationSet$get_LHS_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-get_RHS_matrix"><code>ImplicationSet$get_RHS_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-filter"><code>ImplicationSet$filter()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-support"><code>ImplicationSet$support()</code></a>
</p>
</li>
<li> <p><a href="#method-ImplicationSet-clone"><code>ImplicationSet$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-ImplicationSet-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initialize with an optional name
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>See Details.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Creates and initialize a new <code>ImplicationSet</code> object. It can be done in two ways:
<code>initialize(name, attributes, lhs, rhs)</code>
or <code>initialize(rules)</code>
</p>
<p>In the first way, the only mandatory argument is <code>attributes</code>, (character vector) which is a vector of names of the attributes on which we define the implications. Optional arguments are: <code>name</code> (character string), name of the implication set, <code>lhs</code> (a <code>dgCMatrix</code>), initial LHS of the implications stored and the analogous <code>rhs</code>.
</p>
<p>The other way is used to initialize the <code>ImplicationSet</code> object from a <code>rules</code> object from package <code>arules</code>.
</p>



<h5>Returns</h5>

<p>A new <code>ImplicationSet</code> object.
</p>


<hr>
<a id="method-ImplicationSet-get_attributes"></a>



<h4>Method <code>get_attributes()</code>
</h4>

<p>Get the names of the attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$get_attributes()</pre></div>



<h5>Returns</h5>

<p>A character vector with the names of the attributes used in the implications.
</p>


<hr>
<a id="method-ImplicationSet-bracket"></a>



<h4>Method <code>[()</code>
</h4>

<p>Get a subset of the implication set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$[(idx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>idx</code></dt>
<dd>
<p>(integer or logical vector) Indices of the implications to extract or remove. If logical vector, only <code>TRUE</code> elements are retained and the rest discarded.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new <code>ImplicationSet</code> with only the rules given by the <code>idx</code> indices (if all <code>idx &gt; 0</code> and all but <code>idx</code> if all <code>idx &lt; 0</code>.
</p>


<hr>
<a id="method-ImplicationSet-to_arules"></a>



<h4>Method <code>to_arules()</code>
</h4>

<p>Convert to arules format
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$to_arules(quality = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quality</code></dt>
<dd>
<p>(logical) Compute the interest measures for each rule?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A <code>rules</code> object as used by package <code>arules</code>.
</p>


<hr>
<a id="method-ImplicationSet-add"></a>



<h4>Method <code>add()</code>
</h4>

<p>Add a precomputed implication set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$add(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>An <code>ImplicationSet</code> object, a <code>rules</code> object, or a pair <code>lhs</code>, <code>rhs</code> of <code>Set</code> objects or <code>dgCMatrix</code>. The implications to add to this formal context.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Nothing, just updates the internal <code>implications</code> field.
</p>


<hr>
<a id="method-ImplicationSet-cardinality"></a>



<h4>Method <code>cardinality()</code>
</h4>

<p>Cardinality: Number of implications in the set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$cardinality()</pre></div>



<h5>Returns</h5>

<p>The cardinality of the implication set.
</p>


<hr>
<a id="method-ImplicationSet-is_empty"></a>



<h4>Method <code>is_empty()</code>
</h4>

<p>Empty set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$is_empty()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the set of implications is empty, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-ImplicationSet-size"></a>



<h4>Method <code>size()</code>
</h4>

<p>Size: number of attributes in each of LHS and RHS
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$size()</pre></div>



<h5>Returns</h5>

<p>A vector with two components: the number of attributes present in each of the LHS and RHS of each implication in the set.
</p>


<hr>
<a id="method-ImplicationSet-closure"></a>



<h4>Method <code>closure()</code>
</h4>

<p>Compute the semantic closure of a fuzzy set with respect to the implication set
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$closure(S, reduce = FALSE, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt>
<dd>
<p>(a <code>Set</code> object)  Fuzzy set to compute its closure. Use class <code>Set</code> to build it.</p>
</dd>
<dt><code>reduce</code></dt>
<dd>
<p>(logical) Reduce the implications using simplification logic?</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>(logical) Show verbose output?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>If <code>reduce == FALSE</code>, the output is a fuzzy set corresponding to the closure of <code>S</code>. If <code>reduce == TRUE</code>, a list with two components: <code>closure</code>, with the closure as above, and <code>implications</code>, the reduced set of implications.
</p>


<hr>
<a id="method-ImplicationSet-recommend"></a>



<h4>Method <code>recommend()</code>
</h4>

<p>Generate a recommendation for a subset of the attributes
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$recommend(S, attribute_filter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>S</code></dt>
<dd>
<p>(a vector) Vector with the grades of each attribute (a fuzzy set).</p>
</dd>
<dt><code>attribute_filter</code></dt>
<dd>
<p>(character vector) Names of the attributes to get recommendation for.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A fuzzy set describing the values of the attributes in <code>attribute_filter</code> within the closure of <code>S</code>.
</p>


<hr>
<a id="method-ImplicationSet-apply_rules"></a>



<h4>Method <code>apply_rules()</code>
</h4>

<p>Apply rules to remove redundancies
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$apply_rules(
  rules = c("composition", "generalization"),
  batch_size = 25000L,
  parallelize = FALSE,
  reorder = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rules</code></dt>
<dd>
<p>(character vector) Names of the rules to use. See <code>details</code>.</p>
</dd>
<dt><code>batch_size</code></dt>
<dd>
<p>(integer) If the number of rules is large, apply the rules by batches of this size.</p>
</dd>
<dt><code>parallelize</code></dt>
<dd>
<p>(logical) If possible, should we parallelize the computation among different batches?</p>
</dd>
<dt><code>reorder</code></dt>
<dd>
<p>(logical) Should the rules be randomly reordered previous to the computation?</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Currently, the implemented rules are <code>"generalization"</code>, <code>"simplification"</code>, <code>"reduction"</code> and <code>"composition"</code>.
</p>



<h5>Returns</h5>

<p>Nothing, just updates the internal matrices for LHS and RHS.
</p>


<hr>
<a id="method-ImplicationSet-to_basis"></a>



<h4>Method <code>to_basis()</code>
</h4>

<p>Convert Implications to Canonical Basis
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$to_basis()</pre></div>



<h5>Returns</h5>

<p>The canonical basis of implications obtained from the current <code>ImplicationSet</code>
</p>


<hr>
<a id="method-ImplicationSet-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Print all implications to text
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$print()</pre></div>



<h5>Returns</h5>

<p>A string with all the implications in the set.
</p>


<hr>
<a id="method-ImplicationSet-to_latex"></a>



<h4>Method <code>to_latex()</code>
</h4>

<p>Export to LaTeX
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$to_latex(
  print = TRUE,
  ncols = 1,
  numbered = TRUE,
  numbers = seq(self$cardinality())
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>print</code></dt>
<dd>
<p>(logical) Print to output?</p>
</dd>
<dt><code>ncols</code></dt>
<dd>
<p>(integer) Number of columns for the output.</p>
</dd>
<dt><code>numbered</code></dt>
<dd>
<p>(logical) If <code>TRUE</code> (default), implications will be numbered in the output.</p>
</dd>
<dt><code>numbers</code></dt>
<dd>
<p>(vector) If <code>numbered</code>, use these elements to enumerate the implications. The default is to enumerate 1, 2, ..., but can be changed.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A string in LaTeX format that prints nicely all the implications.
</p>


<hr>
<a id="method-ImplicationSet-get_LHS_matrix"></a>



<h4>Method <code>get_LHS_matrix()</code>
</h4>

<p>Get internal LHS matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$get_LHS_matrix()</pre></div>



<h5>Returns</h5>

<p>A sparse matrix representing the LHS of the implications in the set.
</p>


<hr>
<a id="method-ImplicationSet-get_RHS_matrix"></a>



<h4>Method <code>get_RHS_matrix()</code>
</h4>

<p>Get internal RHS matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$get_RHS_matrix()</pre></div>



<h5>Returns</h5>

<p>A sparse matrix representing the RHS of the implications in the set.
</p>


<hr>
<a id="method-ImplicationSet-filter"></a>



<h4>Method <code>filter()</code>
</h4>

<p>Filter implications by attributes in LHS and RHS
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$filter(
  lhs = NULL,
  not_lhs = NULL,
  rhs = NULL,
  not_rhs = NULL,
  drop = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lhs</code></dt>
<dd>
<p>(character vector) Names of the attributes to filter the LHS by. If <code>NULL</code>, no filtering is done on the LHS.</p>
</dd>
<dt><code>not_lhs</code></dt>
<dd>
<p>(character vector) Names of the attributes to not include in the LHS. If <code>NULL</code> (the default), it is not considered at all.</p>
</dd>
<dt><code>rhs</code></dt>
<dd>
<p>(character vector) Names of the attributes to filter the RHS by. If <code>NULL</code>, no filtering is done on the RHS.</p>
</dd>
<dt><code>not_rhs</code></dt>
<dd>
<p>(character vector) Names of the attributes to not include in the RHS. If <code>NULL</code> (the default), it is not considered at all.</p>
</dd>
<dt><code>drop</code></dt>
<dd>
<p>(logical) Remove the rest of attributes in RHS?</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>An <code>ImplicationSet</code> that is a subset of the current set, only with those rules which has the attributes in <code>lhs</code> and <code>rhs</code> in their LHS and RHS, respectively.
</p>


<hr>
<a id="method-ImplicationSet-support"></a>



<h4>Method <code>support()</code>
</h4>

<p>Compute support of each implication
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$support()</pre></div>



<h5>Returns</h5>

<p>A vector with the support of each implication
</p>


<hr>
<a id="method-ImplicationSet-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImplicationSet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>References</h3>

<p>Ganter B, Obiedkov S (2016). Conceptual Exploration. Springer. https://doi.org/10.1007/978-3-662-49291-8
</p>
<p>Hahsler M, Grun B, Hornik K (2005). “arules - a computational environment for mining association rules and frequent item sets.” <em>J Stat Softw</em>, <em>14</em>, 1-25.
</p>
<p>Belohlavek R, Cordero P, Enciso M, Mora Á, Vychodil V (2016). “Automated prover for attribute dependencies in data with grades.” <em>International Journal of Approximate Reasoning</em>, <em>70</em>, 51-67.
</p>
<p>Mora A, Cordero P, Enciso M, Fortes I, Aguilera G (2012). “Closure via functional dependence simplification.” <em>International Journal of Computer Mathematics</em>, <em>89</em>(4), 510-526.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Build a formal context
fc_planets &lt;- FormalContext$new(planets)

# Find its implication basis
fc_planets$find_implications()

# Print implications
fc_planets$implications

# Cardinality and mean size in the ruleset
fc_planets$implications$cardinality()
sizes &lt;- fc_planets$implications$size()
colMeans(sizes)

# Simplify the implication set
fc_planets$implications$apply_rules("simplification")

</code></pre>


</div>