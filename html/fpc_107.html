<div class="container">

<table style="width: 100%;"><tr>
<td>plot.valstat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation-standardised plot and print of cluster validation statistics</h2>

<h3>Description</h3>

<p>Visualisation and print function for cluster validation output
compared to results
on simulated random clusterings. The print method can also be used to
compute and print an aggregated cluster validation index.
</p>
<p>Unlike for many other plot methods, the additional arguments
of <code>plot.valstat</code> are essential. <code>print.valstat</code> should make
good sense with the defaults, but for computing the aggregate index
need to be set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'valstat'
plot(x,simobject=NULL,statistic="sindex",
                            xlim=NULL,ylim=c(0,1),
                            nmethods=length(x)-5,
                            col=1:nmethods,cex=1,pch=c("c","f","a","n"),
                            simcol=rep(grey(0.7),4),
                         shift=c(-0.1,-1/3,1/3,0.1),include.othernc=NULL,...)


## S3 method for class 'valstat'
print(x,statistics=x$statistics,
                          nmethods=length(x)-5,aggregate=FALSE,
                          weights=NULL,digits=2,
                          include.othernc=NULL,...)

			      
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>"valstat"</code>, such as sublists
<code>stat, qstat, sstat</code> of <code>clusterbenchstats</code>-output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simobject</code></td>
<td>
<p>list of simulation results as produced by
<code>randomclustersim</code> and documented there; typically sublist
<code>sim</code> of <code>clusterbenchstats</code>-output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>one of <code>"avewithin","mnnd","variation",
      "diameter","gap","sindex","minsep","asw","dindex","denscut",
      "highdgap","pg","withinss","entropy","pamc","kdnorm","kdunif","dmode"</code>;
validation statistic to be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlim</code></td>
<td>
<p>passed on to <code>plot</code>. Default is the range of all
involved numbers of clusters, minimum minus 0.5 to maximum plus
0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ylim</code></td>
<td>
<p>passed on to <code>plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nmethods</code></td>
<td>
<p>integer. Number of clustering methods to involve
(these are those from number 1 to <code>nmethods</code> specified in
<code>x$name</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>colours used for the different clustering methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cex</code></td>
<td>
<p>passed on to <code>plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pch</code></td>
<td>
<p>vector of symbols for random clustering results from
<code>stupidkcentroids</code>, <code>stupidkfn</code>,
<code>stupidkaven</code>, <code>stupidknn</code>.
To be passed on to <code>plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simcol</code></td>
<td>
<p>vector of colours used for random clustering results in
order <code>stupidkcentroids</code>, <code>stupidkfn</code>,
<code>stupidkaven</code>, <code>stupidknn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>numeric vector. Indicates the amount to which the results
from  <code>stupidkcentroids</code>, <code>stupidkfn</code>,
<code>stupidkaven</code>, <code>stupidknn</code> are
plotted to the right of their respective
number of clusters (negative numbers plot to the left).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include.othernc</code></td>
<td>
<p>this indicates whether methods should be
included that estimated their number of clusters themselves and gave
a result outside the standard range as given by <code>x$minG</code>
and <code>x$maxG</code>. If not <code>NULL</code>, this is a
list of integer vectors of length 2. The first
number is
the number of the clustering method (the order is determined by
argument <code>x$name</code>), the second number is the
number of clusters for those methods that estimate the number of
clusters themselves and estimated a number outside the standard
range. Normally what will be used here, if not <code>NULL</code>, is the
output parameter
<code>cm$othernc</code> of <code>clusterbenchstats</code>, see also
<code>cluster.magazine</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statistics</code></td>
<td>
<p>vector of character strings specifying the
validation statistics that will be included in the output (unless
you want to restrict the output for some reason, the default should
be fine.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregate</code></td>
<td>
<p>logical. If <code>TRUE</code>, an aggegate validation
statistic will be computed as the weighted mean of the involved
statistic. This requires <code>weights</code> to be set. In order for this
to make sense, values of the validation statistics should be
comparable, which is achieved by standardisation in
<code>clusterbenchstats</code>. Accordingly, <code>x</code> should
be the <code>qstat</code> or <code>sstat</code>-component of the
<code>clusterbenchstats</code>-output rather than the
<code>stat</code>-component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>vector of numericals. Weights for computation of the
aggregate statistic in case that <code>aggregate=TRUE</code>. The order of
clustering methods corresponding to the weight vector is given by
<code>x$name</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>minimal number of significant digits, passed on to
<code>print.table</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>no effect.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Whereas <code>print.valstat</code>, at least with <code>aggregate=TRUE</code>
makes more sense for the <code>qstat</code> or <code>sstat</code>-component of the
<code>clusterbenchstats</code>-output rather than the
<code>stat</code>-component, <code>plot.valstat</code> should be run with the
<code>stat</code>-component if <code>simobject</code> is specified, because the
simulated cluster validity statistics are unstandardised and need to
be compared with unstandardised values on the dataset of interest.
</p>
<p><code>print.valstat</code> will print all values for all validation indexes
and the aggregated index (in case of <code>aggregate=TRUE</code> and set
<code>weights</code> will be printed last.
</p>


<h3>Value</h3>

<p><code>print.valstats</code> returns the results table as invisible object.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Hennig, C. (2019) Cluster validation by measurement of clustering
characteristics relevant to the user. In C. H. Skiadas (ed.)
<em>Data Analysis and Applications 1: Clustering and Regression,
Modeling-estimating, Forecasting and Data Mining, Volume 2</em>, Wiley,
New York 1-24,
<a href="https://arxiv.org/abs/1703.09282">https://arxiv.org/abs/1703.09282</a>
</p>
<p>Akhanli, S. and Hennig, C. (2020) Calibrating and aggregating cluster
validity indexes for context-adapted comparison of clusterings.
<em>Statistics and Computing</em>, 30, 1523-1544,
<a href="https://link.springer.com/article/10.1007/s11222-020-09958-2">https://link.springer.com/article/10.1007/s11222-020-09958-2</a>, <a href="https://arxiv.org/abs/2002.01822">https://arxiv.org/abs/2002.01822</a>
</p>


<h3>See Also</h3>

<p><code>clusterbenchstats</code>, <code>valstat.object</code>, 
<code>cluster.magazine</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  
  set.seed(20000)
  options(digits=3)
  face &lt;- rFace(10,dMoNo=2,dNoEy=0,p=2)
  clustermethod=c("kmeansCBI","hclustCBI","hclustCBI")
  clustermethodpars &lt;- list()
  clustermethodpars[[2]] &lt;- clustermethodpars[[3]] &lt;- list()
  clustermethodpars[[2]]$method &lt;- "ward.D2"
  clustermethodpars[[3]]$method &lt;- "single"
  methodname &lt;- c("kmeans","ward","single")
  cbs &lt;-  clusterbenchstats(face,G=2:3,clustermethod=clustermethod,
    methodname=methodname,distmethod=rep(FALSE,3),
    clustermethodpars=clustermethodpars,nnruns=2,kmruns=2,fnruns=2,avenruns=2)
  plot(cbs$stat,cbs$sim)
  plot(cbs$stat,cbs$sim,statistic="dindex")
  plot(cbs$stat,cbs$sim,statistic="avewithin")
  pcbs &lt;- print(cbs$sstat,aggregate=TRUE,weights=c(1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0))
# Some of the values are "NaN" because due to the low number of runs of
# the stupid clustering methods there is no variation. If this happens
# in a real application, nnruns etc. should be chosen higher than 2.
# Also useallg=TRUE in clusterbenchstats may help.
#
# Finding the best aggregated value:
  mpcbs &lt;- as.matrix(pcbs[[17]][,-1])
  which(mpcbs==max(mpcbs),arr.ind=TRUE)
# row=1 refers to the first clustering method kmeansCBI,
# col=2 refers to the second number of clusters, which is 3 in g=2:3.
</code></pre>


</div>