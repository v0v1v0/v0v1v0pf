<div class="container">

<table style="width: 100%;"><tr>
<td>farm.select</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Factor-adjusted robust model selection</h2>

<h3>Description</h3>

<p>Given a covariate matrix and output vector, this function first adjusts the covariates for underlying factors and then performs model selection.
</p>


<h3>Usage</h3>

<pre><code class="language-R">farm.select(X, Y, loss = c("scad", "mcp", "lasso"), robust = TRUE,
  cv = FALSE, tau = 2, lin.reg = TRUE, K.factors = NULL,
  max.iter = 10000, nfolds = ceiling(length(Y)/3), eps = 1e-04,
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an n x p covariate matrix with each row being a sample. Must have same number of rows as the size of <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a size n outcome vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>a character string specifying the loss function to be minimized. Must be one of "scad" (default) "mcp" or "lasso". You can just specify the initial letter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>a boolean, specifying whether or not to use robust estimators for mean and variance. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>a boolean, specifying whether or  not to run cross-validation for the tuning parameter. Default is FALSE. Only used if <code>robust</code> is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p><code>&gt;0</code>, multiplier for the tuning parameter for Huber loss function. Default is 2. Only used if <code>robust</code> is TRUE and <code>cv</code> is FALSE. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lin.reg</code></td>
<td>
<p>a boolean, specifying whether or not to assume that we have a linear regression model (TRUE) or a logit model (FALSE) structure. Default is TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.factors</code></td>
<td>
<p>number of factors to be estimated. Otherwise estimated internally. K&gt;0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.iter</code></td>
<td>
<p>maximum number of iterations across the regularization path. Default is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>the number of cross-validation folds. Default is ceiling(samplesize/3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence threshhold for model fitting using <code>ncvreg</code>. The algorithm iterates until the RMSD for the change in linear predictors for any coefficient is less than eps. Default is <code>1e-4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>a boolean specifying whether to print runtime updates to the console. Default is TRUE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For formula of how the covariates are  adjusted for latent factors, see Section 3.2 in Fan et al.(2017).
</p>
<p>The tuning parameter <code>= tau *  sigma * optimal rate </code> where <code>optimal rate </code> is the optimal rate for the tuning parameter. For details, see Fan et al.(2017). <code>sigma</code> is the standard deviation of the data.
</p>
<p><code>ncvreg</code> is used to fit the model after decorrelation. This package may output its own warnings about failures to converge and model saturation.
</p>


<h3>Value</h3>

<p>A list with the following items
</p>
<table>
<tr style="vertical-align: top;">
<td><code>model.size</code></td>
<td>
<p>the size of the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.chosen</code></td>
<td>
<p>the indices of the covariates chosen in the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef.chosen</code></td>
<td>
<p>the coefficients of the chosen covariates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.residual</code></td>
<td>
<p>the residual covariate matrix after adjusting for factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfactors</code></td>
<td>
<p>number of (estimated) factors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>number of observations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>number of dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>whether robust parameters were used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>
<p>loss function used</p>
</td>
</tr>
</table>
<p>#' @details Number of rows and columns of the covariate matrix must be at least 4 in order to be able to calculate latent factors.
</p>


<h3>References</h3>

<p>Fan J., Ke Y., Wang K., "Decorrelation of Covariates for High Dimensional Sparse Regression." <a href="https://arxiv.org/abs/1612.08490">https://arxiv.org/abs/1612.08490</a>
</p>


<h3>See Also</h3>

<p><code>print.farm.select</code> <code>farm.res</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##linear regression
set.seed(100)
P = 200 #dimension
N = 50 #samples
K = 3 #nfactors
Q = 3 #model size
Lambda = matrix(rnorm(P*K, 0,1), P,K)
F = matrix(rnorm(N*K, 0,1), N,K)
U = matrix(rnorm(P*N, 0,1), P,N)
X = Lambda%*%t(F)+U
X = t(X)
beta_1 = rep(5,Q)
beta = c(beta_1, rep(0,P-Q))
eps = rt(N, 2.5)
Y = X%*%beta+eps

##with default options
output = farm.select(X,Y) #robust, no cross-validation
output$beta.chosen #variables selected
output$coef.chosen #coefficients of selected variables

#examples of other robustification options
output = farm.select(X,Y,robust = FALSE) #non-robust
output = farm.select(X,Y, tau = 3) #robust, no cross-validation, specified tau
#output = farm.select(X,Y, cv= TRUE) #robust, cross-validation: LONG RUNNING!

##changing the loss function and inputting factors
output = farm.select(X, Y,loss = "mcp", K.factors = 4)

##use a logistic regression model, a larger sample size is desired.
## Not run: 
set.seed(100)
P = 400 #dimension
N = 300 #samples
K = 3 #nfactors
Q = 3 #model size
Lambda = matrix(rnorm(P*K, 0,1), P,K)
F = matrix(rnorm(N*K, 0,1), N,K)
U = matrix(rnorm(P*N, 0,1), P,N)
X = Lambda%*%t(F)+U
X = t(X)
beta_1 = rep(5, Q)
beta = c(beta_1, rep(0,P-Q))
eps = rnorm(N)
Prob = 1/(1+exp(-X%*%beta))
Y = rbinom(N, 1, Prob)

output = farm.select(X,Y, lin.reg=FALSE, eps=1e-3)
output$beta.chosen
output$coef.chosen

## End(Not run)
</code></pre>


</div>