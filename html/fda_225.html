<div class="container">

<table style="width: 100%;"><tr>
<td>smooth.pos</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Smooth Data with a Positive Function
</h2>

<h3>Description</h3>

<p>A set of data is smoothed with a functional data object that only
takes positive values.  For example, this function can be used to
estimate a smooth variance function from a set of squared residuals.
A function $W(t)$ is estimated such that that the smoothing function
is $exp[W(t)]$.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smooth.pos(argvals, y, WfdParobj, wtvec=rep(1,n),conv=.0001, iterlim=50, dbglev=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>

<p>Argument value array of length N, where N is the number of observed
curve values for each curve.  It is assumed that that these argument
values are common to all observed curves.  If this is not the case,
you will need to run this function inside one or more loops,
smoothing each curve separately.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Function value array (the values to be fit).  If the functional data
are univariate, this array will be an N by NCURVE matrix, where N is
the number of observed curve values for each curve and NCURVE is the
number of curves observed.  If the functional data are multivariate,
this array will be an N by NCURVE by NVAR matrix, where NVAR the
number of functions observed per case.  For example, for the gait
data, NVAR = 2, since we observe knee and hip angles.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WfdParobj</code></td>
<td>

<p>A functional parameter or fdPar object.  This object contains the
specifications for the functional data object to be estimated by
smoothing the data.  See comment lines in function fdPar for
details.  The functional data object WFD in WFDPAROBJ is used to
initialize the optimization process.  Its coefficient array contains
the starting values for the iterative minimization of mean squared
error.
The coefficient array contains the starting values for the iterative 
minimization of mean squared error, and this coefficient array must 
be either a K by NCURVE matrix or a K by NUCRVE by NVAR array,  
where K is the number of basis functions.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wtvec</code></td>
<td>

<p>a vector of weights to be used in the smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>a convergence criterion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterlim</code></td>
<td>

<p>the maximum number of iterations allowed in the minimization of
error sum of squares.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  If either level 1 or 2 is specified, it
can be helpful to turn off the output buffering feature of S-PLUS.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an object of class <code>posfd</code>, being a list with 4 components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the positive function that it
defines.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged
solution: (1) <b>f</b>: the optimal function value being minimized,
(2) <b>grad</b>: the gradient vector at the optimal solution, and
(3) <b>norm</b>: the norm of the gradient vector at the optimal
solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>the corresponding input arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>the corresponding input arguments</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>smooth.surp</code>,
<code>smooth.monotone</code>,
<code>smooth.morph</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">smallbasis  &lt;- create.fourier.basis(c(0, 365), 65)
harmaccelLfd365 &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))

index   &lt;- (1:35)[CanadianWeather$place == "Vancouver"]
VanPrec &lt;- CanadianWeather$dailyAv[,index, "Precipitation.mm"]

lambda    &lt;- 1e4
dayfdPar &lt;- fdPar(fd(matrix(0,smallbasis$nbasis,1), smallbasis), 
                  harmaccelLfd365, lambda)
smooth.pos(day.5, VanPrec, dayfdPar)

</code></pre>


</div>