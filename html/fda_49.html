<div class="container">

<table style="width: 100%;"><tr>
<td>create.polygonal.basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create a Polygonal Basis
</h2>

<h3>Description</h3>

<p>A basis is set up for constructing polygonal lines, consisting of
straight line segments that join together.
</p>


<h3>Usage</h3>

<pre><code class="language-R">create.polygonal.basis(rangeval=NULL, argvals=NULL, dropind=NULL,
        quadvals=NULL, values=NULL, basisvalues=NULL, names='polygon',
        axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rangeval</code></td>
<td>

<p>a numeric vector of length 2 defining the interval over which the
functional data object can be evaluated;  default value is
<code>if(is.null(argvals)) 0:1 else range(argvals)</code>.
</p>
<p>If <code>length(rangeval) == 1</code> and <code>rangeval &lt;= 0</code>, this is an
error.  Otherwise, if <code>length(rangeval) == 1</code>, <code>rangeval</code>
is replaced by <code>c(0,rangeval)</code>.
</p>
<p>If length(rangeval)&gt;2 and <code>argvals</code> is not provided, this extra
long <code>rangeval</code> argument is assigned to <code>argvals</code>, and
then <code>rangeval = range(argvale)</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>

<p>a strictly increasing vector of argument values at which line
segments join to form a polygonal line.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropind</code></td>
<td>

<p>a vector of integers specifiying the basis functions to
be dropped, if any.  For example, if it is required that
a function be zero at the left boundary, this is achieved
by dropping the first basis function, the only one that
is nonzero at that point.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to These are proportional
to 1, 4, 2, 4, ..., 2, 4, 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>

<p>a list containing the basis functions and their derivatives
evaluated at the quadrature points contained in the first
column of <code> quadvals </code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisvalues</code></td>
<td>

<p>A list of lists, allocated by code such as vector("list",1).  This
is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each sublist corresponds to a specific
set of argument values, and must have at least two components, which
may be named as you wish.  The first component of a sublist contains
the argument values.  The second component contains a matrix of
values of the basis functions evaluated at the arguments in the
first component.  The third and subsequent components, if present,
contain matrices of values their derivatives up to a maximum
derivative order.  Whenever function <code>getbasismatrix</code> is
called, it checks the first list in each row to see, first, if the
number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time can
be avoided by direct retrieval of the desired array. For example,
you might set up a vector of argument values called "evalargs" along
with a matrix of basis function values for these argument values
called "basismat".  You might want too use tags like "args" and
"values", respectively for these.  You would then assign them to
<code>basisvalues</code> with code such as the following:
</p>
<p>basisobj$basisvalues &lt;- vector("list",1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs, values=basismat)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a single character string to which <code>1:nbasis</code> are
appended as <code>paste(names, 1:nbasis, sep=''</code>.  For example, if
<code>nbasis = 4</code>, this defaults to <code>c('polygon1', 'polygon2',
      'polygon3', 'polygon4')</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this uses
<code>list("axesIntervals", ...)</code>, e.g., with <code>Fourier</code> bases
to create <code>CanadianWeather</code> plots
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The actual basis functions consist of triangles, each with its apex
over an argument value. Note that in effect the polygonal basis is
identical to a B-spline basis of order 2 and a knot or break value at
each argument value.  The range of the polygonal basis is set to the
interval defined by the smallest and largest argument values.
</p>


<h3>Value</h3>

<p>a basis object with the type <code>polyg</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>basisfd</code>,
<code>create.bspline.basis</code>,
<code>create.constant.basis</code>,
<code>create.exponential.basis</code>,
<code>create.fourier.basis</code>,
<code>create.monomial.basis</code>,
<code>create.power.basis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#  Create a polygonal basis over the interval [0,1]
#  with break points at 0, 0.1, ..., 0.95, 1
(basisobj &lt;- create.polygonal.basis(seq(0,1,0.1)))
#  plot the basis
oldpar &lt;- par(no.readonly=TRUE)
plot(basisobj)
par(oldpar)
</code></pre>


</div>