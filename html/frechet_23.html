<div class="container">

<table style="width: 100%;"><tr>
<td>LocDenReg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Local density regression.</h2>

<h3>Description</h3>

<p>Local Fréchet regression for densities with respect to <code class="reqn">L^2</code>-Wasserstein distance.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LocDenReg(
  xin = NULL,
  yin = NULL,
  hin = NULL,
  qin = NULL,
  xout = NULL,
  optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xin</code></td>
<td>
<p>An n by p matrix or a vector of length n if p=1 holding the n observations of the predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yin</code></td>
<td>
<p>A matrix or list holding the sample of observations of the response. If <code>yin</code> is a matrix, each row holds the observations of the response corresponding to a predictor value in the corresponding row of <code>xin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hin</code></td>
<td>
<p>A list holding the histograms of the response corresponding to each predictor value in the corresponding row of <code>xin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qin</code></td>
<td>
<p>A matrix or list holding the quantile functions of the response. If <code>qin</code> is a matrix, the support of the quantile functions should be the same (i.e., <code>optns$qSup</code>), and each row of <code>qin</code> holds the quantile function corresponding to a predictor value in the corresponding row of <code>xin</code>. If the quantile functions are evaluated on different grids, then <code>qin</code> should be a list, each element consisting of two components <code>x</code> and <code>y</code> holding the support grid and the corresponding values of the quantile functions, respectively.
Note that only one of the three <code>yin</code>, <code>hin</code>, and <code>qin</code> needs to be input.
If more than one of them are specified, <code>yin</code> overwrites <code>hin</code>, and <code>hin</code> overwrites <code>qin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xout</code></td>
<td>
<p>An m by p matrix or a vector of length m if p=1 holding the m output predictor values. Default is <code>xin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optns</code></td>
<td>
<p>A list of control parameters specified by <code>list(name=value)</code>. See ‘Details’.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Available control options are
</p>

<dl>
<dt>bwReg</dt>
<dd>
<p>A vector of length p used as the bandwidth for the Fréchet regression or <code>"CV"</code> (default), i.e., a data-adaptive selection done by cross-validation.</p>
</dd>
<dt>kernelReg</dt>
<dd>
<p>A character holding the type of kernel functions for local Fréchet regression for densities; <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>qSup</dt>
<dd>
<p>A numeric vector holding the grid on [0,1] quantile functions take value on. Default is an equidistant grid.</p>
</dd>
<dt>nqSup</dt>
<dd>
<p>A scalar giving the length of <code>qSup</code>. Default is 201.</p>
</dd>
<dt>lower</dt>
<dd>
<p>A scalar with the lower bound of the support of the distribution. Default is <code>NULL</code>.</p>
</dd>
<dt>upper</dt>
<dd>
<p>A scalar with the upper bound of the support of the distribution. Default is <code>NULL</code>.</p>
</dd>
<dt>bwRange</dt>
<dd>
<p>A 2 by p matrix whose columns contain the bandwidth selection range for each corresponding dimension of the predictor <code>xin</code> for the case when <code>bwReg</code> equals <code>"CV"</code>. Default is <code>NULL</code> and is automatically chosen by a data-adaptive method.</p>
</dd>
<dt>bwDen</dt>
<dd>
<p>The bandwidth value used in <code>CreateDensity()</code> for density estimation; positive numeric - default: determine automatically based on the data-driven bandwidth selector proposed by Sheather and Jones (1991).</p>
</dd>
<dt>ndSup</dt>
<dd>
<p>The number of support points the kernel density estimation uses in <code>CreateDensity()</code>; numeric - default: 101.</p>
</dd>
<dt>dSup</dt>
<dd>
<p>User defined output grid for the support of kernel density estimation used in <code>CreateDensity()</code>, it overrides <code>nRegGrid</code>; numeric - default: <code>NULL</code></p>
</dd>
<dt>delta</dt>
<dd>
<p>The size of the bin to be used used in <code>CreateDensity()</code>; numeric - default: <code>diff(range(y))/1000</code>. It only works when the raw sample is available.</p>
</dd>
<dt>kernelDen</dt>
<dd>
<p>A character holding the type of kernel functions used in <code>CreateDensity()</code> for density estimation; <code>"rect"</code>, <code>"gauss"</code>, <code>"epan"</code>, <code>"gausvar"</code>, <code>"quar"</code> - default: <code>"gauss"</code>.</p>
</dd>
<dt>infSupport</dt>
<dd>
<p>logical if we expect the distribution to have infinite support or not, used in <code>CreateDensity()</code> for density estimation; logical - default: <code>FALSE</code></p>
</dd>
<dt>denLowerThreshold</dt>
<dd>
<p><code>FALSE</code> or a positive value giving the lower threshold of the densities used in <code>CreateDensity()</code>; default: <code>0.001 * mean(qin[,ncol(qin)] - qin[,1])</code>.</p>
</dd>
</dl>
<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>xout</code></td>
<td>
<p>Input <code>xout</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dout</code></td>
<td>
<p>A matrix or list holding the output densities corresponding to <code>xout</code>. If <code>dout</code> is a matrix, each row gives a density and the domain grid is given in <code>dSup</code>. If <code>dout</code> is a list, each element is a list of two components, <code>x</code> and <code>y</code>, giving the domain grid and density function values, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>dout</code> when it is a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qout</code></td>
<td>
<p>A matrix holding the quantile functions of the output densities. Each row corresponds to a value in <code>xout</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qSup</code></td>
<td>
<p>A numeric vector giving the domain grid of <code>qout</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xin</code></td>
<td>
<p>Input <code>xin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>din</code></td>
<td>
<p>Densities corresponding to the input <code>yin</code>, <code>hin</code> or <code>qin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qin</code></td>
<td>
<p>Quantile functions corresponding to the input <code>yin</code>, <code>hin</code> or <code>qin</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optns</code></td>
<td>
<p>A list of control options used.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p><cite>Petersen, A., &amp; Müller, H.-G. (2019). "Fréchet regression for random objects with Euclidean predictors." The Annals of Statistics, 47(2), 691–719.</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
xin = seq(0,1,0.05)
yin = lapply(xin, function(x) {
  rnorm(100, rnorm(1,x + x^2,0.005), 0.05)
})
qSup = seq(0,1,0.02)
xout = seq(0,1,0.1)
res1 &lt;- LocDenReg(xin=xin, yin=yin, xout=xout, optns = list(bwReg = 0.12, qSup = qSup))
plot(res1)
xout &lt;- xin
hin = lapply(yin, function(y) hist(y, breaks = 50))
res2 &lt;- LocDenReg(xin=xin, hin=hin, xout=xout, optns = list(qSup = qSup))
plot(res2)

</code></pre>


</div>