<div class="container">

<table style="width: 100%;"><tr>
<td>%Xc%</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Constrained row tensor product</h2>

<h3>Description</h3>

<p>Combining single base-learners to form new, more complex base-learners, with
an identifiability constraint to center the interaction around the intercept and
around the two main effects. Suitable for functional response.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bl1 %Xc% bl2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>bl1</code></td>
<td>
<p>base-learner 1, e.g. <code>bols(x1)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bl2</code></td>
<td>
<p>base-learner 2, e.g. <code>bols(x2)</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Similar to <code>%X%</code> in package <code>mboost</code>, see 
<code>%X%</code>, 
a row tensor product of linear base-learners is returned by <code>%Xc%</code>. 
<code>%Xc%</code> applies a sum-to-zero constraint to the design matrix suitable for
functional response if an interaction of two scalar covariates is specified 
in the case that the model contains a global intercept and both main effects, 
as the interaction is centered around the intercept and centered around the two main effects. 
See Web Appendix A of Brockhaus et al. (2015) for details on how to enforce the constraint 
for the functional intercept.   
Use, e.g., in a model call to <code>FDboost</code>, following the scheme, 
<code>y ~ 1 + bolsc(x1) + bolsc(x2) + bols(x1) %Xc% bols(x2)</code>, 
where <code>1</code> induces a global intercept and <code>x1</code>, <code>x2</code> are factor variables, 
see Ruegamer et al. (2018).
</p>


<h3>Value</h3>

<p>An object of class <code>blg</code> (base-learner generator) with a <code>dpp</code> function 
as for other <code>baselearners</code>.
</p>


<h3>Author(s)</h3>

<p>Sarah Brockhaus, David Ruegamer
</p>


<h3>References</h3>

<p>Brockhaus, S., Scheipl, F., Hothorn, T. and Greven, S. (2015): 
The functional linear array model. Statistical Modelling, 15(3), 279-300.
</p>
<p>Ruegamer D., Brockhaus, S., Gentsch K., Scherer, K., Greven, S. (2018). 
Boosting factor-specific functional historical models for the detection of synchronization in bioelectrical signals. 
Journal of the Royal Statistical Society: Series C (Applied Statistics), 67, 621-642.
</p>


<h3>Examples</h3>

<pre><code class="language-R"> 
######## Example for function-on-scalar-regression with interaction effect of two scalar covariates 
data("viscosity", package = "FDboost") 
## set time-interval that should be modeled
interval &lt;- "101"

## model time until "interval" and take log() of viscosity
end &lt;- which(viscosity$timeAll == as.numeric(interval))
viscosity$vis &lt;- log(viscosity$visAll[,1:end])
viscosity$time &lt;- viscosity$timeAll[1:end]
# with(viscosity, funplot(time, vis, pch = 16, cex = 0.2))

## fit model with interaction that is centered around the intercept 
## and the two main effects 
mod1 &lt;- FDboost(vis ~ 1 + bolsc(T_C, df=1) + bolsc(T_A, df=1) + 
                bols(T_C, df=1) %Xc% bols(T_A, df=1),
                timeformula = ~bbs(time, df=6),
                numInt = "equal", family = QuantReg(),
                offset = NULL, offset_control = o_control(k_min = 9),
                data = viscosity, control=boost_control(mstop = 100, nu = 0.4))
                
## check centering around intercept
colMeans(predict(mod1, which = 4))

## check centering around main effects
colMeans(predict(mod1, which = 4)[viscosity$T_A == "low", ])
colMeans(predict(mod1, which = 4)[viscosity$T_A == "high", ])
colMeans(predict(mod1, which = 4)[viscosity$T_C == "low", ])
colMeans(predict(mod1, which = 4)[viscosity$T_C == "low", ])

## find optimal mstop using cvrsik() or validateFDboost()
## ... 

## look at interaction effect in one plot
# funplot(mod1$yind, predict(mod1, which=4))

</code></pre>


</div>