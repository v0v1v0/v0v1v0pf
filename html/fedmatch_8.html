<div class="container">

<table style="width: 100%;"><tr>
<td>build_tier</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Build settings for a tier</h2>

<h3>Description</h3>

<p><code>build_tier_settings</code> is a convenient way to make the proper list for the
<code>tier_list</code> argument of <code>tier_match</code> Each vector in build_score_settings
should be the same length, and each position (first, second, third, etc.)
corresponds to one variable to score on.
</p>


<h3>Usage</h3>

<pre><code class="language-R">build_tier(
  by.x = NULL,
  by.y = NULL,
  check_merge = NULL,
  match_type = NULL,
  fuzzy_settings = build_fuzzy_settings(),
  score_settings = NULL,
  filter = NULL,
  filter.args = NULL,
  evaluate = NULL,
  evaluate.args = NULL,
  clean_settings = build_clean_settings(),
  clean = NULL,
  sequential_words = NULL,
  allow.cartesian = FALSE,
  multivar_settings = build_multivar_settings()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>by.x</code></td>
<td>
<p>character string. Variable to merge on in data1. See <code>merge</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.y</code></td>
<td>
<p>character string. Variable to merge on in data2. See <code>merge</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_merge</code></td>
<td>
<p>logical. Checks that your unique_keys are indeed unique.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>match_type</code></td>
<td>
<p>string. If 'exact', match is exact, if 'fuzzy', match is
fuzzy. If 'multivar,' match is multivar-based. See <code>multivar_match</code>,</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fuzzy_settings</code></td>
<td>
<p>additional arguments for amatch, to be used if match_type
= 'fuzzy'. Suggested defaults provided. (see amatch, method='jw')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score_settings</code></td>
<td>
<p>list. Score settings for post-hoc matchscores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>function or numeric. Filters a merged data1-data2 dataset. If a
function, should take in a data.frame (data1 and data2 merged by name1 and
name2) and spit out a trimmed version of the data.frame (fewer rows). Think
of this function as applying other conditions to matches, other than a
match by name. The first argument of filter should be the data.frame. If
numeric, will drop all observations with a matchscore lower than or equal
to filter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.args</code></td>
<td>
<p>list. Arguments passed to filter, if a function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate</code></td>
<td>
<p>Function to evaluate merge_plus output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>evaluate.args</code></td>
<td>
<p>list. Arguments passed to evaluate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean_settings</code></td>
<td>
<p>list. Settings for string cleaning. See <code>clean_strings</code> and <code>build_clean_settings</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clean</code></td>
<td>
<p>Boolean, T/F, whether or not to clean strings prior to the match.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sequential_words</code></td>
<td>
<p>data.table of words in the same format of the common_words argument in <code>clean_strings</code>. Each of these will be replaced from the by columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow.cartesian</code></td>
<td>
<p>whether or not to allow many-many matches, see data.table::merge()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multivar_settings</code></td>
<td>
<p>list of settings to go to the multivar match if match_type
== 'multivar'. See <code>multivar-match</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list containing 1 tier for the 'tier_list' argument of <code>tier_match</code>.
</p>


</div>