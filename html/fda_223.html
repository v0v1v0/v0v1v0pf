<div class="container">

<table style="width: 100%;"><tr>
<td>smooth.monotone</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Monotone Smoothing of Data
</h2>

<h3>Description</h3>

<p>When the discrete data that are observed reflect a smooth strictly
increasing or strictly decreasing function, it is often desirable to
smooth the data with a strictly monotone function, even though the
data themselves may not be monotone due to observational error.  An
example is when data are collected on the size of a growing organism
over time.  This function computes such a smoothing function, but,
unlike other smoothing functions, for only for one curve at a time.
The smoothing function minimizes a weighted error sum of squares
criterion.  This minimization requires iteration, and therefore is
more computationally intensive than normal smoothing.
</p>
<p>The monotone smooth is beta[1]+beta[2]*integral(exp(Wfdobj)), where
Wfdobj is a functional data object.  Since exp(Wfdobj)&gt;0, its integral
is monotonically increasing.
</p>


<h3>Usage</h3>

<pre><code class="language-R">smooth.monotone(argvals, y, WfdParobj, wtvec=rep(1,n),
                zmat=NULL, conv=.0001, iterlim=50,
                active=rep(TRUE,nbasis), dbglev=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>

<p>Argument value array of length N, where N is the number of observed
curve values for each curve.  It is assumed that that these argument
values are common to all observed curves.  If this is not the case,
you will need to run this function inside one or more loops,
smoothing each curve separately.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>a vector of data values.  This function can only smooth one set of
data at a time.
</p>
<p>Function value array (the values to be fit).  If the functional data
are univariate, this array will be an N by NCURVE matrix, where N is
the number of observed curve values for each curve and NCURVE is the
number of curves observed.  If the functional data are multivariate,
this array will be an N by NCURVE by NVAR matrix, where NVAR the
number of functions observed per case.  For example, for the gait
data, NVAR = 2, since we observe knee and hip angles.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WfdParobj</code></td>
<td>

<p>A functional parameter or fdPar object.  This object contains the
specifications for the functional data object to be estimated by
smoothing the data.  See comment lines in function fdPar for
details.  The functional data object WFD in WFDPAROBJ is used to
initialize the optimization process.  Its coefficient array contains
the starting values for the iterative minimization of mean squared
error.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wtvec</code></td>
<td>

<p>a vector of weights to be used in the smoothing.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zmat</code></td>
<td>

<p>a design matrix or a matrix of covariate values that also define the
smooth of the data.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>a convergence criterion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterlim</code></td>
<td>

<p>the maximum number of iterations allowed in the minimization of
error sum of squares.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active</code></td>
<td>

<p>a logical vector specifying which coefficients defining W(t) are
estimated.  Normally, the first coefficient is fixed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  If either level 1 or 2 is specified, it
can be helpful to turn off the output buffering feature of S-PLUS.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The smoothing function  f(argvals) is determined by three objects
that need to be estimated from the data:
</p>

<ul>
<li>
<p> W(argvals), a functional data object that is first
exponentiated and then the result integrated.  This is the heart
of the monotone smooth.  The closer W(argvals) is to zero, the
closer the monotone smooth becomes a straight line.  The closer
W(argvals) becomes a constant, the more the monotone smoother
becomes an exponential function.  It is assumed that W(0) = 0.
</p>
</li>
<li>
<p> b0, an intercept term that determines the value of the
smoothing function at argvals = 0.
</p>
</li>
<li>
<p> b1, a regression coefficient that determines the slope
of the smoothing function at argvals = 0.
</p>
</li>
</ul>
<p>In addition, it is possible to have the intercept b0
depend in turn on the values of one or more covariates through the
design matrix <code>Zmat</code> as follows:
b0 = Z c. In this case, the single
intercept coefficient is replaced by the regression coefficients
in vector c multiplying the design matrix.
</p>


<h3>Value</h3>

<p>an object of class <code>monfd</code>, which is a list with the following 5
components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function W(argvals) that
optimizes the fit to the data of the monotone function that it
defines.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>

<p>The regression coefficients b_0 and b_1 for each smoothed
curve.
</p>
<p>If the curves are univariate and
... ZMAT is NULL,       BETA is 2   by NCURVE.
... ZMAT has P columns, BETA is P+1 by NCURVE.
</p>
<p>If the curves are multivariate and
... ZMAT is NULL,       BETA is 2   by NCURVE by NVAR.
... ZMAT has P columns, BETA is P+1 by NCURVE by NVAR.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yhatfd</code></td>
<td>

<p>A functional data object for the monotone curves that smooth the
data.  This object is constructed using the basis for WFDOBJ, and
this basis may  well be too simple to accommodate the curvature
in the monotone function that Wfdobjnes.  It may be
necessary to discard this object and use a richer basis
externally to smooth the values defined by
beta[1] + beta[2]*eval.monfd(evalarg, Wfdobj).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged
solution:  (1) <b>f</b>: the optimal function value being minimized,
(2) <b>grad</b>: the gradient vector at the optimal solution, and
(3) <b>norm</b>: the norm of the gradient vector at the optimal
solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y2cMap</code></td>
<td>

<p>For each estimated curve (and variable if functions are
multivariate, this is an N by NBASIS matrix containing a linear
mapping from data to coefficients that can be used for computing
point-wise confidence intervals.  If NCURVE = NVAR = 1, a matrix is
returned.  Otherwise an NCURVE by NVAR list is returned, with each
slot containing this mapping.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>

<p>input <code>argvals</code>, possibly modified / clarified by
<code>argcheck</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>input argument <code>y</code>, possibly modified / clarified by
<code>ycheck</code>.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>smooth.basis</code>,
<code>smooth.pos</code>,
<code>smooth.morph</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">oldpar &lt;- par(no.readonly=TRUE)
#  Estimate the acceleration functions for growth curves
#  See the analyses of the growth data.
#  Set up the ages of height measurements for Berkeley data

age &lt;- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
#  Range of observations
rng &lt;- c(1,18)
#  First set up a basis for monotone smooth
#  We use b-spline basis functions of order 6
#  Knots are positioned at the ages of observation.
norder &lt;- 6
nage   &lt;- length(age)
nbasis &lt;- nage + norder - 2
wbasis &lt;- create.bspline.basis(rng, nbasis, norder, age)
#  starting values for coefficient
cvec0 &lt;- matrix(0,nbasis,1)
Wfd0  &lt;- fd(cvec0, wbasis)
#  set up functional parameter object
Lfdobj    &lt;- 3          #  penalize curvature of acceleration
lambda    &lt;- 10^(-0.5)  #  smoothing parameter
growfdPar &lt;- fdPar(Wfd0, Lfdobj, lambda)
#  Set up wgt vector
wgt   &lt;- rep(1,nage)
#  Smooth the data for the first girl
hgt1 = growth$hgtf[,1]

# conv=0.1 to reduce the compute time,
# required to reduce the test time on CRAN

# delete the test on CRAN because it takes too long

if (!CRAN()) {
result &lt;- smooth.monotone(age, hgt1, growfdPar, wgt,
                          conv=0.1)
#  Extract the functional data object and regression
#  coefficients
Wfd  &lt;- result$Wfdobj
beta &lt;- result$beta
#  Evaluate the fitted height curve over a fine mesh
agefine &lt;- seq(1,18,len=73)
hgtfine &lt;- beta[1] + beta[2]*eval.monfd(agefine, Wfd)
#  Plot the data and the curve
plot(age, hgt1, type="p")
lines(agefine, hgtfine)
#  Evaluate the acceleration curve
accfine &lt;- beta[2]*eval.monfd(agefine, Wfd, 2)
#  Plot the acceleration curve
plot(agefine, accfine, type="l")
lines(c(1,18),c(0,0),lty=4)
}
par(oldpar)
</code></pre>


</div>