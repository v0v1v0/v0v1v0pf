<div class="container">

<table style="width: 100%;"><tr>
<td>fnn.cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional Neural Networks with Cross-validation</h2>

<h3>Description</h3>

<p>This is a convenience function for the user. The inputs are largely the same as the <code>fnn.fit()</code> function with the
additional parameter of fold choice. This function only works for scalar responses.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fnn.cv(
  nfolds,
  resp,
  func_cov,
  scalar_cov = NULL,
  basis_choice = c("fourier"),
  num_basis = c(7),
  hidden_layers = 2,
  neurons_per_layer = c(64, 64),
  activations_in_layers = c("sigmoid", "linear"),
  domain_range = list(c(0, 1)),
  epochs = 100,
  loss_choice = "mse",
  metric_choice = list("mean_squared_error"),
  val_split = 0.2,
  learn_rate = 0.001,
  patience_param = 15,
  early_stopping = TRUE,
  print_info = TRUE,
  batch_size = 32,
  decay_rate = 0,
  func_resp_method = 1,
  covariate_scaling = TRUE,
  raw_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>The number of folds to be used in the cross-validation process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resp</code></td>
<td>
<p>For scalar responses, this is a vector of the observed dependent variable. For functional responses,
this is a matrix where each row contains the basis coefficients defining the functional response (for each observation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func_cov</code></td>
<td>
<p>The form of this depends on whether the <code>raw_data</code> argument is true or not. If true, then this is
a list of k matrices. The dimensionality of the matrices should be the same (n x p) where n is the number of
observations and p is the number of longitudinal observations. If <code>raw_data</code> is false, then the input should be a tensor
with dimensionality b x n x k where b is the number of basis functions used to define the functional covariates, n is
the number of observations, and k is the number of functional covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scalar_cov</code></td>
<td>
<p>A matrix contained the multivariate information associated with the data set. This is all of your
non-longitudinal data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basis_choice</code></td>
<td>
<p>A vector of size k (the number of functional covariates) with either "fourier" or "bspline" as the inputs.
This is the choice for the basis functions used for the functional weight expansion. If you only specify one, with k &gt; 1,
then the argument will repeat that choice for all k functional covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_basis</code></td>
<td>
<p>A vector of size k defining the number of basis functions to be used in the basis expansion. Must be odd
for <code>fourier</code> basis choices. If you only specify one, with k &gt; 1, then the argument will repeat that choice for all
k functional covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hidden_layers</code></td>
<td>
<p>The number of hidden layers to be used in the neural network.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neurons_per_layer</code></td>
<td>
<p>Vector of size = <code>hidden_layers</code>. The u-th element of the vector corresponds to the number of neurons
in the u-th hidden layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>activations_in_layers</code></td>
<td>
<p>Vector of size = <code>hidden_layers</code>. The u-th element of the vector corresponds to the
activation choice in the u-th hidden layer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain_range</code></td>
<td>
<p>List of size k. Each element of the list is a 2-dimensional vector containing the upper and lower
bounds of the k-th functional weight.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epochs</code></td>
<td>
<p>The number of training iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss_choice</code></td>
<td>
<p>This parameter defines the loss function used in the learning process.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric_choice</code></td>
<td>
<p>This parameter defines the printed out error metric.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>val_split</code></td>
<td>
<p>A parameter that decides the percentage split of the inputted data set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learn_rate</code></td>
<td>
<p>Hyperparameter that defines how quickly you move in the direction of the gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>patience_param</code></td>
<td>
<p>A keras parameter that decides how many additional <code>epochs</code> are eclipsed with minimal change in
error before the learning process is stopped. This is only active if <code>early_stopping = TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stopping</code></td>
<td>
<p>If TRUE, then learning process will be halted early if error improvement isn't seen.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print_info</code></td>
<td>
<p>If TRUE, function will output information about the model as it is trained.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p>Size of the batch for stochastic gradient descent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decay_rate</code></td>
<td>
<p>A modification to the learning rate that decreases the learning rate as more and more learning
iterations are completed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func_resp_method</code></td>
<td>
<p>Set to 1 by default. In the future, this will be set to 2 for an alternative functional response
approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariate_scaling</code></td>
<td>
<p>If TRUE, then data will be internally scaled before model development.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw_data</code></td>
<td>
<p>If TRUE, then user does not need to create functional observations beforehand. The function will
internally take care of that pre-processing.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>No additional details for now.
</p>


<h3>Value</h3>

<p>The following are returned.
</p>
<p><code>predicted_folds</code> – The predicted scalar values in each fold.
</p>
<p><code>true_folds</code> – The true values of the response in each fold.
</p>
<p><code>MSPE</code> – A list object containing the MSPE in each fold and the overall cross-validated MSPE.
</p>
<p><code>fold_indices</code> – The generated indices for each fold; for replication purposes.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Libraries
library(fda)

# Loading data
data("daily")

# Creating functional data
nbasis = 65
temp_data = array(dim = c(nbasis, 35, 1))
tempbasis65  = create.fourier.basis(c(0,365), nbasis)
tempbasis7 = create.bspline.basis(c(0,365), 7, norder = 4)
timepts = seq(1, 365, 1)
temp_fd = Data2fd(timepts, daily$tempav, tempbasis65)
prec_fd = Data2fd(timepts, daily$precav, tempbasis7)
prec_fd$coefs = scale(prec_fd$coefs)

# Data set up
temp_data[,,1] = temp_fd$coefs
resp_mat = prec_fd$coefs

# Non functional covariate
weather_scalar = data.frame(total_prec = apply(daily$precav, 2, sum))

# Setting up data to pass in to function
weather_data_full &lt;- array(dim = c(nbasis, ncol(temp_data), 1))
weather_data_full[,,1] = temp_data
scalar_full = data.frame(weather_scalar[,1])
total_prec = apply(daily$precav, 2, mean)

# cross-validating
cv_example &lt;- fnn.cv(nfolds = 5,
                     resp = total_prec,
                     func_cov = weather_data_full,
                     scalar_cov = scalar_full,
                     domain_range = list(c(1, 365)),
                     learn_rate = 0.001)


</code></pre>


</div>