<div class="container">

<table style="width: 100%;"><tr>
<td>WassFIntegral</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generalized Fréchet integrals of 1D distribution</h2>

<h3>Description</h3>

<p>Calculating generalized Fréchet integrals of 1D distribution (equipped with Wasserstein distance)
</p>


<h3>Usage</h3>

<pre><code class="language-R">WassFIntegral(phi, t_out, Q, Qout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>phi</code></td>
<td>
<p>An eigenfunction along which we want to project the distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_out</code></td>
<td>
<p>Support of <code>phi</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>A <code>length(t_out)</code> X <code>length(Qout)</code> matrix whose jth row corresponds to the quantile function on grid <code>Qout</code> for the jth time point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qout</code></td>
<td>
<p>Support of the quantile valued process</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of the following:
</p>
<table><tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Quantile function corresponding to the frechet integral of <code>Q</code> along <code>phi</code></p>
</td>
</tr></table>
<h3>References</h3>

<p><cite>Dubey, P., &amp; Müller, H. G. (2020). Functional models for time‐varying random objects. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 82(2), 275-327.</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#simulation as in the paper Dubey, P., &amp; Müller, H. G. (2020).
# Functional models for time‐varying random objects. 
# JRSSB, 82(2), 275-327.

n &lt;- 100
N &lt;- 50
t_out &lt;- seq(0,1,length.out = N)

phi1 &lt;- function(t){
  (t^2-0.5)/0.3416
}
phi2 &lt;- function(t){
  sqrt(3)*t
}
phi3 &lt;- function(t){
  (t^3 - 0.3571*t^2 - 0.6*t + 0.1786)/0.0895
}

Z &lt;- cbind(rnorm(n)*sqrt(12), rnorm(n), runif(n)*sqrt(72), runif(n)*sqrt(9))
mu_vec &lt;- 1 + Z[,1] %*% t(phi1(t_out)) + Z[,2] %*% t(phi3(t_out))
sigma_vec &lt;- 3 + Z[,3] %*% t(phi2(t_out)) + Z[,4] %*% t(phi3(t_out))

# grids of quantile function
Nq &lt;- 40
eps &lt;- 0.00001
Qout &lt;- seq(0+eps,1-eps,length.out=Nq)

# I: four dimension array of n x n matrix of squared distances 
# between the time point u of the ith process and 
# process and the time point v of the jth object process, 
# e.g.: I[i,j,u,v] &lt;- d_w^2(X_i(u) X_j(v)).
I &lt;- array(0, dim = c(n,n,N,N))
for(i in 1:n){
  for(j in 1:n){
    for(u in 1:N){
      for(v in 1:N){
        #wasserstein distance between distribution X_i(u) and X_j(v) 
        I[i,j,u,v] &lt;- (mu_vec[i,u] - mu_vec[j,v])^2 + (sigma_vec[i,u] - sigma_vec[j,v])^2
      }
    }
  }
}

# check ObjCov work 
Cov_result &lt;- ObjCov(t_out, I, 3)
#Cov_result$lambda #12 6 1.75

# calculate Q 
i &lt;- 6 # for the ith subject
Q &lt;- t(sapply(1:N, function(t){
  qnorm(Qout, mean = mu_vec[i,t], sd = sigma_vec[i,t])
}))

score_result &lt;- WassFIntegral(Cov_result$phi[,1], t_out, Q, Qout)
score_result$f

</code></pre>


</div>