<div class="container">

<table style="width: 100%;"><tr>
<td>fit2df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract model fit results to dataframe (generic): <code>finalfit</code> model
extractors</h2>

<h3>Description</h3>

<p>Takes output from <code>finalfit</code> model wrappers and extracts to a dataframe,
convenient for further processing in preparation for final results table.
</p>
<p><code>fit2df.lm</code> is the model extract method for <code>lm</code>.
</p>
<p><code>fit2df.lmlist</code> is the model extract method for <code>lmuni</code> and
<code>lmmulti</code>.
</p>
<p><code>fit2df.glm</code> is the model extract method for standard
<code>glm</code> models, which have not used <code>finalfit</code> model
wrappers.
</p>
<p><code>fit2df.glmboot</code> is the model extract method for <code>glmmulti_boot</code> models.
</p>
<p><code>fit2df.glmlist</code> is the model extract method for <code>glmuni</code> and <code>glmmulti</code>.
</p>
<p><code>fit2df.svyglmlist</code> is the model extract method for <code>svyglmuni</code> and <code>svyglmmulti</code>.
</p>
<p><code>fit2df.lmerMod</code> is the model extract method for standard
<code>lme4::lmer</code> models and for the
<code>finalfit::lmmixed</code> model wrapper.
</p>
<p><code>fit2df.glmerMod</code> is the model extract method for standard
<code>lme4::glmer</code> models and for the
<code>finalfit::glmmixed</code> model wrapper.
</p>
<p><code>fit2df.coxph</code> is the model extract method for <code>survival::coxph</code>.
</p>
<p><code>fit2df.coxphlist</code> is the model extract method for <code>coxphuni</code> and <code>coxphmulti</code>.
</p>
<p><code>fit2df.crr</code> is the model extract method for <code>cmprsk::crr</code>.
</p>
<p><code>fit2df.coxme</code> is the model extract method for <code>eoxme::coxme</code>.
</p>
<p><code>fit2df.crr</code> is the model extract method for
<code>crruni</code> and <code>crrmulti</code>.
</p>
<p><code>fit2df.stanfit</code> is the model extract method for our standard Bayesian
hierarchical binomial logistic regression models. These models will be fully
documented separately. However this should work for a single or multilevel
Bayesian logistic regression done in Stan, as long as the fixed effects are
specified in the parameters block as a vector named <code>beta</code>, of length
<code>P</code>, where <code>P</code> is the number of fixed effect parameters. e.g.
parameters( vector[P] beta; )
</p>
<p><code>fit2df.mipo</code> is the model extract method for the <code>mipo</code> object
created using <code>mice::pool</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fit2df(...)

## S3 method for class 'lm'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_level = 0.95,
  confint_sep = " to ",
  ...
)

## S3 method for class 'lmlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_level = 0.95,
  confint_sep = " to ",
  ...
)

## S3 method for class 'glm'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_type = "profile",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'glmboot'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'glmlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_type = "profile",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'svyglmlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = FALSE,
  confint_type = "profile",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'lmerMod'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_type = "Wald",
  confint_level = 0.95,
  confint_sep = " to ",
  ...
)

## S3 method for class 'glmerMod'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = TRUE,
  confint_type = "Wald",
  confint_level = 0.95,
  confint_sep = "-",
  ...
)

## S3 method for class 'coxph'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'coxphlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'crr'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'coxme'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'crrlist'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  explanatory_name = "explanatory",
  estimate_name = "HR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'stanfit'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "OR",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  confint_sep = "-",
  ...
)

## S3 method for class 'mipo'
fit2df(
  .data,
  condense = TRUE,
  metrics = FALSE,
  remove_intercept = TRUE,
  explanatory_name = "explanatory",
  estimate_name = "Coefficient",
  estimate_suffix = "",
  p_name = "p",
  digits = c(2, 2, 3),
  exp = FALSE,
  confint_level = 0.95,
  confint_sep = "-",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments: <code>X</code>: Design matrix from stanfit modelling.
Details documented else where.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>Output from <code>finalfit</code> model wrappers.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condense</code></td>
<td>
<p>Logical: when true, effect estimates, confidence intervals
and p-values are pasted conveniently together in single cell.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>Logical: when true, useful model metrics are extracted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_intercept</code></td>
<td>
<p>Logical: remove the results for the intercept term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>explanatory_name</code></td>
<td>
<p>Name for this column in output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate_name</code></td>
<td>
<p>Name for this column in output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate_suffix</code></td>
<td>
<p>Appeneded to estimate name</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_name</code></td>
<td>
<p>Name given to p-value estimate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of digits to round to (1) estimate, (2) confidence
interval limits, (3) p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confint_level</code></td>
<td>
<p>The confidence level required.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confint_sep</code></td>
<td>
<p>String to separate confidence intervals, typically "-" or
" to ".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exp</code></td>
<td>
<p>Currently GLM only. Exponentiate coefficients and confidence
intervals. Defaults to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confint_type</code></td>
<td>
<p>One of <code>c("profile", "default")</code> for GLM models
(confint.glm) or <code>c("profile", "Wald", "boot")</code>
for <code>glmer/lmer</code> models (<code>confint.merMod</code>.). Not
implemented for <code>lm, coxph or coxphlist</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>fit2df</code> is a generic (S3) function for model extract.
</p>


<h3>Value</h3>

<p>A dataframe of model parameters. When <code>metrics=TRUE</code> output is a
list of two dataframes, one is model parameters, one is model metrics.
length two
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(finalfit)
library(dplyr)
library(survival)
# glm
fit = glm(mort_5yr ~  age.factor + sex.factor + obstruct.factor + perfor.factor,
  data=colon_s, family="binomial")
fit %&gt;%
  fit2df(estimate_suffix=" (multivariable)")

# glmlist
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  glmmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (univariable)")

# glmerMod
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "mort_5yr"
colon_s %&gt;%
  glmmixed(dependent, explanatory, random_effect) %&gt;%
  fit2df(estimate_suffix=" (multilevel)")

# glmboot
## Note number of draws set to 100 just for speed in this example
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "mort_5yr"
colon_s %&gt;%
  glmmulti_boot(dependent, explanatory,  R = 100) %&gt;%
  fit2df(estimate_suffix=" (multivariable (BS CIs))")

# lm
fit = lm(nodes ~  age.factor + sex.factor + obstruct.factor + perfor.factor,
  data=colon_s)
fit %&gt;%
  fit2df(estimate_suffix=" (multivariable)")

# lmerMod
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
random_effect = "hospital"
dependent = "nodes"

colon_s %&gt;%
  lmmixed(dependent, explanatory, random_effect) %&gt;%
  fit2df(estimate_suffix=" (multilevel")

# coxphlist
explanatory = c("age.factor", "sex.factor", "obstruct.factor", "perfor.factor")
dependent = "Surv(time, status)"

colon_s %&gt;%
  coxphuni(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (univariable)")

colon_s %&gt;%
  coxphmulti(dependent, explanatory) %&gt;%
  fit2df(estimate_suffix=" (multivariable)")

# coxph
fit = coxph(Surv(time, status) ~ age.factor + sex.factor + obstruct.factor + perfor.factor,
  data = colon_s)

fit %&gt;%
  fit2df(estimate_suffix=" (multivariable)")
	
# crr: competing risks
melanoma = boot::melanoma
melanoma = melanoma %&gt;% 
  mutate(
    status_crr = ifelse(status == 2, 0, # "still alive"
      ifelse(status == 1, 1, # "died of melanoma"
      2)), # "died of other causes" 
    sex = factor(sex),
    ulcer = factor(ulcer)
  )

dependent = c("Surv(time, status_crr)")
explanatory = c("sex", "age", "ulcer")
melanoma %&gt;% 
  summary_factorlist(dependent, explanatory, column = TRUE, fit_id = TRUE) %&gt;% 
  ff_merge(
    melanoma %&gt;% 
      crrmulti(dependent, explanatory) %&gt;% 
      fit2df(estimate_suffix = " (competing risks)")
  ) %&gt;% 
select(-fit_id, -index) %&gt;% 
dependent_label(melanoma, dependent)
</code></pre>


</div>