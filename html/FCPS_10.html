<div class="container">

<table style="width: 100%;"><tr>
<td>ClusterApply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Applies a function over grouped data</h2>

<h3>Description</h3>

<p>Applies a given function to each dimension <code>d</code> of data separately for each cluster</p>


<h3>Usage</h3>

<pre><code class="language-R">ClusterApply(DataOrDistances,FUN,Cls,Simple=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>DataOrDistances</code></td>
<td>
<p>  [1:n,1:d] with: if d=n and symmetric then distance matrix assumed, otherwise:
</p>
<p>[1:n,1:d] matrix of defining the dataset that consists of <code>n</code> cases or d-dimensional data points. Every case has <code>d</code> attributes, variables or features.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>Function to be applied to each cluster of data and each column of data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cls</code></td>
<td>
<p>[1:n]  numerical vector with n numbers defining the classification as the main output of the clustering algorithm. It has k unique numbers representing the arbitrary labels of the clustering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Simple</code></td>
<td>
<p>Boolean, if TRUE, simplifies output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters to be passed on to FUN</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Applies a given function to each feature of each cluster of data using the clustering stored in <code>Cls</code> which is the cluster identifiers for all rows in data. If missing, all data are in first cluster, The main output is <code>FUNPerCluster[i]</code> which is the result of <code>FUN</code> for the data points in cluster of <code>UniqueClusters[i]</code> named with the function's name used.
</p>
<p>In case of a distance matrix an automatic classical multidimensional scaling transformation of distances to data is computed. Number of dimensions is selected by the minimal stress w.r.t. the possible output dimensions of cmdscale.
</p>
<p>If <code>FUN</code> has not function name, then ResultPerCluster is given back.
</p>


<h3>Value</h3>

<p>if(Simple==FALSE)
List with
</p>
<table>
<tr style="vertical-align: top;">
<td><code>UniqueClusters</code></td>
<td>
<p>The unique clusters in Cls</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUNPerCluster</code></td>
<td>
<p>a matrix of [1:k,1:d] of d features and k clusters, the list element is named by the function <code>FUN</code> used </p>
</td>
</tr>
</table>
<p>if(Simple==TRUE)
</p>
<p>a matrix of [1:k,1:d] of d features and k clusters
</p>


<h3>Author(s)</h3>

<p>Felix Pape, Michael Thrun</p>


<h3>Examples</h3>

<pre><code class="language-R">##one dataset
data(Hepta)
Data=Hepta$Data
Cls=Hepta$Cls
#mean per cluster
ClusterApply(Data,mean,Cls)

#Simplified
ClusterApply(Data,mean,Cls,Simple=TRUE)

# Mean per cluster of MDS transformation
# Beware, this is not the same!

ClusterApply(as.matrix(dist(Data)),mean,Cls)


## Not run: 
Iris=datasets::iris
Distances=as.matrix(Iris[,1:4])
SomeFactors=Iris$Species
V=ClusterCreateClassification(SomeFactors)
Cls=V$Cls
V$ClusterNames
ClusterApply(Distances,mean,Cls)

## End(Not run)
#special case of identity
## Not run: 
suppressPackageStartupMessages(library('prabclus',quietly = TRUE))
data(tetragonula)
#Generated Specific Distance Matrix
ta &lt;- alleleconvert(strmatrix=as.matrix(tetragonula[1:236,]))
tai &lt;- alleleinit(allelematrix=ta,distance="none")
Distance=alleledist((unbuild.charmatrix(tai$charmatrix,236,13)),236,13)

MDStrans=ClusterApply(Distance,identity)$identityPerCluster

## End(Not run)
</code></pre>


</div>