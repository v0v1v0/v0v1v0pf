<div class="container">

<table style="width: 100%;"><tr>
<td>after_join</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Join tables based on one event happening after another</h2>

<h3>Description</h3>

<p>Join two tables based on observations in one table happening after
observations in the other. Each table must have a user_id column,
which must always match for two observations to be joined,
and a time column, which must be greater in <code>y</code> than in <code>x</code> for
the two to be joined.
Supports all types of dplyr joins (inner, left, anti, etc.) and requires a
type argument to specify which observations in a funnel get kept
(see details for supported types).
</p>


<h3>Usage</h3>

<pre><code class="language-R">after_join(
  x,
  y,
  by_time,
  by_user,
  mode = "inner",
  type = "first-first",
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)

after_inner_join(
  x,
  y,
  by_time,
  by_user,
  type,
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)

after_left_join(
  x,
  y,
  by_time,
  by_user,
  type,
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)

after_right_join(
  x,
  y,
  by_time,
  by_user,
  type,
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)

after_full_join(
  x,
  y,
  by_time,
  by_user,
  type,
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)

after_anti_join(
  x,
  y,
  by_time,
  by_user,
  type,
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)

after_semi_join(
  x,
  y,
  by_time,
  by_user,
  type,
  max_gap = NULL,
  min_gap = NULL,
  gap_col = FALSE,
  suffix = c(".x", ".y")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A tbl representing the first event to occur in the funnel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A tbl representing an event to occur in the funnel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_time</code></td>
<td>
<p>A character vector to specify the time columns in x and y.
This would typically be a datetime or a date column. These columns are used to
filter for time y being after time x.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by_user</code></td>
<td>
<p>A character vector to specify the user or identity columns in
x and y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>The method used to join: "inner", "full", "anti", "semi",
"right", "left". Each also has its own function, such as
<code>after_inner_join</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of funnel used to distinguish between event pairs, such
as "first-first", "last-first", or "any-firstafter". See details for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_gap</code></td>
<td>
<p>Optional: the maximum gap allowed between events. Can be a
integer representing the number of seconds or a difftime object, such as
<code>as.difftime(2, units = "hours")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_gap</code></td>
<td>
<p>Optional: the maximum gap allowed between events. Can be a
integer representing the number of seconds or a difftime object, such as
<code>as.difftime(2, units = "hours")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap_col</code></td>
<td>
<p>Whether to include a numeric column, <code>.gap</code>,
with the time difference in seconds between the events.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in x and y,
these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>type</code> can be any combination of <code>first</code>, <code>last</code>, <code>any</code>, <code>lastbefore</code>, <code>firstwithin</code> with <code>first</code>, <code>last</code>, <code>any</code>,  <code>firstafter</code>. Some common ones you may use include:
</p>

<dl>
<dt>first-first</dt>
<dd>
<p>Take the earliest x and y for each user <b>before</b> joining. For example, you want the first time someone entered an experiment, followed by the first time someone <b>ever</b> registered. If they registered, entered the experiment, and registered again, you do not want to include that person.</p>
</dd>
<dt>first-firstafter</dt>
<dd>
<p>Take the first x, then the first y after that. For example, you want when someone first entered an experiment and the first course they started afterwards. You don't care if they started courses before entering the experiment. </p>
</dd>
<dt>lastbefore-firstafter</dt>
<dd>
<p>First x that's followed by a y before the next x. For example, in last click paid ad attribution, you want the last time someone clicked an ad before the first subscription they did afterward.</p>
</dd>
<dt>any-firstafter</dt>
<dd>
<p>Take all Xs followed by the first Y after it. For example, you want all the times someone visited a homepage and their first product page they visited afterwards.</p>
</dd>
<dt>any-any</dt>
<dd>
<p>Take all Xs followed by all Ys. For example, you want all the times someone visited a homepage and <b>all</b> the product pages they saw afterward.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">
library(dplyr)
landed &lt;- tribble(
  ~user_id, ~timestamp,
  1, "2018-07-01",
  2, "2018-07-01",
  2, "2018-07-01",
  3, "2018-07-02",
  4, "2018-07-01",
  4, "2018-07-04",
  5, "2018-07-10",
  5, "2018-07-12",
  6, "2018-07-07",
  6, "2018-07-08"
) %&gt;%
  mutate(timestamp = as.Date(timestamp))

registered &lt;- tribble(
  ~user_id, ~timestamp,
  1, "2018-07-02",
  3, "2018-07-02",
  4, "2018-06-10",
  4, "2018-07-02",
  5, "2018-07-11",
  6, "2018-07-10",
  6, "2018-07-11",
  7, "2018-07-07"
) %&gt;%
 mutate(timestamp = as.Date(timestamp))

after_inner_join(landed, registered, by_user = "user_id",
           by_time = "timestamp", type = "first-first")

# You can use different methods of joining:
after_left_join(landed, registered, by_user = "user_id",
           by_time = "timestamp", type = "first-first")

after_anti_join(landed, registered, by_user = "user_id",
           by_time = "timestamp", type = "any-any")

</code></pre>


</div>