<div class="container">

<table style="width: 100%;"><tr>
<td>sd3</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute first K moments</h2>

<h3>Description</h3>

<p>Compute the (standardized) 2nd through kth moments, the mean, and the number of elements.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sd3(v, na_rm = FALSE, wts = NULL, sg_df = 1, check_wts = FALSE,
  normalize_wts = TRUE)

skew4(v, na_rm = FALSE, wts = NULL, sg_df = 1, check_wts = FALSE,
  normalize_wts = TRUE)

kurt5(v, na_rm = FALSE, wts = NULL, sg_df = 1, check_wts = FALSE,
  normalize_wts = TRUE)

cent_moments(v, max_order = 5L, used_df = 0L, na_rm = FALSE, wts = NULL,
  check_wts = FALSE, normalize_wts = TRUE)

std_moments(v, max_order = 5L, used_df = 0L, na_rm = FALSE, wts = NULL,
  check_wts = FALSE, normalize_wts = TRUE)

cent_cumulants(v, max_order = 5L, used_df = 0L, na_rm = FALSE,
  wts = NULL, check_wts = FALSE, normalize_wts = TRUE)

std_cumulants(v, max_order = 5L, used_df = 0L, na_rm = FALSE,
  wts = NULL, check_wts = FALSE, normalize_wts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>whether to remove NA, false by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wts</code></td>
<td>
<p>an optional vector of weights. Weights are ‘replication’
weights, meaning a value of 2 is shorthand for having two observations
with the corresponding <code>v</code> value. If <code>NULL</code>, corresponds to
equal unit weights, the default. Note that weights are typically only meaningfully defined
up to a multiplicative constant, meaning the units of weights are
immaterial, with the exception that methods which check for minimum df will,
in the weighted case, check against the sum of weights. For this reason,
weights less than 1 could cause <code>NA</code> to be returned unexpectedly due
to the minimum condition. When weights are <code>NA</code>, the same rules for checking <code>v</code>
are applied. That is, the observation will not contribute to the moment
if the weight is <code>NA</code> when <code>na_rm</code> is true. When there is no
checking, an <code>NA</code> value will cause the output to be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sg_df</code></td>
<td>
<p>the number of degrees of freedom consumed in the computation of
the variance or standard deviation. This defaults to 1 to match the 
‘Bessel correction’.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_wts</code></td>
<td>
<p>a boolean for whether the code shall check for negative
weights, and throw an error when they are found. Default false for speed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize_wts</code></td>
<td>
<p>a boolean for whether the weights should be
renormalized to have a mean value of 1. This mean is computed over elements
which contribute to the moments, so if <code>na_rm</code> is set, that means non-NA
elements of <code>wts</code> that correspond to non-NA elements of the data
vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_order</code></td>
<td>
<p>the maximum order of the centered moment to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>used_df</code></td>
<td>
<p>the number of degrees of freedom consumed, used in the denominator
of the centered moments computation. These are subtracted from the number of
observations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the number of elements, the mean, and the 2nd through kth
centered standardized moment, for <code class="reqn">k=2,3,4</code>. These
are computed via the numerically robust one-pass method of Bennett <em>et. al.</em>
In general they will <em>not</em> match exactly with the 'standard'
implementations, due to differences in roundoff.
</p>
<p>These methods are reasonably fast, on par with the 'standard' implementations.
However, they will usually be faster than calling the various standard implementations
more than once.
</p>
<p>Moments are computed as follows, given some values <code class="reqn">x_i</code> and optional weights <code class="reqn">w_i</code>,
defaulting to 1, the weighted mean is computed as
</p>
<p style="text-align: center;"><code class="reqn">\mu = \frac{\sum_i x_i w_i}{\sum w_i}.</code>
</p>

<p>The weighted kth central sum is computed as
</p>
<p style="text-align: center;"><code class="reqn">\mu = \sum_i \left(x_i - \mu\right)^k w_i.</code>
</p>

<p>Let <code class="reqn">n = \sum_i w_i</code> be the sum of weights (or number of observations in the unweighted case).
Then the weighted kth central moment is computed as that weighted sum divided by the
adjusted sum weights:
</p>
<p style="text-align: center;"><code class="reqn">\mu_k = \frac{\sum_i \left(x_i - \mu\right)^k w_i}{n - \nu},</code>
</p>

<p>where <code class="reqn">\nu</code> is the ‘used df’, provided by the user to adjust the denominator.
(Typical values are 0 or 1.)
The weighted kth standardized moment is the central moment divided by the second central moment
to the <code class="reqn">k/2</code> power:
</p>
<p style="text-align: center;"><code class="reqn">\tilde{\mu}_k = \frac{\mu_k}{\mu_2^{k/2}}.</code>
</p>

<p>The (centered) rth cumulant, for <code class="reqn">r \ge 2</code> is then computed using the formula of Willink, namely
</p>
<p style="text-align: center;"><code class="reqn">\kappa_r = \mu_r - \sum_{j=0}^{r - 2} {r - 1 \choose j} \mu_j \kappa {r-j}.</code>
</p>

<p>The standardized rth cumulant is the rth centered cumulant divided by <code class="reqn">\mu_2^{r/2}</code>.
</p>


<h3>Value</h3>

<p>a vector, filled out as follows:
</p>

<dl>
<dt>sd3</dt>
<dd>
<p>A vector of the (sample) standard devation, mean, and number of elements (or the total weight when <code>wts</code>
are given).</p>
</dd>
<dt>skew4</dt>
<dd>
<p>A vector of the (sample) skewness, standard devation, mean, and number of elements (or the total weight when 
<code>wts</code> are given).</p>
</dd>
<dt>kurt5</dt>
<dd>
<p>A vector of the (sample) excess kurtosis, skewness, standard devation, mean, and number of elements (or the
total weight when <code>wts</code> are given).</p>
</dd>
<dt>cent_moments</dt>
<dd>
<p>A vector of the (sample) <code class="reqn">k</code>th centered moment, then <code class="reqn">k-1</code>th centered moment, ..., 
then the <em>variance</em>, the mean, and number of elements (total weight when <code>wts</code> are given).</p>
</dd>
<dt>std_moments</dt>
<dd>
<p>A vector of the (sample) <code class="reqn">k</code>th standardized (and centered) moment, then 
<code class="reqn">k-1</code>th, ..., then standard devation, mean, and number of elements (total weight).</p>
</dd>
<dt>cent_cumulants</dt>
<dd>
<p>A vector of the (sample) <code class="reqn">k</code>th (centered, but this is redundant) cumulant, then the <code class="reqn">k-1</code>th, ...,
then the <em>variance</em> (which is the second cumulant), then <em>the mean</em>, then the number of elements (total weight).</p>
</dd>
<dt>std_cumulants</dt>
<dd>
<p>A vector of the (sample) <code class="reqn">k</code>th standardized (and centered, but this is redundant) cumulant, then the <code class="reqn">k-1</code>th, ...,
down to the third, then <em>the variance</em>, <em>the mean</em>, then the number of elements (total weight).</p>
</dd>
</dl>
<h3>Note</h3>

<p>The first centered (and standardized) moment is often defined to be identically 0. Instead <code>cent_moments</code>
and <code>std_moments</code> returns the mean. 
Similarly, the second standardized moments defined to be identically 1; <code>std_moments</code> instead returns the standard
deviation. The reason is that a user can always decide to ignore the results and fill in a 0 or 1 as they need, but 
could not efficiently compute the mean and standard deviation from scratch if we discard it.
The antepenultimate element of the output of <code>std_cumulants</code> is not a one, even though that ‘should’ be
the standardized second cumulant.
</p>
<p>The antepenultimate element of the output of <code>cent_moments</code>, <code>cent_cumulants</code> and <code>std_cumulants</code> is the <em>variance</em>,
not the standard deviation. All other code return the standard deviation in that place.
</p>
<p>The kurtosis is <em>excess kurtosis</em>, with a 3 subtracted, and should be nearly zero
for Gaussian input.
</p>
<p>The term 'centered cumulants' is redundant. The intent was to avoid possible collision with existing code named 'cumulants'.
</p>
<p>The moment computations provided by fromo are 
numerically robust, but will often <em>not</em> provide the
same results as the 'standard' implementations,
due to differences in roundoff. We make every attempt to balance
speed and robustness. User assumes all risk from using
the fromo package.
</p>
<p>Note that when weights are given, they are treated as replication weights.
This can have subtle effects on computations which require minimum
degrees of freedom, since the sum of weights will be compared to
that minimum, not the number of data points. Weight values
(much) less than 1 can cause computations to return <code>NA</code>
somewhat unexpectedly due to this condition, while values greater
than one might cause the computation to spuriously return a value
with little precision.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Terriberry, T. "Computing Higher-Order Moments Online."
<a href="http://people.xiph.org/~tterribe/notes/homs.html">http://people.xiph.org/~tterribe/notes/homs.html</a>
</p>
<p>J. Bennett, et. al., "Numerically Stable, Single-Pass, 
Parallel Statistics Algorithms," Proceedings of IEEE
International Conference on Cluster Computing, 2009.
<a href="https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265">https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265</a>
</p>
<p>Cook, J. D. "Accurately computing running variance."
<a href="http://www.johndcook.com/standard_deviation.html">http://www.johndcook.com/standard_deviation.html</a>
</p>
<p>Cook, J. D. "Comparing three methods of computing 
standard deviation."
<a href="http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation">http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation</a>
</p>
<p>Willink, R.  "Relationships Between Central Moments and Cumulants, with Formulae for the Central Moments of Gamma Distributions."
Communications in Statistics - Theory and Methods, 32 no 4 (2003): 701-704.
<a href="https://doi.org/10.1081/STA-120018823">https://doi.org/10.1081/STA-120018823</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- rnorm(1e5)
sd3(x)[1] - sd(x)
skew4(x)[4] - length(x)
skew4(x)[3] - mean(x)
skew4(x)[2] - sd(x)
if (require(moments)) {
  skew4(x)[1] - skewness(x)
}


# check 'robustness'; only the mean should change:
kurt5(x + 1e12) - kurt5(x)
# check speed
if (require(microbenchmark) &amp;&amp; require(moments)) {
  dumbk &lt;- function(x) { c(kurtosis(x) - 3.0,skewness(x),sd(x),mean(x),length(x)) }
  set.seed(1234)
  x &lt;- rnorm(1e6)
  print(kurt5(x) - dumbk(x))
  microbenchmark(dumbk(x),kurt5(x),times=10L)
}
y &lt;- std_moments(x,6)
cml &lt;- cent_cumulants(x,6)
std &lt;- std_cumulants(x,6)

# check that skew matches moments::skewness
if (require(moments)) {
    set.seed(1234)
    x &lt;- rnorm(1000)
    resu &lt;- fromo::skew4(x)

    msku &lt;- moments::skewness(x)
    stopifnot(abs(msku - resu[1]) &lt; 1e-14)
}

# check skew vs e1071 skewness, which has a different denominator
if (require(e1071)) {
    set.seed(1234)
    x &lt;- rnorm(1000)
    resu &lt;- fromo::skew4(x)

    esku &lt;- e1071::skewness(x,type=3)
    nobs &lt;- resu[4]
    stopifnot(abs(esku - resu[1] * ((nobs-1)/nobs)^(3/2)) &lt; 1e-14)

    # similarly:
    resu &lt;- fromo::std_moments(x,max_order=3,used_df=0)
    stopifnot(abs(esku - resu[1] * ((nobs-1)/nobs)^(3/2)) &lt; 1e-14)
}

</code></pre>


</div>