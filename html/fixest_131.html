<div class="container">

<table style="width: 100%;"><tr>
<td>setFixest_estimation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Default arguments for fixest estimations</h2>

<h3>Description</h3>

<p>This function sets globally the default arguments of fixest estimations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">setFixest_estimation(
  data = NULL,
  panel.id = NULL,
  fixef.rm = "perfect",
  fixef.tol = 1e-06,
  fixef.iter = 10000,
  collin.tol = 1e-10,
  lean = FALSE,
  verbose = 0,
  warn = TRUE,
  combine.quick = NULL,
  demeaned = FALSE,
  mem.clean = FALSE,
  glm.iter = 25,
  glm.tol = 1e-08,
  data.save = FALSE,
  reset = FALSE
)

getFixest_estimation()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model.
The variables of the non-linear right hand side of the formula are identified
with this <code>data.frame</code> names. Can also be a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>panel.id</code></td>
<td>
<p>The panel identifiers. Can either be: i) a one sided formula
(e.g. <code>panel.id = ~id+time</code>), ii) a character vector of length 2
(e.g. <code>panel.id=c('id', 'time')</code>, or iii) a character scalar of two variables
separated by a comma (e.g. <code>panel.id='id,time'</code>). Note that you can combine variables
with <code>^</code> only inside formulas (see the dedicated section in <code>feols</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.rm</code></td>
<td>
<p>Can be equal to "perfect" (default), "singleton", "both" or "none".
Controls which observations are to be removed. If "perfect", then observations
having a fixed-effect with perfect fit (e.g. only 0 outcomes in Poisson estimations)
will be removed. If "singleton", all observations for which a fixed-effect appears
only once will be removed. Note, importantly, that singletons are removed in just one pass,
there is no recursivity implemented. The meaning of "both" and "none" is direct.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.tol</code></td>
<td>
<p>Precision used to obtain the fixed-effects. Defaults to <code>1e-5</code>.
It corresponds to the maximum absolute difference allowed between two coefficients
of successive iterations. Argument <code>fixef.tol</code> cannot be lower
than <code>10000*.Machine$double.eps</code>. Note that this parameter is dynamically
controlled by the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixef.iter</code></td>
<td>
<p>Maximum number of iterations in fixed-effects algorithm
(only in use for 2+ fixed-effects). Default is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collin.tol</code></td>
<td>
<p>Numeric scalar, default is <code>1e-10</code>. Threshold deciding when variables should
be considered collinear and subsequently removed from the estimation. Higher values means more
variables will be removed (if there is presence of collinearity). One signal of presence of
collinearity is t-stats that are extremely low (for instance when t-stats &lt; 1e-3).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code> then all large objects are removed
from the returned result: this will save memory but will block the possibility to
use many methods. It is recommended to use the arguments <code>se</code> or <code>cluster</code> to
obtain the appropriate standard-errors at estimation time, since obtaining different
SEs won't be possible afterwards.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Integer. Higher values give more information. In particular,
it can detail the number of iterations in the demeaning algorithm
(the first number is the left-hand-side, the other numbers are the right-hand-side variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed
(concerns warnings relating to convergence state).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combine.quick</code></td>
<td>
<p>Logical. When you combine different variables to transform them
into a single fixed-effects you can do e.g. <code>y ~ x | paste(var1, var2)</code>.
The algorithm provides a shorthand to do the same operation: <code>y ~ x | var1^var2</code>.
Because pasting variables is a costly operation, the internal algorithm may use a
numerical trick to hasten the process. The cost of doing so is that you lose the labels.
If you are interested in getting the value of the fixed-effects coefficients
after the estimation, you should use <code>combine.quick = FALSE</code>. By default it is
equal to <code>FALSE</code> if the number of observations is lower than 50,000, and to <code>TRUE</code>
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>demeaned</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only used in the presence of fixed-effects: should
the centered variables be returned? If <code>TRUE</code>, it creates the items
<code>y_demeaned</code> and <code>X_demeaned</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mem.clean</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Only to be used if the data set is
large compared to the available RAM. If <code>TRUE</code> then intermediary objects are removed as
much as possible and <code>gc</code> is run before each substantial C++ section in the internal
code to avoid memory issues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm.iter</code></td>
<td>
<p>Number of iterations of the glm algorithm. Default is 25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>glm.tol</code></td>
<td>
<p>Tolerance level for the glm algorithm. Default is <code>1e-8</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.save</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. If <code>TRUE</code>, the data used for
the estimation is saved within the returned object. Hence later calls to predict(),
vcov(), etc..., will be consistent even if the original data has been modified
in the meantime.
This is especially useful for estimations within loops, where the data changes
at each iteration, such that postprocessing can be done outside the loop without issue.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reset</code></td>
<td>
<p>Logical scalar, default is <code>FALSE</code>. Whether to reset all values.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function <code>getFixest_estimation</code> returns the currently set global defaults.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#
# Example: removing singletons is FALSE by default
#

# =&gt; changing this default

# Let's create data with singletons
base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
base$fe_singletons = as.character(base$species)
base$fe_singletons[1:5] = letters[1:5]

res          = feols(y ~ x1 + x2 | fe_singletons, base)
res_noSingle = feols(y ~ x1 + x2 | fe_singletons, base, fixef.rm = "single")

# New defaults
setFixest_estimation(fixef.rm = "single")
res_newDefault = feols(y ~ x1 + x2 | fe_singletons, base)

etable(res, res_noSingle, res_newDefault)

# Resetting the defaults
setFixest_estimation(reset = TRUE)



</code></pre>


</div>