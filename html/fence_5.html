<div class="container">

<table style="width: 100%;"><tr>
<td>fence.sae</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fence model selection (Small Area Estmation)</h2>

<h3>Description</h3>

<p>Fence model selection (Small Area Estmation)
</p>


<h3>Usage</h3>

<pre><code class="language-R">fence.sae(full, data, B = 100, grid = 101, fence = c("adaptive",
  "nonadaptive"), cn = NA, method = c("F-H", "NER"), D = NA,
  REML = FALSE, bandwidth = NA, cpus = parallel::detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>full</code></td>
<td>
<p>formular of full model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>number of bootstrap sample, parametric for lmer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>grid for c</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fence</code></td>
<td>
<p>fence method to be used, e.g., adaptive, or nonadaptive.
It's suggested to choose nonadaptive procedure if c is known; otherwise nonadaptive must be chosen</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cn</code></td>
<td>
<p>cn for nonadaptive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Select method to use</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>vector containing the D sampling variances of direct estimators for each domain. The values must be sorted as the variables in formula. Only used in FH model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>REML</code></td>
<td>
<p>Restricted Maximum Likelihood approach</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>bandwidth for kernel smooth function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpus</code></td>
<td>
<p>Number of parallel computers</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In Jiang et. al (2008), the adaptive c value is chosen from the highest peak in the p* vs. c plot.  
In Jiang et. al (2009), 95% CI is taken into account while choosing such an adaptive choice of c.
In Thuan Nguyen et. al (2014), the adaptive c value is chosen from the first peak. This approach works better in the 
moderate sample size or weak signal situations.  Empirically, the first peak becomes highest peak when sample size 
increases or signals become stronger
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>list all model candidates in the model space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>list the number of bootstrap samples that have been used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lack_of_fit_matrix</code></td>
<td>
<p>list a matrix of Qs for all model candidates (in columns). Each row is for each bootstrap sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qd_matrix</code></td>
<td>
<p>list a matrix of QM - QM.tilde for all model candidates. Each row is for each bootrap sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>list the value of bandwidth</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_mat</code></td>
<td>
<p>list a matrix of selected models at each c values in grid (in columns). Each row is for each bootstrap sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq_mat</code></td>
<td>
<p>list a matrix of coverage probabilities (frequency/smooth_frequency) of each selected models for a given c value (index)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>list the adaptive choice of c value from which the parsimonious model is selected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sel_model</code></td>
<td>
<p>list the selected (parsimonious) model given the adaptive c value</p>
</td>
</tr>
</table>
<h3>Note</h3>


<ul>
<li>
<p>The current Fence package focuses on variable selection. 
However, Fence methods can be used to select other parameters of interest, e.g., tunning parameter, variance-covariance structure, etc.
</p>
</li>
<li>
<p>The number of bootstrap samples is suggested to be increased, e.g., B=1000 when the sample size is small, or signals are weak
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Jiming Jiang  Jianyang Zhao  J. Sunil Rao  Thuan Nguyen
</p>


<h3>References</h3>


<ul>
<li>
<p>Jiang J., Rao J.S., Gu Z., Nguyen T. (2008),  Fence Methods for Mixed Model Selection. The Annals of Statistics, 36(4): 1669-1692
</p>
</li>
<li>
<p>Jiang J., Nguyen T., Rao J.S. (2009), A Simplified Adaptive Fence Procedure. Statistics and Probability Letters, 79, 625-629
</p>
</li>
<li>
<p>Thuan Nguyen, Jie Peng, Jiming Jiang (2014), Fence Methods for Backcross Experiments.  Statistical Computation and Simulation, 84(3), 644-662
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">require(fence)
library(snow)
### example 1 ####
data("kidney")
data = kidney[-which.max(kidney$x),]     # Delete a suspicious data point #
data$x2 = data$x^2
data$x3 = data$x^3
data$x4 = data$x^4
data$D = data$sqrt.D.^2
plot(data$y ~ data$x)
full = y~x+x2+x3+x4
# Takes more than 5 seconds to run
# testfh = fence.sae(full, data, B=100, fence="adaptive", method="F-H", D = D)
# testfh$sel_model
# testfh$c
</code></pre>


</div>