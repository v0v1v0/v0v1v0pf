<div class="container">

<table style="width: 100%;"><tr>
<td>create.basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create Basis Set for Functional Data Analysis</h2>

<h3>Description</h3>

<p>Functional data analysis proceeds by selecting a finite basis set and
fitting data to it.  The current <code>fda</code> package supports fitting
via least squares penalized with lambda times the integral over the
(finite) support of the basis set of the squared deviations from a
linear differential operator.
</p>


<h3>Details</h3>

<p>The most commonly used basis in <code>fda</code> is probably B-splines.  For
periodic phenomena, Fourier bases are quite useful.  A constant basis
is provided to facilitation arithmetic with functional data objects.
To restrict attention to solutions of certain differential equations,
it may be useful to use a corresponding basis set such as exponential,
monomial or power basis sets.
</p>
<p>Power bases support the use of negative and fractional powers, while
monomial bases are restricted only to nonnegative integer exponents.
</p>
<p>The polygonal basis is essentially a B-spline of order 2, degree 1.
</p>
<p>The following summarizes arguments used by some or all of the current
<code>create.basis</code> functions:
</p>

<dl>
<dt>rangeval</dt>
<dd>
<p>a vector of length 2 giving the lower and upper limits of the
range of permissible values for the function argument.
</p>
<p>For <code>bspline</code> bases, this can be inferred from
range(breaks).  For <code>polygonal</code> bases, this can be inferred
from range(argvals).  In all other cases, this defaults to 0:1.
</p>
</dd>
<dt>nbasis</dt>
<dd>
<p>an integer giving the number of basis functions.
</p>
<p>This is not used for two of the <code>create.basis</code> functions:
For <code>constant</code> this is 1, so there is no need to specify it.
For <code>polygonal</code> bases, it is length(argvals), and again there
is no need to specify it.
</p>
<p>For <code>bspline</code> bases, if <code>nbasis</code> is not specified, it
defaults to (length(breaks) + norder - 2) if <code>breaks</code> is
provided.  Otherwise, <code>nbasis</code> defaults to 20 for
<code>bspline</code> bases.
</p>
<p>For <code>exponential</code> bases, if <code>nbasis</code> is not specified,
it defaults to length(ratevec) if <code>ratevec</code> is provided.
Otherwise, in <code>fda_2.0.2</code>, <code>ratevec</code> defaults to 1,
which makes <code>nbasis</code> = 1;  in <code>fda_2.0.4</code>,
<code>ratevec</code> will default to 0:1, so <code>nbasis</code> will then
default to 2.
</p>
<p>For <code>monomial</code> and <code>power</code> bases, if <code>nbasis</code> is
not specified, it defaults to length(exponents) if
<code>exponents</code> is provided.  Otherwise, <code>nbasis</code> defaults
to 2 for <code>monomial</code> and <code>power</code> bases.  (Temporary
exception:  In <code>fda_2.0.2</code>, the default <code>nbasis</code> for
<code>power</code> bases is 1.  This will be increased to 2 in
<code>fda_2.0.4</code>.)
</p>
</dd>
</dl>
<p>In addition to <code>rangeval</code> and <code>nbasis</code>, all but
<code>constant</code> bases have one or two parameters unique to that
basis type or shared with one other:
</p>

<dl>
<dt>bspline</dt>
<dd>
<p>Argument <code>norder</code> = the order of the spline, which is one
more than the degree of the polynomials used.  This defaults to
4, which gives cubic splines.
</p>
<p>Argument <code>breaks</code> = the locations of the break or join
points;  also called <code>knots</code>.  This defaults to
seq(rangeval[1], rangeval[2], nbasis-norder+2).
</p>
</dd>
<dt>polygonal</dt>
<dd>
<p>Argument <code>argvals</code> = the locations of the break or join
points;  also called <code>knots</code>.  This defaults to
seq(rangeval[1], rangeval[2], nbasis).
</p>
</dd>
<dt>fourier</dt>
<dd>
<p>Argument <code>period</code> defaults to diff(rangeval).
</p>
</dd>
<dt>exponential</dt>
<dd>
<p>Argument <code>ratevec</code>.  In <code>fda_2.0.2</code>, this defaulted to
1.  In <code>fda_2.0.3</code>, it will default to 0:1.
</p>
</dd>
<dt>monomial, power</dt>
<dd>
<p>Argument <code>exponents</code>.  Default = 0:(nbasis-1).  For
<code>monomial</code> bases, <code>exponents</code> must be distinct
nonnegative integers.  For <code>power</code> bases, they must be
distinct real numbers.
</p>
</dd>
</dl>
<p>Beginning with <code>fda_2.1.0</code>, the last 6 arguments for all the
<code>create.basis</code> functions will be as follows;  some but not all
are available in the previous versions of <code>fda</code>:
</p>

<dl>
<dt>dropind</dt>
<dd>
<p>a vector of integers specifiying the basis functions to be
dropped, if any.
</p>
</dd>
<dt>quadvals</dt>
<dd>
<p>a matrix with two columns and a number of rows equal to the
number of quadrature points for numerical evaluation of the
penalty integral.  The first column of <code>quadvals</code> contains
the quadrature points, and the second column the quadrature
weights.  A minimum of 5 values are required for each inter-knot
interval, and that is often enough.  For Simpson's rule, these
points are equally spaced, and the weights are proportional to
1, 4, 2, 4, ..., 2, 4, 1.
</p>
</dd>
<dt>values</dt>
<dd>
<p>a list of matrices with one row for each row of <code>quadvals</code>
and one column for each basis function.  The elements of the
list correspond to the basis functions and their derivatives
evaluated at the quadrature points contained in the first column
of <code>quadvals</code>.
</p>
</dd>
<dt>basisvalues</dt>
<dd>
<p>A list of lists, allocated by code such as vector("list",1).
This field is designed to avoid evaluation of a basis system
repeatedly at a set of argument values.  Each list within the
vector corresponds to a specific set of argument values, and
must have at least two components, which may be tagged as you
wish.  'The first component in an element of the list vector
contains the argument values.  The second component in an
element of the list vector contains a matrix of values of the
basis functions evaluated at the arguments in the first
component.  The third and subsequent components, if present,
contain matrices of values their derivatives up to a maximum
derivative order.  Whenever function getbasismatrix is called,
it checks the first list in each row to see, first, if the
number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time
can be avoided by direct retrieval of the desired array.  For
example, you might set up a vector of argument values called
"evalargs" along with a matrix of basis function values for
these argument values called "basismat".  You might want too use
tags like "args" and "values", respectively for these.  You
would then assign them to <code>basisvalues</code> with code such as
the following:
</p>
<p>basisobj$basisvalues &lt;- vector("list",1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat)
</p>
</dd>
<dt>names</dt>
<dd>
<p>either a character vector of the same length as the number of
basis functions or a simple stem used to construct such a
vector.
</p>
<p>For <code>bspline</code> bases, this defaults to paste('bspl', norder,
'.', 1:nbreaks, sep=‚Äù).
</p>
<p>For other bases, there are crudely similar defaults.
</p>
</dd>
<dt>axes</dt>
<dd>
<p>an optional list used by selected <code>plot</code> functions to
create custom <code>axes</code>.  If this <code>axes</code> argument is not
NULL, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>,
and <code>plot.Lfd</code> will create axes via
<code>do.call(x$axes[[1]], x$axes[-1])</code>.  The primary example of
this is to create <code>CanadianWeather</code> plots using
<code>list("axesIntervals")</code>
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>J. O. Ramsay and Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>create.bspline.basis</code>
<code>create.constant.basis</code>
<code>create.exponential.basis</code>
<code>create.fourier.basis</code>
<code>create.monomial.basis</code>
<code>create.polygonal.basis</code>
<code>create.power.basis</code>
</p>


</div>