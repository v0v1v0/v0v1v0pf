<div class="container">

<table style="width: 100%;"><tr>
<td>convergence-checker</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convergence Monitoring</h2>

<h3>Description</h3>

<p>Built-in set of functions to be used in companion with the argument
<code>conv_checker</code> in MCMC. These functions are not intended to be used
in a context other than the <code>MCMC</code> function.
</p>
<p>The object <code>LAST_CONV_CHECK</code> is an environment that holds
information regarding the convergence checker used. This information can be
updated every time that the <code>conv_checker</code> function is called by <code>MCMC</code> using
the functions <code>convergence_data_set</code> and <code>convergence_msg_set</code>. The function
<code>convergence_data_get</code> is just a wrapper of <code>get()</code>.
</p>
<p>The <code>msg</code> member of <code>LAST_CONV_CHECK</code> is resetted before <code>conv_checker</code> is
called.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LAST_CONV_CHECK

convergence_data_set(x)

convergence_data_get(x)

convergence_msg_set(msg = NA_character_)

convergence_msg_get()

convergence_gelman(freq = 1000L, threshold = 1.1, check_invariant = TRUE, ...)

convergence_geweke(
  freq = 1000L,
  threshold = 0.025,
  check_invariant = TRUE,
  ...
)

convergence_heildel(freq = 1000L, ..., check_invariant = TRUE)

convergence_auto(freq = 1000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>In the case of <code>convergence_data_set</code>, a named list. For
<code>convergence_data_get</code>, a character vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>msg</code></td>
<td>
<p>Character scalar. Personalized message to print.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>Integer scalar. Frequency of checking.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>Numeric value. A Gelman statistic below the threshold
will return <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_invariant</code></td>
<td>
<p>Logical. When <code>TRUE</code> the function only computes
the Gelman diagnostic using variables with greater than <code>1e-10</code> variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td>
</tr>
</table>
<h3>Format</h3>

<p>An object of class <code>fmcmc_output_conv_check</code> (inherits from <code>environment</code>) of length 1.
</p>


<h3>Details</h3>

<p><code>convergence_gelman</code> is a wrapper of <code>coda::gelman.diag()</code>.
</p>
<p>In the case of <code>convergence_geweke</code>, <code>threshold</code> sets the p-value
for the null <code class="reqn">H_0: Z = 0</code>, i.e. equal means between the first and last
chunks of the chain. See coda::geweke.diag. This implies that the higher
the threshold, the lower the probability of stopping the chain.
</p>
<p>In the case that the chain has more than one parameter, the algorithm will
return true if and only if the test fails to reject the null for all the
parameters.
</p>
<p>For the <code>convergence_heildel</code>, see coda::heidel.diag for details.
</p>
<p>The <code>convergence_auto</code> function is the default and is just a wrapper
for <code>convergence_gelman</code> and <code>convergence_geweke</code>. This function returns a
convergence checker that will be either of the other two depending on whether
<code>nchains</code> in <code>MCMC</code> is greater than one–in which case it will use the Gelman
test–or not–in which case it will use the Geweke test.
</p>


<h3>Value</h3>

<p>A function passed to MCMC to check automatic convergence.
</p>


<h3>Building a convergence checker</h3>

<p>Convergence checkers are simply a function that receives as argument a matrix
(or list of them) with sampled values, and returns a logical scalar with the
value <code>TRUE</code> if the chain converged. An example of a personalized convergence
checker is provided below. The frequency with which the check is performed is
retrieved from the attribute <code>"freq"</code> from the convergence checker function,
i.e., <code>attr(..., "freq")</code>. If missing, convergence will be checked halfway
the number of steps in the chain, i.e., <code>floor(nsteps/2)</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1: Presonalized conv checker --------------------------------------
# Dummy rule, if acceptance rate is near between .2 and .3.
convergence_example &lt;- function(x) {
  arate &lt;- 1 - coda::rejectionRate(x)
  all(
    abs(arate - .25) &lt; .05
  )
}

# Tell fmcmc::MCMC what is the frequency
attr(convergence_example, "freq") &lt;- 2e3

set.seed(223)
x &lt;- rnorm(1000)
y &lt;- x * 2 + rnorm(1000)
logpost &lt;- function(p) {
  sum(dnorm(y, mean = x * p, log = TRUE))
}

ans &lt;- MCMC(
  initial = 0, fun = logpost, nsteps = 5e4,
  kernel= kernel_ram(),
  conv_checker = convergence_example
)

# Example 2: Adding information ---------------------------------------------
# Here we do two things: Save a value and set a message for the user
convergence_example_with_info &lt;- structure(function(x) {
  arate &lt;- 1 - coda::rejectionRate(x)
  
  # Saving a value
  if (!exists("arates", envir = LAST_CONV_CHECK, inherits = FALSE)) {
    convergence_data_set(list(arates = arate))
  } else {
    convergence_data_set(list(
      arates = rbind(convergence_data_get("arates"), arate)
    ))
  }
  
  # Setting up the message
  convergence_msg_set(
    sprintf("Current Avg. Accept. Rate: %.2f", mean(arate))
  )
  
  all(
    abs(arate - .25) &lt; .05
  )
}, freq = 2000)


ans &lt;- MCMC(
  initial = 0, fun = logpost, nsteps = 5e4,
  kernel= kernel_ram(),
  conv_checker = convergence_example_with_info,
  seed = 112,
  progress = FALSE
)
</code></pre>


</div>