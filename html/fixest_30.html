<div class="container">

<table style="width: 100%;"><tr>
<td>degrees_freedom</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Gets the degrees of freedom of a <code>fixest</code> estimation</h2>

<h3>Description</h3>

<p>Simple utility to extract the degrees of freedom from a <code>fixest</code> estimation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">degrees_freedom(
  x,
  type,
  vars = NULL,
  vcov = NULL,
  se = NULL,
  cluster = NULL,
  ssc = NULL,
  stage = 2
)

degrees_freedom_iid(x, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>fixest</code> estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Character scalar, equal to "k", "resid", "t". If "k", then the number of
regressors is returned. If "resid", then it is the "residuals degree of freedom", i.e.
the number of observations minus the number of regressors. If "t", it is the degrees of
freedom used in the t-test. Note that these values are affected by how the VCOV of <code>x</code>
is computed, in particular when the VCOV is clustered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>A vector of variable names, of the regressors. This is optional. If provided,
then <code>type</code> is set to 1 by default and the number of regressors contained in <code>vars</code>
is returned. This is only useful in the presence of collinearity and we want a subset of
the regressors only. (Mostly for internal use.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcov</code></td>
<td>
<p>Versatile argument to specify the VCOV. In general, it is either a character
scalar equal to a VCOV type, either a formula of the form: <code>vcov_type ~ variables</code>. The
VCOV types implemented are: "iid", "hetero" (or "HC1"), "cluster", "twoway",
"NW" (or "newey_west"), "DK" (or "driscoll_kraay"), and "conley". It also accepts
object from <code>vcov_cluster</code>, <code>vcov_NW</code>, <code>NW</code>,
<code>vcov_DK</code>, <code>DK</code>, <code>vcov_conley</code> and
<code>conley</code>. It also accepts covariance matrices computed externally.
Finally it accepts functions to compute the covariances. See the <code>vcov</code> documentation
in the <a href="https://lrberge.github.io/fixest/articles/fixest_walkthrough.html#the-vcov-argument-1">vignette</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Character scalar. Which kind of standard error should be computed:
“standard”, “hetero”, “cluster”, “twoway”, “threeway”
or “fourway”? By default if there are clusters in the estimation:
<code>se = "cluster"</code>, otherwise <code>se = "iid"</code>. Note that this argument is deprecated,
you should use <code>vcov</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Tells how to cluster the standard-errors (if clustering is requested).
Can be either a list of vectors, a character vector of variable names, a formula or
an integer vector. Assume we want to perform 2-way clustering over <code>var1</code> and <code>var2</code>
contained in the data.frame <code>base</code> used for the estimation. All the following
<code>cluster</code> arguments are valid and do the same thing:
<code>cluster = base[, c("var1", "var2")]</code>, <code>cluster = c("var1", "var2")</code>, <code>cluster = ~var1+var2</code>.
If the two variables were used as fixed-effects in the estimation, you can leave it
blank with <code>vcov = "twoway"</code> (assuming <code>var1</code> [resp. <code>var2</code>] was
the 1st [resp. 2nd] fixed-effect). You can interact two variables using <code>^</code> with
the following syntax: <code>cluster = ~var1^var2</code> or <code>cluster = "var1^var2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object of class <code>ssc.type</code> obtained with the function <code>ssc</code>. Represents
how the degree of freedom correction should be done.You must use the function <code>ssc</code>
for this argument. The arguments and defaults of the function <code>ssc</code> are:
<code>adj = TRUE</code>, <code>fixef.K="nested"</code>, <code>cluster.adj = TRUE</code>, <code>cluster.df = "min"</code>,
<code>t.df = "min"</code>, <code style="white-space: pre;">⁠fixef.force_exact=FALSE)⁠</code>. See the help of the function <code>ssc</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stage</code></td>
<td>
<p>Either 1 or 2. Only concerns IV regressions, which stage to look at.
</p>
<p>The type of VCOV can have an influence on the degrees of freedom. In particular, when the
VCOV is clustered, the DoF returned will be in accordance with the way the small
sample correction was performed when computing the VCOV. That type of value is in general
not what we have in mind when we think of "degrees of freedom". To obtain the ones that are
more intuitive, please use <code>degrees_freedom_iid</code> instead.</p>
</td>
</tr>
</table>
<h3>Functions</h3>


<ul><li> <p><code>degrees_freedom_iid()</code>: Gets the degrees of freedom of a <code>fixest</code> estimation
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">
# First: an estimation

base = iris
names(base) = c("y", "x1", "x2", "x3", "species")
est = feols(y ~ x1 + x2 | species, base)

# "Normal" standard-errors (SE)
est_standard = summary(est, se = "st")

# Clustered SEs
est_clustered = summary(est, se = "clu")

# The different degrees of freedom

# =&gt; different type 1 DoF (because of the clustering)
degrees_freedom(est_standard, type = "k")
degrees_freedom(est_clustered, type = "k") # fixed-effects are excluded

# =&gt; different type 2 DoF (because of the clustering)
degrees_freedom(est_standard, type = "resid") # =&gt; equivalent to the df.residual from lm
degrees_freedom(est_clustered, type = "resid")



</code></pre>


</div>