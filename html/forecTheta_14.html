<div class="container">

<table style="width: 100%;"><tr>
<td>Theta Models</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Theta Models

</h2>

<h3>Description</h3>


<p>Functions for forecast univariate time series using the Dynamic Optimised Theta Model, Dynamic Standard Theta Model,
Optimised Theta Model and Standard Theta Model (Fiorucci et al, 2016).
We also provide an implementation for the Standard Theta Method (STheta) of Assimakopoulos and Nikolopoulos (2000).
</p>


<h3>Usage</h3>

<pre><code class="language-R">	dotm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5, 2),
	estimation=TRUE, lower=c(-1e+10, 0.1, 1.0), upper=c(1e+10, 0.99, 1e+10),
	opt.method="Nelder-Mead", xreg=NULL)

	dstm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5), estimation=TRUE,
	lower=c(-1e+10, 0.1), upper=c(1e+10, 0.99), opt.method="Nelder-Mead", xreg=NULL)

	otm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5, 2),
	estimation=TRUE, lower=c(-1e+10, 0.1, 1.0), upper=c(1e+10, 0.99, 1e+10),
	opt.method="Nelder-Mead", xreg=NULL)

	stm(y, h=5, level=c(80,90,95), s=NULL, par_ini=c(y[1]/2, 0.5), estimation=TRUE,
	lower=c(-1e+10, 0.1), upper=c(1e+10, 0.99), opt.method="Nelder-Mead", xreg=NULL)

	stheta(y, h=5, s=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Object of time series class.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>Number of required forecasting periods.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>

<p>Levels for prediction intervals.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>

<p>If <code>TRUE</code>, the multiplicative seasonal decomposition is used.
If <code>NULL</code> and <code>frequency(y)&gt;=4</code> the time series is tested for statistically seasonal behaviour, with 90% of significance.
If s='additive' or close zero values been find in the multiplicative decomposition, the additive decomposition is performed hatter than multiplicative.
Default is NULL.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par_ini</code></td>
<td>

<p>Vector of initialization for <code>(ell, alpha, theta)</code> parameters.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimation</code></td>
<td>

<p>If <code>TRUE</code>, the <code>optim()</code> function is consider for compute the minimum square estimator of parameters.
If <code>FALSE</code>, the models/methods are computed for <code>par_ini</code> values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>

<p>The lower limit of parametric space.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>

<p>The upper limit of parametric space.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.method</code></td>
<td>

<p>The numeric optimisation method for <code>optim()</code> function.
Choose one among <code>'Nelder-Mead', 'L-BFGS-B', 'SANN'</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xreg</code></td>
<td>

<p>A matrix with the regressor variables including the out-of-sample data.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>By default (<code>s=NULL</code>), the 90% significance seasonal Z-test, used by Assimakopoulos and Nikolopoulos (2000), is applied for quarterly and monthly time series.
</p>
<p>For details of each model see Fiorucci et al, 2016.
If you are looking for the methods presented in the arXiv paper (Fiorucci et al, 2015), see <code>otm.arxiv()</code> function.
</p>


<h3>Value</h3>

<p>An object of <code>thetaModel</code> class with one list containing the elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>$method</code></td>
<td>
<p>The name of the model/method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$y </code></td>
<td>
<p>The original time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$s</code></td>
<td>
<p>A binary indication for seasonal decomposition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Classical seasonal decomposition type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.method</code></td>
<td>
<p>The optimisation method used in the <code>optim()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$par </code></td>
<td>
<p>The estimated values for <code>(ell, alpha, theta)</code> parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$weights </code></td>
<td>
<p>The estimated weights values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$fitted </code></td>
<td>
<p>A time series element with the fitted points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$residuals </code></td>
<td>
<p>A time series element with the residual points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$mean</code></td>
<td>
<p>The forecasting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$level</code></td>
<td>
<p>The levels for prediction intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$lower</code></td>
<td>
<p>Lower limits for prediction intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$upper</code></td>
<td>
<p>Upper limits for prediction intervals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$tests</code></td>
<td>
<p>The p.value of Teraesvirta Neural Network test applied on unseasoned time series and the p.value of Shapiro-Wilk test applied on unseasoned residuals.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci, Francisco Louzada
</p>


<h3>References</h3>

<p>Fiorucci J.A., Pellegrini T.R., Louzada F., Petropoulos F., Koehler, A. (2016). <em>Models for optimising the theta method and their relationship to state space models</em>,	International Journal of Forecasting, 32 (4), 1151–1161, &lt;doi:10.1016/j.ijforecast.2016.02.005&gt;.
</p>
<p>Assimakopoulos, V. and Nikolopoulos k. (2000). <em>The theta model: a decomposition approach to forecasting</em>. International Journal of Forecasting 16, 4, 521–530, &lt;doi:10.1016/S0169-2070(00)00066-2&gt;.
</p>


<h3>See Also</h3>

<p><code>forecTheta-package</code>, <code>otm.arxiv</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
y1 = 2+ 0.15*(1:20) + rnorm(20)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30)
y =  as.ts(c(y1,y2))
out &lt;- dotm(y, h=10)
summary(out)
plot(out)

#### additive seasonal decomposition ###
x = sin(2*pi*seq(0,9,len=300)) + exp((1:300)/150) + rnorm(mean=0,sd=0.5,n=300)
y = ts(x, frequency=33)
out &lt;- dotm(y, h=50, s='additive')
summary(out)
plot(out)

# #########################################################
# ######### Reproducing the M3 results by DOTM ############
# #########################################################
#
# library(Mcomp)
# data(M3)
#
# forec = matrix(NA, nrow=3003, ncol=18)
# obs = matrix(NA, nrow=3003, ncol=18) #matrix of the out-sample values
# meanDiff &lt;- rep(1, 3003)
#
# for(i in 1:3003){
#   x=M3[[i]]$x
#   h=M3[[i]]$h
#   out = dotm(x,h,level=NULL)
#   forec[i,1:h] = out$mean
#   obs[i,1:h] = M3[[i]]$xx
#   meanDiff[i] = mean(abs(diff(x, lag = frequency(x))))
# }
#
# ############## sMAPE ###################
# sAPE_matrix = errorMetric(obs=obs, forec=forec, type="sAPE", statistic="N")
# #### Yearly ###
# mean( sAPE_matrix[1:645, 1:6] )
# #### QUARTERLY ###
# mean( sAPE_matrix[646:1401, 1:8] )
# #### MONTHLY ###
# mean( sAPE_matrix[1402:2829, 1:18] )
# #### Other ###
# mean( sAPE_matrix[2830:3003, 1:8] )
# #### ALL ###
# mean( sAPE_matrix, na.rm=TRUE )
# #
# ############# MASE ######################
# AE_matrix = errorMetric(obs=obs, forec=forec, type="AE", statistic="N")
# ASE_matrix=AE_matrix/meanDiff
# #### Yearly ###
# mean( ASE_matrix[1:645, 1:6] )
# #### QUARTERLY ###
# mean( ASE_matrix[646:1401, 1:8] )
# #### MONTHLY ###
# mean( ASE_matrix[1402:2829, 1:18] )
# #### Other ###
# mean( ASE_matrix[2830:3003, 1:8] )
# #### ALL ###
# mean( ASE_matrix, na.rm=TRUE )
# ########################################################


</code></pre>


</div>