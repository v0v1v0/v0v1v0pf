<div class="container">

<table style="width: 100%;"><tr>
<td>depth.mfdata</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Provides the depth measure for a list of p–functional data objects</h2>

<h3>Description</h3>

<p>This function computes the depth measure for a list of p–functional data
objects.  The procedure extends the Fraiman and Muniz (FM), modal, and
random project depth functions from 1 functional dataset to p functional
datasets.
</p>


<h3>Usage</h3>

<pre><code class="language-R">depth.modep(
  mfdata,
  mfdataref = mfdata,
  h = NULL,
  metric,
  par.metric = list(),
  method = "euclidean",
  scale = FALSE,
  trim = 0.25,
  draw = FALSE,
  ask = FALSE
)

depth.RPp(
  mfdata,
  mfdataref = mfdata,
  nproj = 50,
  proj = "vexponential",
  trim = 0.25,
  dfunc = "mdepth.TD",
  par.dfunc = list(scale = TRUE),
  draw = FALSE,
  ask = FALSE
)

depth.FMp(
  mfdata,
  mfdataref = mfdata,
  trim = 0.25,
  dfunc = "mdepth.MhD",
  par.dfunc = list(scale = FALSE),
  draw = FALSE,
  ask = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mfdata</code></td>
<td>
<p>A list of new curves (list of fdata ojects) to evaluate the
depth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mfdataref</code></td>
<td>
<p>A set of reference curves (list of fdata ojects) w.r.t. the
depth of mfdata is computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Bandwidth, <code>h&gt;0</code>. Default argument values are provided as the
15%–quantile of the distance between <code>fdataobj</code> and <code>fdataori</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>Metric or semi–metric function used for compute the distance
between each element in <code>ldata</code> w.r.t. <code>ldataref</code>, by default
<code>metric.lp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.metric</code></td>
<td>
<p>list of parameters for the metric function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Type of the distance measure (by default <code>euclidean</code>) to
compute the metric between the p-distance matrix computed from the p
functional data elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>=TRUE, scale the depth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim</code></td>
<td>
<p>The alpha of the trimming.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draw</code></td>
<td>
<p>=TRUE, draw the curves, the sample median and trimmed mean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ask</code></td>
<td>
<p>logical. If <code>TRUE</code> (and the R session is interactive) the
user is asked for input, before a new figure is drawn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nproj</code></td>
<td>
<p>The number projection.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proj</code></td>
<td>
<p>if is a character: create the random projection using a
covariance matrix by process indicated in the argument (by default, proj=1,
sigma=diag(ncol(fdataobj))), else if is a matrix of random projection
provided by the user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfunc</code></td>
<td>
<p>Type of multivariate depth (of order p) function used in
Framiman and Muniz depth, <code>depth.FMp</code> or in Random Projection
depth,<code>depth.FMp</code>: : </p>
 <ul>
<li>
<p> The <code>mdepth.SD</code>
function provides the simplicial depth measure for bivariate data.  </p>
</li>
<li>
<p>The <code>mdepth.LD</code> function provides the Likelihood depth measure
based on Nadaraya–Watson estimator of empirical density function.  </p>
</li>
<li>
<p>The <code>mdepth.HS</code> function implements a half-space depth measure
based on random projections.  </p>
</li>
<li>
<p> The <code>mdepth.TD</code> function
implements a Tukey depth measure.  </p>
</li>
<li>
<p> The
<code>mdepth.MhD</code>function implements a Mahalanobis depth measure.
</p>
</li>
<li>
<p> The <code>mdepth.RP</code> function provides the depth measure using
random projections for multivariate data.  </p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.dfunc</code></td>
<td>
<p>list of parameters for the <code>dfunc</code> depth function, see
<code>Depth.Multivariate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

 
<ul>
<li> <p><code>depth.FMp</code>, this procedure suposes that each
curve of the mfdataobj have the same support [0,T] (same argvals and
rangeval).  The FMp depth is defined as: <code class="reqn">FM_i^p
=\int_{0}^{T}Z_i^p(t)dt</code> where
<code class="reqn">Z_i^p(t)</code> is a <code class="reqn">p</code>–variate depth of the vector
<code class="reqn">(x_i^1(t),\ldots,x_i^p(t))</code> w.r.t. the sample
at <code class="reqn">t</code>. 
derivatives. In this case,note solo un dato funcional se reduce
depth.FM=depth.FM1 
</p>
</li>
<li>
<p> The <code>depth.RPp</code> function calculates the depth in two
steps. It builds random projections for the each curve of the <code>mfdata</code>
w.r.t. each curve of the <code>mfdataref</code> object. Then it applyes a
multivariate depth function specified in <code>dfunc</code> argument to the set of
random projections.  This procedure is a generalization of Random Projection
with derivatives (RPD) implemented in <code>depth.RPD</code> function.
Now, the procedure computes a p-variate depth with the projections using the
<code class="reqn">p</code> functional dataset.
</p>
</li>
<li>
<p> The modal depth <code>depth.modep</code> function calculates the
depth in three steps.  First, the function calculates a suitable metrics or
semi–metrics <code class="reqn">m_1+\cdots+m_p</code> for each curve of the
<code>mfdata</code> w.r.t. each curve in the <code>mfdataref</code> object using the
<code>metric</code> and <code>par.metric</code> arguments, see <code>metric.lp</code>
or <code>semimetric.NPFDA</code> for more details.  Second, the function
uses the <code class="reqn">p</code>–dimensional metrics to construct a new metric, specified
in <code>method</code> argument, by default if <code>method="euclidean"</code>, i.e.
<code class="reqn">m:=\sqrt{m_1^2+\cdots+m_p^2}</code>. Finally, the
empirical <em>h</em>–depth is computed as:
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}_h(x_0)=N^{-1}\sum_{i=1}^{N}{K(m/h)}</code>
</p>
<p> where <code class="reqn">x</code> is dataset with p observed fucntional data, <code class="reqn">m</code> is
a suitable metric or semi–metric, <code class="reqn">K(t)</code> is an asymmetric kernel
function and <code>h</code> is the bandwidth parameter. 
</p>
</li>
</ul>
<h3>Value</h3>


<ul>
<li> <p>lmed Index deepest element <code>median</code>. 
</p>
</li>
<li> <p>ltrim Index of curves with trimmed mean <code>mtrim</code>.
</p>
</li>
<li> <p>dep  Depth of each curve of fdataobj w.r.t. fdataori. 
</p>
</li>
<li> <p>dfunc  second depth function used as multivariate depth, see details section. 
</p>
</li>
<li> <p>par.dfunc list of parameters for the dfunc depth function. 
</p>
</li>
<li> <p>proj  The projection value of each point on the curves. 
</p>
</li>
<li> <p>dist  Distance matrix between curves or functional data.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Manuel Febrero-Bande, Manuel Oviedo de la Fuente
<a href="mailto:manuel.oviedo@udc.es">manuel.oviedo@udc.es</a>
</p>


<h3>References</h3>

<p>Cuevas, A., Febrero-Bande, M. and Fraiman, R. (2007).
<em>Robust estimation and classification for functional data via
projection-based depth notions.</em> Computational Statistics 22, 3, 481-496.

10: 419-440. 
<em>Statistical Computing in Functional Data Analysis: The R Package
fda.usc.</em>Journal of Statistical Software, 51(4), 1-28.
<a href="https://www.jstatsoft.org/v51/i04/">https://www.jstatsoft.org/v51/i04/</a>
</p>


<h3>See Also</h3>

<p>See Also as <code>Descriptive</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(tecator)
xx&lt;-tecator$absorp
xx1&lt;-fdata.deriv(xx,1)
lx&lt;-list(xx=xx,xx=xx1)
# Fraiman-Muniz Depth
par.df&lt;-list(scale =TRUE)
out.FM1p=depth.FMp(lx,trim=0.1,draw=TRUE, par.dfunc = par.df)
out.FM2p=depth.FMp(lx,trim=0.1,dfunc="mdepth.LD",
par.dfunc = par.df, draw=TRUE)

# Random Project Depth
out.RP1p=depth.RPp(lx,trim=0.1,dfunc="mdepth.TD",
draw=TRUE,par.dfunc = par.df)
out.RP2p=depth.RPp(lx,trim=0.1,dfunc="mdepth.LD",
draw=TRUE,par.dfunc = par.df)

#Modal Depth
out.mode1p=depth.modep(lx,trim=0.1,draw=T,scale=T)
out.mode2p=depth.modep(lx,trim=0.1,method="manhattan",
draw=T,scale=T)

par(mfrow=c(2,3))
plot(out.FM1p$dep,out.FM2p$dep)
plot(out.RP1p$dep,out.RP2p$dep)
plot(out.mode1p$dep,out.mode2p$dep)
plot(out.FM1p$dep,out.RP1p$dep)
plot(out.RP1p$dep,out.mode1p$dep)
plot(out.FM1p$dep,out.mode1p$dep)

## End(Not run)

</code></pre>


</div>