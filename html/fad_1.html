<div class="container">

<table style="width: 100%;"><tr>
<td>fad</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Factor Analysis for data (high or low dimensional).</h2>

<h3>Description</h3>

<p>Perform fast matrix-free maximum-likelihood factor analysis on a
covariance matrix or data matrix, works if number of variables is more than
number of observations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fad(
  x,
  factors,
  data = NULL,
  covmat = NULL,
  n.obs = NA,
  subset,
  na.action,
  start = NULL,
  scores = c("none", "regression", "Bartlett"),
  rotation = "varimax",
  control = NULL,
  lower = 0.005,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A formula or a numeric matrix or an object that can be coerced to a
numeric matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>The number of factors to be fitted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional data frame (or similar: see <code>model.frame</code>),
used only if <code>x</code> is a formula.  By default the variables are taken
from <code>environment(formula)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covmat</code></td>
<td>
<p>A covariance matrix, or a covariance list as returned by
<code>cov.wt</code>. Of course, correlation matrices are covariance
matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.obs</code></td>
<td>
<p>The number of observations, used if <code>covmat</code> is a
covariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>A specification of the cases to be used, if <code>x</code> is used as
a matrix or formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>The <code>na.action</code> to be used if <code>x</code> is used as a
formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p><code>NULL</code> or a matrix of starting values, each column giving
an initial set of uniquenesses.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>Type of scores to produce, if any.  The default is none,
<code>"regression"</code> gives Thompson's scores, <code>"Bartlett"</code> given
Bartlett's weighted least-squares scores. Partial matching allows these
names to be abbreviated. Also note that some of the scores-types are not
applicable when <code>p &gt; n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotation</code></td>
<td>
<p>character. <code>"none"</code> or the name of a function to be used
to rotate the factors: it will be called with first argument the loadings
matrix, and should return a list with component <code>loadings</code> giving the
rotated loadings, or just the rotated loadings. The options included in the package are:
<code>varimax</code>, <code>promax</code>, <code>quartimax</code>, <code>equamax</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list of control values:
</p>

<dl>
<dt>nstart</dt>
<dd>
<p>The number of starting values to be tried if <code>start = NULL</code>. Default 1.</p>
</dd>
<dt>trace</dt>
<dd>
<p>logical. Output tracing information? Default <code>FALSE</code>.</p>
</dd>
<dt>opt</dt>
<dd>
<p>A list of control values to be passed to <code>optim</code>'s
<code>control</code> argument.</p>
</dd>
<dt>rotate</dt>
<dd>
<p>a list of additional arguments for the rotation function.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>The lower bound for uniquenesses during optimization. Should be &gt; 0. Default 0.005.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Components of <code>control</code> can also be supplied as named arguments to <code>fad</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>"fad"</code> with components
</p>
<table>
<tr style="vertical-align: top;">
<td><code>loadings</code></td>
<td>
<p>A matrix of loadings on the correlation scale, one column for each factor.  The
factors are ordered in decreasing order of sums of squares of
loadings, and given the sign that will make the sum of the loadings
positive.  This is of class <code>"loadings"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uniquenesses</code></td>
<td>
<p>The uniquenesses computed on the correlation scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>The estimated standard deviations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criteria</code></td>
<td>
<p>The results of the optimization: the value of the
criterion (a linear function of the negative log-likelihood) and information
on the iterations used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>factors</code></td>
<td>
<p>The argument <code>factors</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dof</code></td>
<td>
<p>The number of degrees of freedom of the factor analysis model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method: always <code>"mle"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rotmat</code></td>
<td>
<p>The rotation matrix if relevant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>If requested, a matrix of scores.  <code>napredict</code> is
applied to handle the treatment of values omitted by the <code>na.action</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.obs</code></td>
<td>
<p>The number of observations if available, or <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The matched call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.action</code></td>
<td>
<p>If relevant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik, BIC</code></td>
<td>
<p>The maximum log-likelihood and the Bayesian Information Criteria.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>factanal</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1234)

## Simulate a 200 x 3 loadings matrix ~i.i.d N(0,1)
L &lt;- matrix(rnorm(200*3),200,3) 

## Simulate the uniquenesses i.i.d U(0.2,0.9)
D &lt;- runif(200,0.2,0.9) 

## Generate a data matrix of size 50 x 200 with rows
## ~i.i.d. N(0,LL'+diag(D))
X &lt;- tcrossprod(matrix(rnorm(50*3),50,3),L) + matrix(rnorm(50*200),50,200) %*% diag(sqrt(D))

## Fit a factor model with 3 factors:
fit = fad(X,3)


## Print the loadings:
print(fit$loadings)

</code></pre>


</div>