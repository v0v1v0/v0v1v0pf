<div class="container">

<table style="width: 100%;"><tr>
<td>running_sum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute sums or means over a sliding window.</h2>

<h3>Description</h3>

<p>Compute the mean or sum over 
an infinite or finite sliding window, returning a vector the same size as the input.
</p>


<h3>Usage</h3>

<pre><code class="language-R">running_sum(v, window = NULL, wts = NULL, na_rm = FALSE,
  restart_period = 10000L, check_wts = FALSE)

running_mean(v, window = NULL, wts = NULL, na_rm = FALSE, min_df = 0L,
  restart_period = 10000L, check_wts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>a vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>the window size. if given as finite integer or double, passed through.
If <code>NULL</code>, <code>NA_integer_</code>, <code>NA_real_</code> or <code>Inf</code> are given, equivalent
to an infinite window size. If negative, an error will be thrown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wts</code></td>
<td>
<p>an optional vector of weights. Weights are ‘replication’
weights, meaning a value of 2 is shorthand for having two observations
with the corresponding <code>v</code> value. If <code>NULL</code>, corresponds to
equal unit weights, the default. Note that weights are typically only meaningfully defined
up to a multiplicative constant, meaning the units of weights are
immaterial, with the exception that methods which check for minimum df will,
in the weighted case, check against the sum of weights. For this reason,
weights less than 1 could cause <code>NA</code> to be returned unexpectedly due
to the minimum condition. When weights are <code>NA</code>, the same rules for checking <code>v</code>
are applied. That is, the observation will not contribute to the moment
if the weight is <code>NA</code> when <code>na_rm</code> is true. When there is no
checking, an <code>NA</code> value will cause the output to be <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>whether to remove NA, false by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>restart_period</code></td>
<td>
<p>the recompute period. because subtraction of elements can cause
loss of precision, the computation of moments is restarted periodically based on 
this parameter. Larger values mean fewer restarts and faster, though potentially less 
accurate results. Unlike in the computation of even order moments, loss of precision
is unlikely to be disastrous, so the default value is rather large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_wts</code></td>
<td>
<p>a boolean for whether the code shall check for negative
weights, and throw an error when they are found. Default false for speed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_df</code></td>
<td>
<p>the minimum df to return a value, otherwise <code>NaN</code> is returned,
only for the means computation.
This can be used to prevent moments from being computed on too few observations.
Defaults to zero, meaning no restriction.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the mean or sum of the elements, using a Kahan's Compensated Summation Algorithm,
a numerically robust one-pass method.
</p>
<p>Given the length <code class="reqn">n</code> vector <code class="reqn">x</code>, we output matrix <code class="reqn">M</code> where
<code class="reqn">M_{i,1}</code> is the sum or mean 
of <code class="reqn">x_{i-window+1},x_{i-window+2},...,x_{i}</code>.
Barring <code>NA</code> or <code>NaN</code>, this is over a window of size <code>window</code>.
During the 'burn-in' phase, we take fewer elements. If fewer than <code>min_df</code> for
<code>running_mean</code>, returns <code>NA</code>.
</p>


<h3>Value</h3>

<p>A vector the same size as the input.
</p>


<h3>Note</h3>

<p>The moment computations provided by fromo are 
numerically robust, but will often <em>not</em> provide the
same results as the 'standard' implementations,
due to differences in roundoff. We make every attempt to balance
speed and robustness. User assumes all risk from using
the fromo package.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Terriberry, T. "Computing Higher-Order Moments Online."
<a href="http://people.xiph.org/~tterribe/notes/homs.html">http://people.xiph.org/~tterribe/notes/homs.html</a>
</p>
<p>J. Bennett, et. al., "Numerically Stable, Single-Pass, 
Parallel Statistics Algorithms," Proceedings of IEEE
International Conference on Cluster Computing, 2009.
<a href="https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265">https://www.semanticscholar.org/paper/Numerically-stable-single-pass-parallel-statistics-Bennett-Grout/a83ed72a5ba86622d5eb6395299b46d51c901265</a>
</p>
<p>Cook, J. D. "Accurately computing running variance."
<a href="http://www.johndcook.com/standard_deviation.html">http://www.johndcook.com/standard_deviation.html</a>
</p>
<p>Cook, J. D. "Comparing three methods of computing 
standard deviation."
<a href="http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation">http://www.johndcook.com/blog/2008/09/26/comparing-three-methods-of-computing-standard-deviation</a>
</p>
<p>Kahan, W. "Further remarks on reducing truncation errors,"
Communications of the ACM, 8 (1), 1965.
<a href="https://doi.org/10.1145/363707.363723">https://doi.org/10.1145/363707.363723</a>
</p>
<p>Wikipedia contributors "Kahan summation algorithm," 
Wikipedia, The Free Encyclopedia, 
<a href="https://en.wikipedia.org/w/index.php?title=Kahan_summation_algorithm&amp;oldid=777164752">https://en.wikipedia.org/w/index.php?title=Kahan_summation_algorithm&amp;oldid=777164752</a>
(accessed May 31, 2017).
</p>


<h3>Examples</h3>

<pre><code class="language-R">x &lt;- rnorm(1e5)
xs &lt;- running_sum(x,10)
xm &lt;- running_mean(x,100)

</code></pre>


</div>