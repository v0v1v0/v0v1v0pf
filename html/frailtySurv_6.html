<div class="container">

<table style="width: 100%;"><tr>
<td>genfrail</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generate survival data
</h2>

<h3>Description</h3>

<p>Generate clustered survival data from a shared frailty model, with hazard function given by
</p>
<p style="text-align: center;"><code class="reqn">S(t)=\exp [-\Lambda_0(t) \omega_i \exp (\beta Z_{ij})]</code>
</p>

<p>where <code class="reqn">\Lambda_0</code> is the cumulative baseline hazard, <code class="reqn">\omega_i</code> is the frailty value of cluster <code class="reqn">i</code>, <code class="reqn">\beta</code> is the regression coefficient vector, and <code class="reqn">Z_ij</code> is the covariate vector for individual <code class="reqn">i</code> in cluster <code class="reqn">j</code>.
</p>
<p>The baseline hazard can be specified by the inverse cumualative baseline hazard, cumulative baseline hazard, or simply the baseline hazard. Frailty values can be sampled from gamma, power variance function (PVF), log-normal, inverse Gaussian, and positive stable distributions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">genfrail(N = 300, K = 2, K.param = c(2, 0), beta = c(log(2)),
         frailty = "gamma", theta = c(2), 
         covar.distr = "normal", covar.param = c(0, 1), covar.matrix = NULL,
         censor.distr = "normal", censor.param = c(130, 15), 
         censor.rate = NULL, censor.time = NULL,
         lambda_0 = NULL, Lambda_0 = NULL, Lambda_0_inv = NULL, 
         round.base = NULL, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>integer; number of clusters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>integer, string, or vector; If an integer, the number of members in each cluster. If a string, the name of the distribution to sample the cluster sizes from. This can be one of: "poisson", "pareto", or "uniform". The <code>K.param</code> argument specifies the distribution parameters. If a vector, must be of length N and contains the integer size of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K.param</code></td>
<td>
<p>vector of the cluster size distribution parameters if <code>K</code> is a string. If "possion", the vector should contain the rate and truncated value (see <code>rtpois</code>). If "pareto", the exponent, lower, and upper bounds (see <code>rtzeta</code>). If "uniform", the lower (noninclusive) and upper (inclusive) bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>vector of regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frailty</code></td>
<td>
<p>string name of the frailty distribution. Can be one of: "gamma", "pvf", "lognormal", "invgauss", "posstab", or "none". See <code>dgamma_r</code>,<code>dpvf_r</code>, <code>dlognormal_r</code>, <code>dinvgauss_r</code>, <code>posstab_r</code> for the respective density functions. (Also see the *_c for C implementations of the respective density functions.) </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>vector the frailty distribution parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar.distr</code></td>
<td>
<p>string distribution to sample covariates from. Can be one of: "normal", "uniform", "zero"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar.param</code></td>
<td>
<p>vector covariate distribution parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar.matrix</code></td>
<td>
<p>matrix with dimensions <code>c(NK, length(beta))</code> that contains the desired covariates. If not NULL, this overrides <code>covar.distr</code> and <code>covar.param</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censor.distr</code></td>
<td>
<p>string censoring distribution to use. Followup times are sampled from the censoring distribution to simulate non-informative right censorship. The censoring distribution can be one of: "normal", "lognormal", "uniform", "none".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censor.param</code></td>
<td>
<p>vector of censoring distribution parameters. For normal and lognormal censorship, this should be c(mu,sigma) where mu is the mean and sigma is the standard deviation (Note: this is still the mean and standard deviation for lognormal). For uniform censorship, the vector <code>c(lower, upper)</code> should specify the lower and upper bounds.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censor.rate</code></td>
<td>
<p>numeric value between 0 and 1 to specify the empirical censoring rate. The mean specified in the <code>censor.param</code> parameter is adjusted to achieve a desired censoring rate if <code>censor.rate</code> is given. Note that the standard deviation (the second parameter in <code>censor.param</code>) must still be specified so that the problem is identifiable. For uniform censorship, the interval given by <code>c(lower, upper)</code> is adjusted to achieve the desired censorship, while keeping the variance fixed (i.e., upper - lower does not change).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>censor.time</code></td>
<td>
<p>vector of right-censorship times. This must have length N*K and specifies the right-censoring times of each observation. Note that this overrides all other censor.* params and cannot be used with variable cluster sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_0</code></td>
<td>
<p>function baseline hazard. Only one of <code>lambda_0</code>, <code>Lambda_0</code>, and <code>Lambda_0_inv</code> need to be specified. Passing the baseline hazard (<code>lambda_0</code>) is the most computationally expensive since this requires numerical integration inside a root-finding algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda_0</code></td>
<td>
<p>function cumulative baseline hazard. This overrides <code>lambda_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lambda_0_inv</code></td>
<td>
<p>function inverse cumulative baseline hazard. This overrides both <code>lambda_0</code> and <code>Lambda_0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>round.base</code></td>
<td>
<p>numeric if specified, round the followup times to the nearest <code>round.base</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>control parameters in the form of a <code>genfrail.control</code> object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments will be passed to <code>genfrail.control</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>data.frame</code> with row-observations is returned.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>the cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rep</code></td>
<td>
<p>the member within each cluster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>observed followup time</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status</code></td>
<td>
<p>failure indicator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z1...</code></td>
<td>
<p>covariates, where there are <code>length(beta)</code> Z columns</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>John V. Monaco, Malka Gorfine, and Li Hsu.
</p>


<h3>See Also</h3>

<p><code>fitfrail</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Generate the same dataset 3 different ways

# Using the baseline hazard (least efficient)
set.seed(1234)
dat.1 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2,
                  lambda_0=function(t, tau=4.6, C=0.01) (tau*(C*t)^tau)/t)

# Using the cumulative baseline hazard
set.seed(1234)
dat.2 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2, 
                  Lambda_0 = function(t, tau=4.6, C=0.01) (C*t)^tau)

# Using the inverse cumulative baseline hazard (most efficient)
set.seed(1234)
dat.3 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2, 
                  Lambda_0_inv=function(t, tau=4.6, C=0.01) (t^(1/tau))/C)

# Generate data with PVF frailty, truncated Poisson cluster sizes, normal
# covariates, and 0.35 censorship from a lognormal distribution
set.seed(1234)
dat.4 &lt;- genfrail(N = 100, K = "poisson", K.param=c(5, 1), 
                  beta = c(log(2),log(3)),
                  frailty = "pvf", theta = 0.3, 
                  covar.distr = "lognormal", 
                  censor.rate = 0.35) # Use the default baseline hazard

# Cluster sizes have size &gt;= 2, summarized by
summary(dat.4)

# An oscillating baseline hazard
set.seed(1234)
dat.5 &lt;- genfrail(lambda_0=function(t, tau=4.6, C=0.01, A=2, f=0.1) 
                              A^sin(f*pi*t) * (tau*(C*t)^tau)/t)

# Uniform censorship with 0.25 censoring rate
set.seed(1234)
dat.6 &lt;- genfrail(N = 300, K = 2, 
                  beta = c(log(2),log(3)),
                  frailty = "gamma", theta = 2, 
                  censor.distr = "uniform", 
                  censor.param = c(50, 150), 
                  censor.rate = 0.25,
                  Lambda_0_inv=function(t, tau=4.6, C=0.01) (t^(1/tau))/C)
</code></pre>


</div>