<div class="container">

<table style="width: 100%;"><tr>
<td>remove_hold</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Removes Hold on UI Element</h2>

<h3>Description</h3>

<p>When some buttons are clicked they will change the state of the
system, but other UI components will not detect that change correctly. So those
triggers are put on hold. This will remove the hold after those UI
components have updated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">remove_hold(state, session, inputId)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>state</code></td>
<td>
<p>module state with all of the current ui elements populated</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session</code></td>
<td>
<p>Shiny session variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inputId</code></td>
<td>
<p>The input ID of the UI element that was put on hold</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>No return value, called to remove holds.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Within shiny both session and input variables will exist, 
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# For this example we also need a state variable
state = sess_res$state

# This sets a hold on the specified inputID. This is normally done in 
# your XX_fetch_state() function.
state = set_hold(state, inputId = "select_dw_views")

# This will fetch the hold status of the specified inputID. 
fetch_hold(state, inputId = "select_dw_views")

# This will remove the hold and is normally done in one of the UI outputs
# with a priority set to ensure it happens after the rest of the UI has
# refreshed.
state = remove_hold(state, session, inputId = "select_dw_views")
</code></pre>


</div>