<div class="container">

<table style="width: 100%;"><tr>
<td>boottest.ivreg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast wild cluster bootstrap inference for object of class lm</h2>

<h3>Description</h3>

<p><code>boottest.ivreg</code> is a S3 method that allows for fast wild cluster
bootstrap inference for objects of class ivreg by  implementing
the fast wild bootstrap algorithm developed in Roodman et al., 2019
for instrumental variable models (WRE, Davidson &amp; McKinnon, 2010)
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'ivreg'
boottest(
  object,
  clustid,
  param,
  B,
  bootcluster = "max",
  conf_int = TRUE,
  R = NULL,
  r = 0,
  sign_level = 0.05,
  type = "rademacher",
  impose_null = TRUE,
  p_val_type = "two-tailed",
  tol = 1e-06,
  floattype = "Float64",
  getauxweights = FALSE,
  maxmatsize = NULL,
  bootstrapc = FALSE,
  liml = FALSE,
  fuller = NULL,
  kappa = NULL,
  arubin = FALSE,
  ssc = boot_ssc(adj = TRUE, fixef.K = "none", cluster.adj = TRUE, cluster.df =
    "conventional"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class lm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustid</code></td>
<td>
<p>A character vector or rhs formula containing the names of
the cluster variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>A character vector or rhs formula of length one. The name of
the regression
coefficient for which the hypothesis is to be tested</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Integer. The number of bootstrap iterations. When the number of
clusters is low,
increasing B adds little additional runtime</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootcluster</code></td>
<td>
<p>A character vector or rhs formula of length 1. Specifies
the bootstrap clustering variable or variables. If more
than one variable is specified, then bootstrapping is clustered
by the intersections of
clustering implied by the listed variables. To mimic the behavior
of stata's boottest command,
the default is to cluster by the intersection of all the variables
specified via the <code>clustid</code> argument,
even though that is not necessarily recommended (see the paper by
Roodman et al cited below, section 4.2).
Other options include "min", where bootstrapping is clustered by
the cluster variable with the fewest clusters.
Further, the subcluster bootstrap (MacKinnon &amp; Webb, 2018) is
supported - see the <code>vignette("fwildclusterboot", package = "fwildclusterboot")</code> for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_int</code></td>
<td>
<p>A logical vector. If TRUE, boottest computes confidence
intervals by test inversion. If FALSE, only the p-value is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Hypothesis Vector giving linear combinations of coefficients.
Must be either NULL or a vector of the same length as <code>param</code>. If NULL,
a vector of ones of length param.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>A numeric. Shifts the null hypothesis
H0: param = r vs H1: param != r</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_level</code></td>
<td>
<p>A numeric between 0 and 1 which sets the significance level
of the inference procedure. E.g. sign_level = 0.05
returns 0.95% confidence intervals. By default, sign_level = 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>character or function. The character string specifies the type
of boostrap to use: One of "rademacher", "mammen", "norm", "gamma"
and "webb". Alternatively, type can be a function(n) for drawing
wild bootstrap factors. "rademacher" by default.
For the Rademacher and Mammen distribution, if the number of
replications B exceeds
the number of possible draw ombinations, 2^(#number of clusters),
then <code>boottest()</code>
will use each possible combination once (enumeration).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impose_null</code></td>
<td>
<p>Logical. Controls if the null hypothesis is imposed on
the bootstrap dgp or not. Null imposed <code>(WCR)</code> by default.
If FALSE, the null is not imposed <code>(WCU)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_val_type</code></td>
<td>
<p>Character vector of length 1. Type of p-value.
By default "two-tailed". Other options include "equal-tailed",
"&gt;" and "&lt;".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Numeric vector of length 1. The desired accuracy
(convergence tolerance) used in the root finding procedure to find
the confidence interval.
Relative tolerance of 1e-6 by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>floattype</code></td>
<td>
<p>Float64 by default. Other option: Float32. Should floating
point numbers in Julia be represented as 32 or 64 bit?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getauxweights</code></td>
<td>
<p>Logical. FALSE by default. Whether to save auxilliary
weight matrix (v)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxmatsize</code></td>
<td>
<p>NULL by default = no limit. Else numeric scalar to set
the maximum size of auxilliary weight matrix (v), in gigabytes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootstrapc</code></td>
<td>
<p>Logical scalar, FALSE by default. TRUE  to request
bootstrap-c instead of bootstrap-t</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>liml</code></td>
<td>
<p>Logical scalar. False by default. TRUE for liml or fuller liml</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fuller</code></td>
<td>
<p>NULL by default. Numeric scalar. fuller liml factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Null by default. fixed &lt;U+03BA&gt; for k-class estimation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arubin</code></td>
<td>
<p>False by default. Logical scalar. TRUE for Anderson-Rubin Test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ssc</code></td>
<td>
<p>An object of class <code>boot_ssc.type</code> obtained with the function
<code>boot_ssc()</code>. Represents how the small sample
adjustments are computed. The defaults are <code style="white-space: pre;">⁠adj = TRUE, fixef.K = "none", cluster.adj = "TRUE", cluster.df = "conventional"⁠</code>.
You can find more details in the help file for <code>boot_ssc()</code>.
The function is purposefully designed to mimic
fixest's <code>fixest::ssc()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class <code>boottest</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>p_val</code></td>
<td>
<p>The bootstrap p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf_int</code></td>
<td>
<p>The bootstrap confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>The tested parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>Sample size. Might differ from the regression sample size if
the cluster variables contain NA values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot_iter</code></td>
<td>
<p>Number of Bootstrap Iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustid</code></td>
<td>
<p>Names of the cluster Variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N_G</code></td>
<td>
<p>Dimension of the cluster variables as used in boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign_level</code></td>
<td>
<p>Significance level used in boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Distribution of the bootstrap weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impose_null</code></td>
<td>
<p>Whether the null was imposed on the bootstrap dgp or not.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>The vector "R" in the null hypothesis of interest Rbeta = r.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>The scalar "r" in the null hypothesis of interest Rbeta = r.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>point_estimate</code></td>
<td>
<p>R'beta. A scalar: the constraints vector times the
regression coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid_vals</code></td>
<td>
<p>All t-statistics calculated while calculating the
confidence interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_grid_vals</code></td>
<td>
<p>All p-values calculated while calculating the confidence
interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_stat</code></td>
<td>
<p>The 'original' regression test statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t_boot</code></td>
<td>
<p>All bootstrap t-statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regression</code></td>
<td>
<p>The regression object used in boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Function call of boottest.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>engine</code></td>
<td>
<p>The employed bootstrap algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nthreads</code></td>
<td>
<p>The number of threads employed.</p>
</td>
</tr>
</table>
<h3>Setting Seeds</h3>

<p>To guarantee reproducibility, you need to
set a global random seed via <code>set.seed()</code>
</p>


<h3>References</h3>

<p>Roodman et al., 2019, "Fast and wild: Bootstrap inference in
STATA using boottest", The STATA Journal.
(<a href="https://ideas.repec.org/p/qed/wpaper/1406.html">https://ideas.repec.org/p/qed/wpaper/1406.html</a>)
</p>
<p>Cameron, A. Colin, Jonah B. Gelbach, and Douglas L. Miller.
"Bootstrap-based improvements for inference with clustered errors."
The Review of Economics and Statistics 90.3 (2008): 414-427.
</p>
<p>Cameron, A.Colin &amp; Douglas L. Miller. "A practitioner's
guide to cluster-robust inference" Journal of Human Resources (2015)
<a href="https://doi.org/10.3368/jhr.50.2.317">doi:10.3368/jhr.50.2.317</a>
</p>
<p>Davidson &amp; MacKinnon. "Wild Bootstrap Tests for IV regression"
Journal of Economics and Business Statistics (2010)
<a href="https://doi.org/10.1198/jbes.2009.07221">doi:10.1198/jbes.2009.07221</a>
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
"The wild bootstrap for few (treated) clusters."
The Econometrics Journal 21.2 (2018): 114-135.
</p>
<p>MacKinnon, James G., and Matthew D. Webb.
"Cluster-robust inference: A guide to empirical practice"
Journal of Econometrics (2022)
<a href="https://doi.org/10.1016/j.jeconom.2022.04.001">doi:10.1016/j.jeconom.2022.04.001</a>
</p>
<p>MacKinnon, James. "Wild cluster bootstrap confidence
intervals." L'Actualite economique 91.1-2 (2015): 11-33.
</p>
<p>Webb, Matthew D. Reworking wild bootstrap based inference
for clustered errors. No. 1315. Queen's Economics Department Working
Paper, 2013.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
requireNamespace("ivreg")
requireNamespace("fwildclusterboot")

# drop all NA values from SchoolingReturns
SchoolingReturns &lt;- na.omit(SchoolingReturns)
ivreg_fit &lt;- ivreg(log(wage) ~ education + age +
  ethnicity + smsa + south + parents14 |
  nearcollege + age + ethnicity + smsa
    + south + parents14,
data = SchoolingReturns
)

boot_ivreg &lt;- boottest(
  object = ivreg_fit,
  B = 999,
  param = "education",
  clustid = "kww",
  type = "mammen",
  impose_null = TRUE
)
summary(boot_ivreg)
print(boot_ivreg)
plot(boot_ivreg)
nobs(boot_ivreg)
pval(boot_ivreg)
confint(boot_ivreg)
generics::tidy(boot_ivreg)

## End(Not run)

</code></pre>


</div>