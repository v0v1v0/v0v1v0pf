<div class="container">

<table style="width: 100%;"><tr>
<td>learn_heavy_tail_bipartite_graph_pgd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Laplacian matrix of a connected bipartite graph with heavy-tailed data
Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix
whose distribution is assumed to be Student-t.</h2>

<h3>Description</h3>

<p>Laplacian matrix of a connected bipartite graph with heavy-tailed data
</p>
<p>Computes the Laplacian matrix of a bipartite graph on the basis of an observed data matrix
whose distribution is assumed to be Student-t.
</p>


<h3>Usage</h3>

<pre><code class="language-R">learn_heavy_tail_bipartite_graph_pgd(
  X,
  r,
  q,
  nu = 2.001,
  learning_rate = 1e-04,
  maxiter = 1000,
  reltol = 1e-05,
  init = "default",
  verbose = TRUE,
  record_objective = FALSE,
  backtrack = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a n x p data matrix, where p is the number of nodes in the graph and n is the number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>number of nodes in the objects set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>number of nodes in the classes set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>degrees of freedom of the Student-t distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>learning_rate</code></td>
<td>
<p>gradient descent parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reltol</code></td>
<td>
<p>relative tolerance as a convergence criteria.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>
<p>string denoting how to compute the initial graph or a r x q matrix with initial graph weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>whether or not to show a progress bar during the iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>record_objective</code></td>
<td>
<p>whether or not to record the objective function value during iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>backtrack</code></td>
<td>
<p>whether or not to optimize the learning rate via backtracking.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing possibly the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>laplacian</code></td>
<td>
<p>estimated Laplacian matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjacency</code></td>
<td>
<p>estimated adjacency matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>estimated graph weights matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>number of iterations taken to reach convergence</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>boolean flag to indicate whether or not the optimization converged</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr_seq</code></td>
<td>
<p>learning rate value per iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj_seq</code></td>
<td>
<p>objective function value per iteration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elapsed_time</code></td>
<td>
<p>time taken per iteration until convergence is reached</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">library(finbipartite)
library(igraph)
set.seed(42)
r &lt;- 50
q &lt;- 5
p &lt;- r + q

bipartite &lt;- sample_bipartite(r, q, type="Gnp", p = 1, directed=FALSE)
# randomly assign edge weights to connected nodes
E(bipartite)$weight &lt;- 1
Lw &lt;- as.matrix(laplacian_matrix(bipartite))
B &lt;- -Lw[1:r, (r+1):p]
B[,] &lt;- runif(length(B))
B &lt;- B / rowSums(B)
# utils functions
from_B_to_laplacian &lt;- function(B) {
  A &lt;- from_B_to_adjacency(B)
  return(diag(rowSums(A)) - A)
}

from_B_to_adjacency &lt;- function(B) {
  r &lt;- nrow(B)
  q &lt;- ncol(B)
  zeros_rxr &lt;- matrix(0, r, r)
  zeros_qxq &lt;- matrix(0, q, q)
  return(rbind(cbind(zeros_rxr, B), cbind(t(B), zeros_qxq)))
}
Ltrue &lt;- from_B_to_laplacian(B)
X &lt;- MASS::mvrnorm(100*p, rep(0, p), MASS::ginv(Ltrue))
bipartite_graph &lt;- learn_heavy_tail_bipartite_graph_pgd(X = X,
                                                        r = r,
                                                        q = q,
                                                        nu = 1e2,
                                                        verbose=FALSE)
</code></pre>


</div>