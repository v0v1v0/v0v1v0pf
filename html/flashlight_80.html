<div class="container">

<table style="width: 100%;"><tr>
<td>light_profile2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>2D Partial Dependence and other 2D Profiles</h2>

<h3>Description</h3>

<p>Calculates different types of 2D-profiles across two variables.
By default, partial dependence profiles are calculated (see Friedman).
Other options are response, predicted values, residuals, and shap.
The results are aggregated by (weighted) means.
</p>


<h3>Usage</h3>

<pre><code class="language-R">light_profile2d(x, ...)

## Default S3 method:
light_profile2d(x, ...)

## S3 method for class 'flashlight'
light_profile2d(
  x,
  v = NULL,
  data = NULL,
  by = x$by,
  type = c("partial dependence", "predicted", "response", "residual", "shap"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = "equal",
  use_linkinv = TRUE,
  counts = TRUE,
  counts_weighted = FALSE,
  pd_evaluate_at = NULL,
  pd_grid = NULL,
  pd_indices = NULL,
  pd_n_max = 1000L,
  pd_seed = NULL,
  ...
)

## S3 method for class 'multiflashlight'
light_profile2d(
  x,
  v = NULL,
  data = NULL,
  type = c("partial dependence", "predicted", "response", "residual", "shap"),
  breaks = NULL,
  n_bins = 11L,
  cut_type = "equal",
  pd_evaluate_at = NULL,
  pd_grid = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class "flashlight" or "multiflashlight".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to <code>cut3()</code> in forming
the cut breaks of the <code>v</code> variables. Not relevant for partial dependence profiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>A vector of exactly two variable names to be profiled.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An optional <code>data.frame</code>. Not used for <code>type = "shap"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by</code></td>
<td>
<p>An optional vector of column names used to additionally group the results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of the profile: Either "partial dependence", "predicted",
"response", "residual", or "shap".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>Named list of cut breaks specifying how to bin one or more numeric
variables. Used to overwrite automatic binning via <code>n_bins</code> and <code>cut_type</code>.
Ignored for non-numeric <code>v</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_bins</code></td>
<td>
<p>Approximate number of unique values to evaluate for numeric <code>v</code>.
Can be an unnamed vector of length 2 to distinguish between v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut_type</code></td>
<td>
<p>Should numeric <code>v</code> be cut into "equal" or "quantile" bins?
Can be an unnamed vector of length 2 to distinguish between v.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_linkinv</code></td>
<td>
<p>Should retransformation function be applied?
Default is <code>TRUE</code>. Not used for type "shap".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>Should observation counts be added?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts_weighted</code></td>
<td>
<p>If <code>counts</code> is TRUE: Should counts be weighted by the
case weights? If <code>TRUE</code>, the sum of <code>w</code> is returned by group.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd_evaluate_at</code></td>
<td>
<p>An named list of evaluation points for one or more variables.
Only relevant for type = "partial dependence".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd_grid</code></td>
<td>
<p>An evaluation <code>data.frame</code> with exactly two columns,
e.g., generated by <code>expand.grid()</code>. Only used for type = "partial dependence".
Offers maximal flexibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd_indices</code></td>
<td>
<p>A vector of row numbers to consider in calculating partial
dependence profiles. Only used for type = "partial dependence".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd_n_max</code></td>
<td>
<p>Maximum number of ICE profiles to calculate
(will be randomly picked from <code>data</code>). Only used for type = "partial dependence".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pd_seed</code></td>
<td>
<p>Integer random seed used to select ICE profiles.
Only used for type = "partial dependence".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Different binning options are available, see arguments below.
For high resolution partial dependence plots, it might be necessary to specify
<code>breaks</code>, <code>pd_evaluate_at</code> or <code>pd_grid</code> in order to avoid empty parts
in the plot. A high value of <code>n_bins</code> might not have the desired effect as it
internally capped at the number of distinct values of a variable.
</p>
<p>For partial dependence and prediction profiles, "model", "predict_function",
"linkinv" and "data" are required. For response profiles it is "y", "linkinv"
and "data" and for shap profiles it is just "shap". "data" can be passed on the fly.
</p>


<h3>Value</h3>

<p>An object of class "light_profile2d" with the following elements:
</p>

<ul>
<li> <p><code>data</code> A tibble containing results. Can be used to build fully customized
visualizations. Column names can be controlled by
<code>options(flashlight.column_name)</code>.
</p>
</li>
<li> <p><code>by</code> Names of group by variables.
</p>
</li>
<li> <p><code>v</code> The two variable names evaluated.
</p>
</li>
<li> <p><code>type</code> Same as input <code>type</code>. For information only.
</p>
</li>
</ul>
<h3>Methods (by class)</h3>


<ul>
<li> <p><code>light_profile2d(default)</code>: Default method not implemented yet.
</p>
</li>
<li> <p><code>light_profile2d(flashlight)</code>: 2D profiles for flashlight.
</p>
</li>
<li> <p><code>light_profile2d(multiflashlight)</code>: 2D profiles for multiflashlight.
</p>
</li>
</ul>
<h3>References</h3>

<p>Friedman J. H. (2001). Greedy function approximation: A gradient boosting machine.
The Annals of Statistics, 29:1189â€“1232.
</p>


<h3>See Also</h3>

<p><code>light_profile()</code>, <code>plot.light_profile2d()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">fit &lt;- lm(Sepal.Length ~ ., data = iris)
fl &lt;- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
light_profile2d(fl, v = c("Petal.Length", "Species"))
</code></pre>


</div>