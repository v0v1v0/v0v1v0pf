<div class="container">

<table style="width: 100%;"><tr>
<td>garchFitControl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Control GARCH fitting algorithms</h2>

<h3>Description</h3>

<p>Control parameters for the GARCH fitting algorithms.
</p>


<h3>Usage</h3>

<pre><code class="language-R">garchFitControl(
    llh = c("filter", "internal", "testing"),
    nlminb.eval.max = 2000,
    nlminb.iter.max = 1500,
    nlminb.abs.tol = 1.0e-20,
    nlminb.rel.tol = 1.0e-14,
    nlminb.x.tol = 1.0e-14,
    nlminb.step.min = 2.2e-14,
    nlminb.scale = 1,
    nlminb.fscale = FALSE,
    nlminb.xscale = FALSE,
    sqp.mit = 200,
    sqp.mfv = 500,
    sqp.met = 2,
    sqp.mec = 2,
    sqp.mer = 1,
    sqp.mes = 4,
    sqp.xmax = 1.0e3,
    sqp.tolx = 1.0e-16,
    sqp.tolc = 1.0e-6,
    sqp.tolg = 1.0e-6,
    sqp.told = 1.0e-6,
    sqp.tols = 1.0e-4,
    sqp.rpf = 1.0e-4,
    lbfgsb.REPORT = 10,
    lbfgsb.lmm = 20,
    lbfgsb.pgtol = 1e-14,
    lbfgsb.factr = 1,
    lbfgsb.fnscale = FALSE,
    lbfgsb.parscale = FALSE,
    nm.ndeps = 1e-14,
    nm.maxit = 10000,
    nm.abstol = 1e-14,
    nm.reltol = 1e-14,
    nm.alpha = 1.0,
    nm.beta = 0.5,
    nm.gamma = 2.0,
    nm.fnscale = FALSE,
    nm.parscale = FALSE)
</code></pre>


<h3>Arguments</h3>


<table><tr style="vertical-align: top;">
<td><code>llh</code></td>
<td>

<p><code>llh = c("filter", "internal", "testing")[1]</code>,
defaults to <code>"filter"</code>.
</p>
</td>
</tr></table>
<table>
<tr style="vertical-align: top;">
<td><code>nlminb.eval.max</code></td>
<td>

<p>maximum number of evaluations of the objective function,
defaults to 200.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.iter.max</code></td>
<td>

<p>maximum number of iterations, defaults to 150.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>nlminb.abs.tol</code></td>
<td>

<p>absolute tolerance, defaults to 1e-20.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.rel.tol</code></td>
<td>

<p>relative tolerance, defaults to 1e-10.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.x.tol</code></td>
<td>

<p>X tolerance, defaults to 1.5e-8.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.fscale</code></td>
<td>

<p>defaults to FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.xscale</code></td>
<td>

<p>defaulkts to FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.step.min</code></td>
<td>

<p>minimum step size, defaults to 2.2e-14.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlminb.scale</code></td>
<td>

<p>defaults to 1.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>sqp.mit</code></td>
<td>

<p>maximum number of iterations, defaults to 200.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.mfv</code></td>
<td>

<p>maximum number of function evaluations, defaults to 500.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.met</code></td>
<td>

<p>specifies scaling strategy:<br>
sqp.met=1 - no scaling,<br>
sqp.met=2 - preliminary scaling in 1st iteration (default),<br>
sqp.met=3 - controlled scaling,<br>
sqp.met=4 - interval scaling,<br>
sqp.met=5 - permanent scaling in all iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.mec</code></td>
<td>

<p>correction for negative curvature:<br>
sqp.mec=1 - no correction,<br>
sqp.mec=2 - Powell correction (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.mer</code></td>
<td>

<p>restarts after unsuccessful variable metric updates:<br>
sqp.mer=0 - no restarts,<br>
sqp.mer=1 - standard restart.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.mes</code></td>
<td>

<p>interpolation method selection in a line search:<br>
sqp.mes=1 - bisection,<br>
sqp.mes=2 - two point quadratic interpolation,<br>
sqp.mes=3 - three point quadratic interpolation,<br>
sqp.mes=4 - three point cubic interpolation (default).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.xmax</code></td>
<td>

<p>maximum stepsize, defaults to 1.0e+3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.tolx</code></td>
<td>

<p>tolerance for the change of the coordinate vector,
defaults to 1.0e-16.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.tolc</code></td>
<td>

<p>tolerance for the constraint violation,
defaults to 1.0e-6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.tolg</code></td>
<td>

<p>tolerance for the Lagrangian function gradient,
defaults to 1.0e-6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.told</code></td>
<td>

<p>defaults to 1.0e-6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.tols</code></td>
<td>

<p>defaults to 1.0e-4.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sqp.rpf</code></td>
<td>

<p>value of the penalty coefficient,
default to1.0D-4.
The default velue may be relatively small. Therefore, larger
value, say one, can sometimes be more suitable.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>lbfgsb.REPORT</code></td>
<td>

<p>the frequency of reports for the <code>"BFGS"</code> and <code>"L-BFGS-B"</code>
methods if <code>control$trace</code> is positive. Defaults to every 10
iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsb.lmm</code></td>
<td>

<p>an integer giving the number of BFGS updates retained in
the <code>"L-BFGS-B"</code> method, It defaults to 5.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsb.factr</code></td>
<td>

<p>controls the convergence of the <code>"L-BFGS-B"</code>
method. Convergence occurs when the reduction in the objective is
within this factor of the machine tolerance. Default is 1e7, that is
a tolerance of about 1.0e-8.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsb.pgtol</code></td>
<td>

<p>helps control the convergence of the <code>"L-BFGS-B"</code> method. It is
a tolerance on the projected gradient in the current search
direction. This defaults to zero, when the check is suppressed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsb.fnscale</code></td>
<td>

<p>defaults to FALSE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lbfgsb.parscale</code></td>
<td>

<p>defaults to FALSE.
</p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>nm.ndeps</code></td>
<td>

<p>a vector of step sizes for the finite-difference approximation
to the gradient, on par/parscale scale. Defaults to 1e-3.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm.maxit</code></td>
<td>

<p>the maximum number of iterations. Defaults to 100 for the
derivative-based methods, and 500 for <code>"Nelder-Mead"</code>. For
<code>"SANN"</code> maxit gives the total number of function
evaluations. There is no other stopping criterion. Defaults to
10000.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm.abstol</code></td>
<td>

<p>the absolute convergence tolerance. Only useful for non-negative
functions, as a tolerance for reaching zero.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm.reltol</code></td>
<td>

<p>relative convergence tolerance. The algorithm stops if it is
unable to reduce the value by a factor of
<code>reltol * (abs(val) + reltol)</code> at a step. Defaults to
<code>sqrt(.Machine$double.eps)</code>, typically about 1e-8.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm.alpha, nm.beta, nm.gamma</code></td>
<td>

<p>scaling parameters for the "Nelder-Mead" method.
alpha is the reflection factor (default 1.0),
beta the contraction factor (0.5), and
gamma the expansion factor (2.0).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm.fnscale</code></td>
<td>

<p>an overall scaling to be applied to the value of fn and gr
during optimization. If negative, turns the problem into a
maximization problem.  Optimization is performed on
<code>fn(par) / nm.fnscale</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm.parscale</code></td>
<td>

<p>a vector of scaling values for the parameters. Optimization is
performed on par/parscale and these should be comparable in the
sense that a unit change in any element produces about a unit
change in the scaled value.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a list
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port,<br>
R Core Team for the 'optim' <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port,<br>
Douglas Bates and Deepayan Sarkar for the 'nlminb' <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>-port,<br>
Bell-Labs for the underlying PORT Library,<br>
Ladislav Luksan for the underlying Fortran SQP Routine, <br>
Zhu, Byrd, Lu-Chen and Nocedal for the underlying L-BFGS-B Routine.
</p>


<h3>See Also</h3>

<p><code>garchFit</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
</code></pre>


</div>