<div class="container">

<table style="width: 100%;"><tr>
<td>fill.KNNimpute</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Imputation using Weighted K-nearest Neighbors</h2>

<h3>Description</h3>

<p>One of the simplest idea to <em>guess</em> missing entry is to use
portion of the data that has most similar characteristics across
all covariates. <code>fill.KNNimpute</code> follows such reasoning in that
it finds <code class="reqn">K</code>-nearest neighbors based on observed variables and
uses weighted average of nearest elements to fill in the missing entry.
Note that when there are many missing entries, it's possible that there are
no <em>surrogates</em> to be computed upon. Therefore, if there exists an entire
row or column full of missing entries, the algorithm stops.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fill.KNNimpute(A, k = ceiling(nrow(A)/2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>an <code class="reqn">(n\times p)</code> partially observed matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the number of neighbors to use.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>X</dt>
<dd>
<p>an <code class="reqn">(n\times p)</code> matrix after completion.</p>
</dd>
</dl>
<h3>References</h3>

<p>Troyanskaya O, Cantor M, Sherlock G, Brown P, Hastie T, Tibshirani R, Botstein D, Altman RB (2001).
“Missing value estimation methods for DNA microarrays.”
<em>Bioinformatics</em>, <b>17</b>(6), 520–525.
ISSN 1367-4803.
</p>


<h3>See Also</h3>

<p><code>fill.SVDimpute</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## load image data of 'lena128'
data(lena128)

## transform 5% of entries into missing
set.seed(5)
A &lt;- aux.rndmissing(lena128, x=0.05)

## apply the method with 3 different neighborhood size
fill1 &lt;- fill.KNNimpute(A, k=5)
fill2 &lt;- fill.KNNimpute(A, k=25)
fill3 &lt;- fill.KNNimpute(A, k=50)

## visualize only the last ones from each run
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
image(A, col=gray((0:100)/100), axes=FALSE, main="5% missing")
image(fill1$X, col=gray((0:100)/100), axes=FALSE, main="5-neighbor")
image(fill2$X, col=gray((0:100)/100), axes=FALSE, main="25-neighbor")
image(fill3$X, col=gray((0:100)/100), axes=FALSE, main="50-neighbor")
par(opar)

</code></pre>


</div>