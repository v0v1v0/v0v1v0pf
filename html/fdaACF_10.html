<div class="container">

<table style="width: 100%;"><tr>
<td>obtain_autocorrelation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate the autocorrelation function of the series</h2>

<h3>Description</h3>

<p>Obtain the empirical autocorrelation function for
lags <code class="reqn">= 0,...,</code><code>nlags</code> of the functional time
series. Given <code class="reqn">Y_{1},...,Y_{T}</code> a functional time
series, the sample autocovariance functions
<code class="reqn">\hat{C}_{h}(u,v)</code> are given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{C}_{h}(u,v) =  \frac{1}{T} \sum_{i=1}^{T-h}(Y_{i}(u) - \overline{Y}_{T}(u))(Y_{i+h}(v) - \overline{Y}_{T}(v))</code>
</p>

<p>where
<code class="reqn"> \overline{Y}_{T}(u) = \frac{1}{T} \sum_{i = 1}^{T} Y_{i}(t)</code>
denotes the sample mean function. By normalizing these
functions using the normalizing factor
<code class="reqn">\int\hat{C}_{0}(u,u)du</code>, the range of the
autocovariance functions becomes <code class="reqn">(0,1)</code>; thus
defining the autocorrelation functions of the series
</p>


<h3>Usage</h3>

<pre><code class="language-R">obtain_autocorrelation(Y, v = seq(from = 0, to = 1, length.out =
  ncol(Y)), nlags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlags</code></td>
<td>
<p>Number of lagged covariance operators
of the functional time series that will be used
to estimate the autocorrelation function.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Return a list with the lagged autocorrelation
functions estimated from the data. Each function is given
by a <code class="reqn">(m x m)</code> matrix, where <code class="reqn">m</code> is the
number of points observed in each curve.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
lagged_autocor &lt;- obtain_autocorrelation(Y = bbridge,
                                        nlags = nlags)
image(x = v, y = v, z = lagged_autocor$Lag0)


# Example 2
require(fields)
N &lt;- 500
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 4
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,
                                        nlags = nlags)
lagged_autocor &lt;- obtain_autocorrelation(Y = bbridge,
                                         v = v,
                                         nlags = nlags)

opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
z_lims &lt;- range(lagged_autocov$Lag1)
colors &lt;- heat.colors(12)
image.plot(x = v, 
           y = v,
           z = lagged_autocov$Lag1,
           legend.width = 2,
           zlim = z_lims,
           col = colors,
           xlab = "u",
           ylab = "v",
           main = "Autocovariance")
z_lims &lt;- range(lagged_autocor$Lag1)
image.plot(x = v, 
           y = v,
           z = lagged_autocor$Lag1,
           legend.width = 2,
           zlim = z_lims,
           col = colors,
           xlab = "u",
           ylab = "v",
           main = "Autocorrelation")
par(opar)

</code></pre>


</div>