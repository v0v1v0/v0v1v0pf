<div class="container">

<table style="width: 100%;"><tr>
<td>metropolis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Bayesian Estimation of Univariate Probability Distributions</h2>

<h3>Description</h3>

<p>For a given dataset, this function serves to approximate
(using a Metropolis algorithm) the posterior distribution of the
parameters  for some specified parametric probability distribution.</p>


<h3>Usage</h3>

<pre><code class="language-R">metropolis(model, iter = 1000, tun = 2, trans.list = NULL,
	start = NULL, variance = NULL, prior = NULL, burn = 0,
	uniroot.interval = c(-100, 100),pass.down.to.C=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p><code>mle</code> object corresponding to the fitted (by
maximum likelihood) model.<br></p>
<p>A <code>list(x=dataset, dist=distribution)</code> object may also be
provided, but the user will then have to make sure to specify the
arguments <code>start</code> and <code>variance</code>. Moreover, the latter two
arguments will have to be specified on their transformed scales (see
<code>trans.list</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>The requested number of iterations - the Markov Chain's
length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tun</code></td>
<td>
<p>A tuning constant; value by which the covariance matrix of
the multivariate normal proposal will be multiplied - see References.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trans.list</code></td>
<td>
<p>A <code>list</code> object containing a function
for each parameter that is to be estimated. For each parameter, the
function must correspond to the inverse transformation that will
determine the parametrization for which the simulation will be carried
out (see Example and Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>A vector of starting values for the algorithm. If
<code>NULL</code>, the maximum likelihood parameter estimates will be used
as starting values for the Markov Chain. If <code>model</code> is not an
object from the class <code>mle</code>, this argument will have to be
specified, along with the argument <code>variance</code>. Moreover, as
already stated above, the user will have to make sure that both
<code>start</code> and <code>variance</code> are those for the transformed
parameters (see <code>trans.list</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variance</code></td>
<td>
<p>Covariance matrix of the multivariate normal proposal
distribution. If <code>NULL</code>, the observed Fisher's information will
be used and multiplied by the specified <code>tun</code>. As for
<code>start</code>, this argument needs to be specified if <code>model</code> is
not from the class <code>mle</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>A function that corresponds to the joint prior
distribution (see Example). Note that the prior distribution will be
evaluated on the transformed parameter space(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>Burn-in period (see References).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uniroot.interval</code></td>
<td>
<p>Default is c(-100,100). This interval is used
by <code>R</code>'s function <code>uniroot</code> to search for the inverse
of each element in <code>trans.list</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pass.down.to.C</code></td>
<td>
<p>If <code>TRUE</code>, the iterative task is passed
down to a C program for faster implementation of the MCMC
algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function uses a single block Metropolis algorithm with
multivariate normal proposal. For this function to work properly, all
parameters should be defined on the real line - parameter
transformation(s) might be required. If <code>trans.list</code> is not
specified, the function will assume that the parameter distributions
are all defined on the real line (i.e., <code>function(x) x</code> will be
used for each parameter). If no prior distribution is provided, an
improper prior distribution - uniform on the interval )-Inf,+Inf( -
will be used for all parameters (i.e., prior distribution proportional
to 1 - function(x) 1).
</p>
<p>In order to minimize the number of arguments for <code>metropolis</code>,
the function automatically computes the inverse of <code>trans.list</code>:
this suppresses the need for the user to provide both the
"inverse transformation" and the "transformation". However, problems
may occur, and it is why the user is allowed to alter
<code>uniroot.interval</code>. Depending on the number of errors reported,
future versions of this package may end up requesting that a list for
both the "inverse transformation" and the "transformation" be provided
by the user.
</p>
<p>A nice list of references is provided below for more information on
topics such as: MCMC algorithms, tuning of Metropolis-Hastings
algorithms, MCMC convergence diagnostics, the Bayesian paradigm ...
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rate</code></td>
<td>
<p>MCMC acceptance rate. This value is computed before
applying the burn-in; i.e., it is computed for <code>sims.all</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>total.time</code></td>
<td>
<p>Total computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sims.all</code></td>
<td>
<p>Array containing all iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sims</code></td>
<td>
<p>Array containing iterations after burn-in.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>Inputted <code>mle</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>Prior distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>Integer corresponding to the number of iterations to be
discarded - burn-in period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M</code></td>
<td>
<p>Parameter vector whose elements correspond to the parameter
values (on the scales specified by <code>trans.list</code>) obtained at
the last iteration of the Metropolis sampler;
i.e. <code>sims[iter,]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>V</code></td>
<td>
<p>Covariance matrix computed using, after removing the burn-in
period, the joint posterior distribution of the parameters (on the
scales specified by <code>trans.list</code>). This matrix might be used to
tune the MCMC algorithm.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., and Rubin,
D.B. (2004). Bayesian data analysis, 2nd edition, Chapman &amp; Hall/CRC.
</p>
<p>Carlin, B.P, and Louis, T.A. (2009). Bayesian methods for data
analysis. Chapman &amp; Hall/CRC.
</p>
<p>Gamerman, D., and Lopes H.F. (2006). Markov Chain Monte Carlo:
Stochastic simulation for Bayesian inference. 2nd edition, Chapman &amp;
Hall/CRC.
</p>
<p>Gilks, W.R., Richardson, S., and Spiegelhalter, D.J. (1996). Markov
Chain Monte Carlo in Practice. Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code>plot.metropolis</code>, <code>mle</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
### These examples should be re-run with, e.g., iter &gt; 2000.
data(yarns)
x &lt;- yarns$x
fit.x &lt;- mle(x,'gamma',c(.1,.1))
bayes.x.no.prior &lt;- metropolis(model=fit.x,iter=150,
	trans.list=list(function(x) x,function(x) exp(x)))
plot(bayes.x.no.prior)

# examples of prior distributions (note that these prior distribution
#	are specified for the transformated parameters;
#	i.e., in this case, 'meanlog' -&gt; 'meanlog' and 'sdlog' -&gt; 'ln.sdlog')
# for the scale parameter only
prior.1 &lt;- function(x) dnorm(x[2],.8,.1)
# for both parameters (joint but independent in this case)
prior.2 &lt;- function(x) dunif(x[1],3.4,3.6)*dnorm(x[2],1,1)

bayes.x.prior.2 &lt;- metropolis(model=fit.x,iter=150,
	trans.list=list(function(x) x,function(x) exp(x)),prior=prior.2)
plot(bayes.x.prior.2)

# Example where 'model' is not from the class 'mle'; i.e.
# both 'start' and 'variance' need to be specified!
#x &lt;- rweibull(5,2,1)
x &lt;- c(0.9303492,1.0894917,0.9628029,0.6145032,0.4756699)
# Here 'fit.x &lt;- mle(x,'weibull',c(.1,.1))' is not used,
model.x &lt;- list(x=x,dist='weibull')
# and an informative prior distribution is considered to ensure a proper posterior distribution
prior.x &lt;- function(x) dnorm(x[1],log(2),.1)*dnorm(x[2],log(1),.1)
trans.list.x &lt;- list(function(x) exp(x), function(x) exp(x))
bayes.x &lt;- metropolis(model=model.x,iter=150,prior=prior.x,trans.list=trans.list.x,
            pass.down.to.C=TRUE,start=c(0,0),variance=diag(.1,2,2))

</code></pre>


</div>