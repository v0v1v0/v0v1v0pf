<div class="container">

<table style="width: 100%;"><tr>
<td>Power_Proj_Test_ufDA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Power of the Two-sample Projection-based test for functional data with known (or estimated)
eigencomponents.</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>The function <code>Power_Proj_Test_ufDA()</code> computes the power of
of the two-sample projection-based test for functional response data
setting, when the group difference, the eigenfunctions of the covariance
of the data are specified at dense grid of time points, along with the
(estimated) covariance of the <code>shrinkage</code> scores.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Power_Proj_Test_ufDA(
  total_sample_size,
  argvals,
  mean_vector,
  eigen_matrix,
  scores_var1,
  scores_var2,
  weights,
  sig.level = 0.05,
  alloc.ratio = c(1, 1),
  npc_to_pick = ncol(eigen_matrix),
  nsim = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>total_sample_size</code></td>
<td>
<p>Total sample size combing the two groups, must be a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argvals</code></td>
<td>
<p>The working grid of timepoints to evaluate the eigenfunctions and the mean functions.
It is preferred to take the working grid as dense grid so that
<code class="reqn">\int [\mu_1(t) - \mu_2(t)]\phi_k(t) \,dt</code> can be calculated with a required precision.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_vector</code></td>
<td>
<p>The difference in the mean function evaluated at argvals, must be a numeric vector of length same
as that that of argavls.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eigen_matrix</code></td>
<td>
<p>The matrix of eigenfunctions evaluated at argvals,
must be a length(argvals) by K matrix, where K is the number of eigenfunctions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores_var1</code></td>
<td>
<p>The true (or estimate) of covariance matrix of the shrinkage scores for the first group.
Must be symmetric (<code>is.symmetric(scores_var1) == TRUE</code>) and positive definite
(<code>chol(scores_var1)</code> without an error!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores_var2</code></td>
<td>
<p>The true (or estimate) of covariance matrix of the shrinkage scores for the second group.
Must be symmetric (<code>is.symmetric(scores_var2) == TRUE</code>) and positive definite
(<code>chol(scores_var2)</code> without an error!).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The weights to put to compute the projection <code class="reqn">\int [\mu_1(t) - \mu_2(t)]\phi_k(t) \,dt</code>,
for each <code class="reqn">k=1,\dots, K</code>. The integral is numerically approximated as
<code>sum(mean_diff(argvals)*eigen_matrix[,k]*weights)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sig.level</code></td>
<td>
<p>Significance level of the test, default set at 0.05, must be less than 0.2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alloc.ratio</code></td>
<td>
<p>The allocation ratio of samples in the each group. Note that the eigenfunctions
will still be estimated based on the total sample_size, however, the variance
of the <code>shrinkage</code> scores (which is required to compute the power function) will be
estimated based on the allocation of the samples in each group. Must be given as vector of
length 2. Default value is set at <code>c(1, 1)</code>, indicating equal sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npc_to_pick</code></td>
<td>
<p>Number of eigenfunction to be used to compute the power. Typically this is
becomes handy when the user want to discard few of the last eigenfunctions,
typically with a very small eigenvalues.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>The number of samples to be generated from the alternate distribution of
Hotelling T statistic. Default value is 10000.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The projection-based test first extracts K eigenfunctions from the data, and then
project the mean difference function onto each of the eigenfunctions to obtain a K-dimensional
projection vector that reflects the group difference. Wang (2021) pointed that under the null
hypothesis the covariance of K-dimensional functional principal component analysis (fPCA) scores
are the same, and thus a Hotelling <code class="reqn">T^2</code> test with assuming equal variance of the shrinkage scores
is a valid test. However, Koner and Luo (2023) pointed out that under the alternate hypothesis,
when the difference is mean is significant, the covariance of the shrinkage scores also differ
between the groups. Therefore, while computing the power of test, we must have to derive the
distribution of the Hotelling <code class="reqn">T^2</code> statistic under the assumption of unequal variance. The
alogrithm for the power of multivariate Hotelling <code class="reqn">T^2</code> under unequal variance
is coded in <code>pHotellingT()</code> function. This particular function is a wrapper around that
function, which inputs the mean difference as a function, and the eigenfunctions and
the scores, and subsequently call the <code>pHotellingT()</code> function to compute the power
under unequal variance. See Koner and Luo (2023) for more details on the
formula of the non-null distribution.
</p>


<h3>Value</h3>

<p>Power of the projection-based test for specified difference in the mean function
and the eigencomponents of the covariance of the functional data.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Wang, Qiyao (2021)
<em>Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423</em> <br><a href="https://doi.org/10.1214/21-EJS1802">doi:10.1214/21-EJS1802</a>.
</p>


<h3>See Also</h3>

<p>See <code>pHotellingT()</code> and <code>Sim_HotellingT_unequal_var()</code> for samples
from Hotelling T distribution.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
ngrid          &lt;- 101
interval       &lt;- c(-1,1)
gauss.quad.pts &lt;- gss::gauss.quad(ngrid,interval) # evaluation points
working.grid   &lt;- gauss.quad.pts$pt
mean_fn        &lt;- function(t) {0.4*sin(2*pi*t)}
mean_vector    &lt;- mean_fn(working.grid)
eigen_fn       &lt;- function(t, k){ sqrt(2)*{(k==2)*sin(2*pi*t) + (k==1)*cos(2*pi*t)} }
eigen_matrix   &lt;- cbind(eigen_fn(working.grid,1), eigen_fn(working.grid,2))
mean_proj      &lt;- sapply(1:2, function(r) integrate(function(x)
eigen_fn(x,r)*mean_fn(x), interval[1], interval[2])$value)
sig1           &lt;- diag(2)
sig2           &lt;- 2*diag(2)
alp            &lt;- 0.05
n              &lt;- 100
k              &lt;- ncol(eigen_matrix)
cutoff         &lt;- {(n - 2)*k/(n - k -1)}*qf(1-alp, k, n-k-1)
func_power     &lt;- Power_Proj_Test_ufDA(total_sample_size=n,
argvals=working.grid,
mean_vector = mean_vector, eigen_matrix = eigen_matrix,
scores_var1 = sig1, scores_var2= sig2, weights = gauss.quad.pts$wt,
sig.level=alp, alloc.ratio = c(1,1), npc_to_pick=ncol(eigen_matrix),
nsim = 5e3)

</code></pre>


</div>