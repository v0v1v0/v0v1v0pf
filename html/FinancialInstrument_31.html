<div class="container">

<table style="width: 100%;"><tr>
<td>fn_SpreadBuilder</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate prices of a spread from 2 instruments.</h2>

<h3>Description</h3>

<p>Given 2 products, calculate spread values for as many columns as practicable.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fn_SpreadBuilder(prod1, prod2, ratio = 1, currency = "USD", from = NULL,
  to = NULL, session_times = NULL, notional = TRUE,
  unique_method = c("make.index.unique", "duplicated", "least.liq",
  "price.change"), silent = FALSE, auto.assign = TRUE, env = .GlobalEnv,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>prod1</code></td>
<td>
<p>chr name of instrument that will be the 1st leg of a 2 leg 
spread (Can also be xts data for first product)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prod2</code></td>
<td>
<p>chr name of instrument that will be the 2nd leg of a 2 leg 
spread (Can also be xts data for second product)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>Hedge ratio. Can be a single number, or a vector of same length 
as data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>currency</code></td>
<td>
<p>chr name of currency denomination of the spread</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>from Date to pass through to getSymbols if needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>to Date to pass through to getSymbols if needed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>session_times</code></td>
<td>
<p>ISO-8601 time subset for the session time, in GMT, in 
the format 'T08:00/T14:59'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notional</code></td>
<td>
<p>TRUE/FALSE. Should the prices be multiplied by contract 
multipliers before calculating the spread?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique_method</code></td>
<td>
<p>method for making the time series unique</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>silence warnings? (FALSE by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>auto.assign</code></td>
<td>
<p>If <code>TRUE</code> (the default) the constructed spread will 
be stored in symbol created with <code>make_spread_id</code>. instrument 
metadata will also be created and stored with the same primary_id.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>If <code>prod1</code> and <code>prod1</code> are character, this is where to 
<code>get</code> the data.  Also, if <code>auto.assign</code> is <code>TRUE</code> this is 
the environment in which to store the data (.GlobalEnv by default)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>other arguments to pass to <code>getSymbols</code> and/or 
<code>make_spread_id</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>prod1</code> and <code>prod2</code> can be the names of instruments, or the xts 
objects themselves. Alternatively, <code>prod2</code> can be omitted, and a vector 
of 2 instrument names can be given to <code>prod1</code>. See the last example for 
this usage.
</p>
<p>If <code>prod1</code> and <code>prod2</code> are names (not xts data), it will try to get 
data for <code>prod1</code> and <code>prod2</code> from <code>env</code> (.GlobalEnv by 
default).  If it cannot find the data, it will get it with a call to 
getSymbols. Prices are multiplied by multipliers and exchange rates to get 
notional values in the currency specified.  The second leg's notional values 
are multiplied by <code>ratio</code>.  Then the difference is taken between the 
notionals of leg1 and the new values for leg2.
</p>
<p>‘make.index.unique’ uses the xts function <code>make.index.unique</code> 
‘least.liq’ subsets the spread time series, by using the timestamps 
of the leg that has the fewest rows.
‘duplicated’ removes any duplicate indexes.
‘price.change’ only return rows where there was a price change in the 
Bid, Mid or Ask Price of the spread.
</p>


<h3>Value</h3>

<p>an xts object with
Bid, Ask, Mid columns, 
or Open, Close, Adjusted columns, 
or Open, Close columns.
or Price column.
</p>


<h3>Note</h3>

<p>requires quantmod
</p>


<h3>Author(s)</h3>

<p>Lance Levenson, Brian Peterson, Garrett See
</p>


<h3>See Also</h3>

<p><code>buildSpread</code>
<code>synthetic.instrument</code>
<code>formatSpreadPrice</code>
<code>buildRatio</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
currency("USD")
stock("SPY", "USD")
stock("DIA", "USD")
getSymbols(c("SPY","DIA"))

#can call with names of instrument/xts ojects
fSB &lt;- fn_SpreadBuilder("SPY","DIA") 
fSB2 &lt;- fn_SpreadBuilder(SPY,DIA) # or you can pass xts objects

#assuming you first somehow calculated the ratio to be a constant 1.1
fSB3 &lt;- fn_SpreadBuilder("SPY","DIA",1.1) 
head(fSB)

# Call fn_SpreadBuilder with vector of 2 instrument names
# in 1 arg instead of using both prod1 and prod2.
fSB4 &lt;- fn_SpreadBuilder(c("SPY","DIA"))
#download data and plot the closing values of a spread in one line
chartSeries(Cl(fn_SpreadBuilder(getSymbols(c("SPY","DIA")),auto.assign=FALSE)))

## End(Not run)
</code></pre>


</div>