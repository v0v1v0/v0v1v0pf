<div class="container">

<table style="width: 100%;"><tr>
<td>GetCovSurface</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Covariance Surface</h2>

<h3>Description</h3>

<p>Covariance surface estimation for dense or sparse functional data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">GetCovSurface(Ly, Lt, optns = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Ly</code></td>
<td>
<p>A list of <em>n</em> vectors containing the observed values for each individual. Missing values specified by <code>NA</code>s are supported for dense case (<code>dataType='Dense'</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lt</code></td>
<td>
<p>A list of <em>n</em> vectors containing the observation time points for each individual corresponding to y. Each vector should be sorted in ascending order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optns</code></td>
<td>
<p>A list of options control parameters specified by <code>list(name=value)</code>. See ‘Details’.
</p>
<p>Available control options are 
</p>

<dl>
<dt>userBwCov</dt>
<dd>
<p>The bandwidth value for the smoothed covariance function; positive numeric - default: determine automatically based on 'methodBwCov'</p>
</dd>
<dt>methodBwCov</dt>
<dd>
<p>The bandwidth choice method for the smoothed covariance function; 'GMeanAndGCV' (the geometric mean of the GCV bandwidth and the minimum bandwidth),'CV','GCV' - default: 10% of the support</p>
</dd>
<dt>userBwMu</dt>
<dd>
<p>The bandwidth value for the smoothed mean function (using 'CV' or 'GCV'); positive numeric - default: determine automatically based on 'methodBwMu'</p>
</dd>
<dt>methodBwMu</dt>
<dd>
<p>The bandwidth choice method for the mean function; 'GMeanAndGCV' (the geometric mean of the GCV bandwidth and the minimum bandwidth),'CV','GCV' - default: 5% of the support</p>
</dd> 
<dt>dataType</dt>
<dd>
<p>The type of design we have (usually distinguishing between sparse or dense functional data); 'Sparse', 'Dense', 'DenseWithMV', 'p&gt;&gt;n' - default:  determine automatically based on 'IsRegular'</p>
</dd>
<dt>error</dt>
<dd>
<p>Assume measurement error in the dataset; logical - default: TRUE</p>
</dd>
<dt>kernel</dt>
<dd>
<p>Smoothing kernel choice, common for mu and covariance; "rect", "gauss", "epan", "gausvar", "quar" - default: "gauss"; dense data are assumed noise-less so no smoothing is performed. </p>
</dd>
<dt>kFoldMuCov</dt>
<dd>
<p>The number of folds to be used for mean and covariance smoothing. Default: 10</p>
</dd>
<dt>lean</dt>
<dd>
<p>If TRUE the 'inputData' field in the output list is empty. Default: FALSE</p>
</dd>
<dt>methodMuCovEst</dt>
<dd>
<p>The method to estimate the mean and covariance in the case of dense functional data; 'cross-sectional', 'smooth' - default: 'cross-sectional'</p>
</dd>
<dt>nRegGrid</dt>
<dd>
<p>The number of support points in each direction of covariance surface; numeric - default: 51</p>
</dd>
<dt>numBins</dt>
<dd>
<p>The number of bins to bin the data into; positive integer &gt; 10, default: NULL</p>
</dd>
<dt>rotationCut</dt>
<dd>
<p>The 2-element vector in [0,1] indicating the percent of data truncated during sigma^2 estimation; default  (0.25, 0.75))</p>
</dd>
<dt>useBinnedData</dt>
<dd>
<p>Should the data be binned? 'FORCE' (Enforce the # of bins), 'AUTO' (Select the # of  bins automatically), 'OFF' (Do not bin) - default: 'AUTO'</p>
</dd>
<dt>useBinnedCov</dt>
<dd>
<p>Whether to use the binned raw covariance for smoothing; logical - default:TRUE</p>
</dd>
<dt>userMu</dt>
<dd>
<p>The user-defined smoothed mean function; list of two numerical vector 't' and 'mu' of equal size, 't' must cover the support defined 'Ly' - default: NULL</p>
</dd>
<dt>userSigma2</dt>
<dd>
<p>The user-defined measurement error variance. A positive scalar. If specified then no regularization is used (rho is set to 'no', unless specified otherwise). Default to 'NULL'</p>
</dd>
<dt>useBW1SE</dt>
<dd>
<p>Pick the largest bandwidth such that CV-error is within one Standard Error from the minimum CV-error, relevant only if methodBwMu ='CV' and/or methodBwCov ='CV'; logical - default: FALSE</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>A square matrix of size nWorkGrid containing the covariance surface estimate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2</code></td>
<td>
<p>A numeric estimate of the variance of measurement error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workGrid</code></td>
<td>
<p>A vector of length nWorkGrid. The internal regular grid on which the covariance surface estimation is carried out.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bwCov</code></td>
<td>
<p>The selected (or user specified) bandwidth for smoothing thecovariance surface.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optns</code></td>
<td>
<p>A list of actually-used options relevant to the covariance surface calculation.</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">set.seed(1)
n &lt;- 20
pts &lt;- seq(0, 1, by=0.025)
sampWiener &lt;- Wiener(n, pts)
mu = sin(2*pi*pts)
sampWiener &lt;- Sparsify(t(t(sampWiener) + mu), pts, 10)
res = GetCovSurface(Ly = sampWiener$Ly, Lt = sampWiener$Lt)
</code></pre>


</div>