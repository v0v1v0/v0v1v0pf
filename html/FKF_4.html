<div class="container">

<table style="width: 100%;"><tr>
<td>fks</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Kalman Smoother</h2>

<h3>Description</h3>

<p>This function can be run after running <code>fkf</code> to produce
"smoothed" estimates of the state variable <code class="reqn">\alpha_t</code>.
Unlike the output of the filter, these estimates are conditional
on the entire set of <code class="reqn">n</code> data points rather than only the past, see details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fks(FKFobj)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>FKFobj</code></td>
<td>
<p>An S3-object of class "fkf", returned by <code>fkf</code>.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The following notation is taken from the <code>fkf</code> function descriptions
and is close to the one of Koopman et al. The smoother estimates
</p>
<p style="text-align: center;"><code class="reqn">a_{t|n} = E[\alpha_{t} | y_1,\ldots,y_n]</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t|n} = Var[\alpha_{t} | y_1,\ldots,y_n]</code>
</p>

<p>based on the outputs of the forward filtering pass performed by <code>fkf</code>.
</p>
<p>The formulation of Koopman and Durbin is used which evolves the two values
<code class="reqn">r_{t} \in R^m</code> and <code class="reqn">N_{t} \in R^{m \times m}</code>
to avoid inverting the covariance matrix.
</p>
<p><strong>Iteration:</strong>
</p>
<p>If there are no missing values the iteration proceeds as follows:
</p>
<p>Initialisation: Set <code class="reqn">t=n</code>, with <code class="reqn">r_t =0</code> and <code class="reqn">N_t =0</code>.
</p>
<p>Evolution equations:
</p>
<p style="text-align: center;"><code class="reqn">L = T_{t} - T_{t}K_{t}Z_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">r_{t-1} = Z_{t}^\prime F_{t}^{-1} v_{t} + L^\prime r_{t}</code>
</p>

<p style="text-align: center;"><code class="reqn">N_{t-1} = Z_{t}^\prime F_{t}^{-1} Z_{t} + L^\prime N_{t} L</code>
</p>

<p>Updating equations:
</p>
<p style="text-align: center;"><code class="reqn">a_{t|n} = a_{t|t-1} + P_{t|t-1}r_{t-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">P_{t|n} = P_{t|t-1} - P_{t|t-1}N_{t-1}P_{t|t-1}</code>
</p>

<p>Next iteration: Set <code class="reqn">t=t-1</code> and goto “Evolution equations”.
</p>


<h3>Value</h3>

<p>An S3-object of class "fks" which is a list with the following elements:
</p>
<p><code>ahatt</code>  A <code class="reqn">m \times n</code>-matrix containing the
smoothed state variables, i.e. ahatt[,t] = <code class="reqn">a_{t|n}</code><br><code>Vt</code>  A <code class="reqn">m \times m \times n</code>-array
containing the variances of <code>ahatt</code>, i.e. Vt[,,t] = <code class="reqn">P_{t|n}</code><br></p>


<h3>References</h3>

<p>Koopman, S. J. and Durbin, J. (2000). <em>Fast filtering and smoothing for multivariate state space models</em> Journal of Time Series Analysis Vol. 21, No. 3
</p>


<h3>Examples</h3>

<pre><code class="language-R">## &lt;---------------------------------------------------------------------------&gt;
## Example: Local level model for the Nile's annual flow.
## &lt;---------------------------------------------------------------------------&gt;
## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

y &lt;- Nile
y[c(3, 10)] &lt;- NA  # NA values can be handled

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- matrix(1)
a0 &lt;- y[1]            # Estimation of the first year flow
P0 &lt;- matrix(100)     # Variance of 'a0'

## Estimate parameters:
fit.fkf &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                   GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                   -fkf(HHt = matrix(par[1]), GGt = matrix(par[2]), ...)$logLik,
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

## Filter Nile data with estimated parameters:
fkf.obj &lt;- fkf(a0, P0, dt, ct, Tt, Zt, HHt = matrix(fit.fkf$par[1]),
               GGt = matrix(fit.fkf$par[2]), yt = rbind(y))

## Smooth the data based on the filter object
fks.obj &lt;- fks(fkf.obj)

## Plot the flow data together with local levels:
plot(y, main = "Nile flow")
lines(ts(fkf.obj$att[1, ], start = start(y), frequency = frequency(y)), col = "blue")
lines(ts(fks.obj$ahatt[1,], start = start(y), frequency = frequency(y)), col = "red")
legend("top", c("Nile flow data", "Local level (fkf)","Local level (fks)"),
       col = c("black", "green", "blue", "red"), lty = 1)

</code></pre>


</div>