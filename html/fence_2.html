<div class="container">

<table style="width: 100%;"><tr>
<td>adaptivefence.fh</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Adaptive Fence model selection (Small Area Estmation)</h2>

<h3>Description</h3>

<p>Adaptive Fence model selection (Small Area Estmation)
</p>


<h3>Usage</h3>

<pre><code class="language-R">adaptivefence.fh(mf, f, ms, d, lf, pf, bs, grid = 101, bandwidth, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mf</code></td>
<td>
<p>Call function, for example: default calls: function(m, b) eblupFH(formula = m, vardir = D, data = b, method = "FH")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>Full Model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ms</code></td>
<td>
<p>find candidate model, findsubmodel.fh(full)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>Dimension number</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lf</code></td>
<td>
<p>Measures lack of fit using function(res) -res$fit$goodness[1]</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>
<p>Dimensions of model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bs</code></td>
<td>
<p>Bootstrap</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>grid for c</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>bandwidth for kernel smooth function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Method to be used. Fay-Herriot method is the default.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>In Jiang et. al (2008), the adaptive c value is chosen from the highest peak in the p* vs. c plot.  
In Jiang et. al (2009), 95% CI is taken into account while choosing such an adaptive choice of c.
In Thuan Nguyen et. al (2014), the adaptive c value is chosen from the first peak. This approach works better in the 
moderate sample size or weak signal situations.  Empirically, the first peak becomes highest peak when sample size 
increases or signals become stronger
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>models</code></td>
<td>
<p>list all model candidates in the model space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>list the number of bootstrap samples that have been used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lack_of_fit_matrix</code></td>
<td>
<p>list a matrix of Qs for all model candidates (in columns). Each row is for each bootstrap sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Qd_matrix</code></td>
<td>
<p>list a matrix of QM - QM.tilde for all model candidates. Each row is for each bootrap sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bandwidth</code></td>
<td>
<p>list the value of bandwidth</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model_mat</code></td>
<td>
<p>list a matrix of selected models at each c values in grid (in columns). Each row is for each bootstrap sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq_mat</code></td>
<td>
<p>list a matrix of coverage probabilities (frequency/smooth_frequency) of each selected models for a given c value (index)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>list the adaptive choice of c value from which the parsimonious model is selected</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sel_model</code></td>
<td>
<p>list the selected (parsimonious) model given the adaptive c value</p>
</td>
</tr>
</table>
<h3>Note</h3>


<ul>
<li>
<p>The current Fence package focuses on variable selection. 
However, Fence methods can be used to select other parameters of interest, e.g., tunning parameter, variance-covariance structure, etc.
</p>
</li>
<li>
<p>The number of bootstrap samples is suggested to be increased, e.g., B=1000 when the sample size is small, or signals are weak
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Jiming Jiang  Jianyang Zhao  J. Sunil Rao  Thuan Nguyen
</p>


<h3>References</h3>


<ul>
<li>
<p>Jiang J., Rao J.S., Gu Z., Nguyen T. (2008),  Fence Methods for Mixed Model Selection. The Annals of Statistics, 36(4): 1669-1692
</p>
</li>
<li>
<p>Jiang J., Nguyen T., Rao J.S. (2009), A Simplified Adaptive Fence Procedure. Statistics and Probability Letters, 79, 625-629
</p>
</li>
<li>
<p>Thuan Nguyen, Jie Peng, Jiming Jiang (2014), Fence Methods for Backcross Experiments.  Statistical Computation and Simulation, 84(3), 644-662
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
require(fence)
### example 1 ####
data("kidney")
data = kidney[-which.max(kidney$x),]     # Delete a suspicious data point #
data$x2 = data$x^2
data$x3 = data$x^3
data$x4 = data$x^4
data$D = data$sqrt.D.^2
plot(data$y ~ data$x)
full = y~x+x2+x3+x4
testfh = fence.sae(full, data, B=1000, fence="adaptive", method="F-H", D = D)
testfh$sel_model
testfh$c

## End(Not run)
</code></pre>


</div>