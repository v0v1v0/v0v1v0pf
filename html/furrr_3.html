<div class="container">

<table style="width: 100%;"><tr>
<td>furrr_options</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Options to fine tune furrr</h2>

<h3>Description</h3>

<p>These options fine tune furrr functions, such as <code>future_map()</code>. They
are either used by furrr directly, or are passed on to <code>future::future()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">furrr_options(
  ...,
  stdout = TRUE,
  conditions = "condition",
  globals = TRUE,
  packages = NULL,
  seed = FALSE,
  scheduling = 1,
  chunk_size = NULL,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are reserved for future extensibility and must
be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stdout</code></td>
<td>
<p>A logical.
</p>

<ul>
<li>
<p> If <code>TRUE</code>, standard output of the underlying futures is relayed as soon
as possible.
</p>
</li>
<li>
<p> If <code>FALSE</code>, output is silenced by sinking it to the null device.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditions</code></td>
<td>
<p>A character string of conditions classes to be relayed.
The default is to relay all conditions, including messages and warnings.
Errors are always relayed. To not relay any conditions (besides errors),
use <code>conditions = character()</code>. To selectively ignore specific classes,
use <code>conditions = structure("condition", exclude = "message")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globals</code></td>
<td>
<p>A logical, a character vector, a named list, or <code>NULL</code> for
controlling how globals are handled. For details, see the
<code style="white-space: pre;">⁠Global variables⁠</code> section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>packages</code></td>
<td>
<p>A character vector, or <code>NULL</code>. If supplied, this specifies
packages that are guaranteed to be attached in the R environment where the
future is evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A logical, an integer of length <code>1</code> or <code>7</code>, a list of
<code>length(.x)</code> with pre-generated random seeds, or <code>NULL</code>. For details, see
the <code style="white-space: pre;">⁠Reproducible random number generation (RNG)⁠</code> section below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scheduling</code></td>
<td>
<p>A single integer, logical, or <code>Inf</code>. This argument
controls the average number of futures ("chunks") per worker.
</p>

<ul>
<li>
<p> If <code>0</code>, then a single future is used to process all elements of <code>.x</code>.
</p>
</li>
<li>
<p> If <code>1</code> or <code>TRUE</code>, then one future per worker is used.
</p>
</li>
<li>
<p> If <code>2</code>, then each worker will process two futures (provided there
are enough elements in <code>.x</code>).
</p>
</li>
<li>
<p> If <code>Inf</code> or <code>FALSE</code>, then one future per element of <code>.x</code> is used.
</p>
</li>
</ul>
<p>This argument is only used if <code>chunk_size</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunk_size</code></td>
<td>
<p>A single integer, <code>Inf</code>, or <code>NULL</code>. This argument
controls the average number of elements per future (<code>"chunk"</code>). If <code>Inf</code>,
then all elements are processed in a single future. If <code>NULL</code>, then
<code>scheduling</code> is used instead to determine how <code>.x</code> is chunked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefix</code></td>
<td>
<p>A single character string, or <code>NULL</code>. If a character string,
then each future is assigned a label as <code>{prefix}-{chunk-id}</code>. If <code>NULL</code>,
no labels are used.</p>
</td>
</tr>
</table>
<h3>Global variables</h3>

<p><code>globals</code> controls how globals are identified, similar to the <code>globals</code>
argument of <code>future::future()</code>. Since all function calls use the same set of
globals, furrr gathers globals upfront (once), which is more efficient than
if it was done for each future independently.
</p>

<ul>
<li>
<p> If <code>TRUE</code> or <code>NULL</code>, then globals are automatically identified and
gathered.
</p>
</li>
<li>
<p> If a character vector of names is specified, then those globals are
gathered.
</p>
</li>
<li>
<p> If a named list, then those globals are used as is.
</p>
</li>
<li>
<p> In all cases, <code>.f</code> and any <code>...</code> arguments are automatically passed as
globals to each future created, as they are always needed.
</p>
</li>
</ul>
<h3>Reproducible random number generation (RNG)</h3>

<p>Unless <code>seed = FALSE</code>, furrr functions are guaranteed to generate
the exact same sequence of random numbers <em>given the same initial
seed / RNG state</em> regardless of the type of futures and scheduling
("chunking") strategy.
</p>
<p>Setting <code>seed = NULL</code> is equivalent to <code>seed = FALSE</code>, except that the
<code>future.rng.onMisuse</code> option is not consulted to potentially monitor the
future for faulty random number usage. See the <code>seed</code> argument of
<code>future::future()</code> for more details.
</p>
<p>RNG reproducibility is achieved by pre-generating the random seeds for all
iterations (over <code>.x</code>) by using L'Ecuyer-CMRG RNG streams. In each
iteration, these seeds are set before calling <code>.f(.x[[i]], ...)</code>.
<em>Note, for large <code>length(.x)</code> this may introduce a large overhead.</em>
</p>
<p>A fixed <code>seed</code> may be given as an integer vector, either as a full
L'Ecuyer-CMRG RNG seed of length <code>7</code>, or as a seed of length <code>1</code> that
will be used to generate a full L'Ecuyer-CMRG seed.
</p>
<p>If <code>seed = TRUE</code>, then <code>.Random.seed</code> is returned if it holds a
L'Ecuyer-CMRG RNG seed, otherwise one is created randomly.
</p>
<p>If <code>seed = NA</code>, a L'Ecuyer-CMRG RNG seed is randomly created.
</p>
<p>If none of the function calls <code>.f(.x[[i]], ...)</code> use random number
generation, then <code>seed = FALSE</code> may be used.
</p>
<p>In addition to the above, it is possible to specify a pre-generated
sequence of RNG seeds as a list such that <code>length(seed) == length(.x)</code> and
where each element is an integer seed that can be assigned to <code>.Random.seed</code>.
Use this alternative with caution. <em>Note that <code>as.list(seq_along(.x))</code> is
not a valid set of such <code>.Random.seed</code> values.</em>
</p>
<p>In all cases but <code>seed = FALSE</code>, after a furrr function returns, the RNG
state of the calling R process is guaranteed to be "forwarded one step" from
the RNG state before the call. This is true regardless of the future
strategy / scheduling used. This is done in order to guarantee that an R
script calling <code>future_map()</code> multiple times should be numerically
reproducible given the same initial seed.
</p>


<h3>Examples</h3>

<pre><code class="language-R">furrr_options()
</code></pre>


</div>