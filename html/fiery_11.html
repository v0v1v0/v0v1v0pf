<div class="container">

<table style="width: 100%;"><tr>
<td>loggers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>App Logging</h2>

<h3>Description</h3>

<p><code>fiery</code> has a build in logging mechanism that lets you capture event
information however you like. Every user-injested warnings and errors are
automatically captured by the logger along with most system errors as well.
<code>fiery</code> tries very hard not to break due to faulty app logic. This means that
any event handler error will be converted to an error log without <code>fiery</code>
stopping. In the case of request handlers a 500L response will be send back
if any error is encountered.
</p>


<h3>Usage</h3>

<pre><code class="language-R">logger_null()

logger_console(format = "{time} - {event}: {message}")

logger_file(file, format = "{time} - {event}: {message}")

logger_switch(..., default = logger_null())

common_log_format

combined_log_format
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>format</code></td>
<td>
<p>A glue string specifying the format of the log entry</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>A file or connection to write to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>A named list of loggers to use for different events. The same
semantics as switch is used so it is possible to let events
<em>fall through</em> e.g. <code>logger_switch(error =, warning = logger_file('errors.log'))</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default</code></td>
<td>
<p>A catch-all logger for use with events not defined in <code>...</code></p>
</td>
</tr>
</table>
<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>
<p>An object of class <code>character</code> of length 1.
</p>


<h3>Setting a logger</h3>

<p>By default, <code>fiery</code> uses <code>logger_null()</code> which forwards warning and error
messages to <code>stderr()</code> and ignores any other logging events. To change this
behavior, set a different logger using the <code>set_logger()</code> method:
</p>
<div class="sourceCode"><pre>app$set_logger(logger)
</pre></div>
<p>where <code>logger</code> is a function taking at least the following arguments: <code>event</code>,
<code>message</code>, <code>request</code>, <code>time</code>, and <code>...</code>.
</p>
<p><code>fiery</code> comes with some additional loggers, which either writes all logs to a
file or to the console. A new instance of the file logger can be created with
<code>logger_file(file)</code>:
</p>
<div class="sourceCode"><pre>app$set_logger(logger_file('fiery_log.log'))
</pre></div>
<p>A new instance of the console logger can be create with <code>logger_console()</code>:
</p>
<div class="sourceCode"><pre>app$set_logger(logger_console())
</pre></div>
<p>Both functions takes a <code>format</code> a argument that lets you customise how the
log is written. Furthermore the console logger will style the logs with
colour coding depending on the content if the console supports it.
</p>
<p>As a last possibility it is possible to use different loggers dependent on
the event by using the switch logger:
</p>
<div class="sourceCode"><pre>app$set_logger(logger_switch(warning =, 
                             error = logger_file('errors.log),
                             default = logger_file('info.log')))
</pre></div>


<h3>Automatic logs</h3>

<p><code>fiery</code> logs a number of different information by itself describing its
operations during run. The following events are send to the log:
</p>

<dl>
<dt><em>start</em></dt>
<dd>
<p>Will be send when the server starts up</p>
</dd>
<dt><em>resume</em></dt>
<dd>
<p>Will be send when the server is resumed</p>
</dd>
<dt><em>stop</em></dt>
<dd>
<p>Will be send when the server stops</p>
</dd>
<dt><em>request</em></dt>
<dd>
<p>Will be send when a request has been handled. The message
will contain information about how long time it took to handle the request
or if it was denied.</p>
</dd>
<dt><em>websocket</em></dt>
<dd>
<p>Will be send every time a WebSocket connection is
established or closed as well as when a message is received or send</p>
</dd>
<dt><em>message</em></dt>
<dd>
<p>Will be send every time a message is emitted by an event
handler or delayed execution handler</p>
</dd>
<dt><em>warning</em></dt>
<dd>
<p>Will be send everytime a warning is emitted by an event
handler or delayed execution handler</p>
</dd>
<dt><em>error</em></dt>
<dd>
<p>Will be send everytime an error is signaled by an event
handler or delayed execution handler. In addition some internal functions
will also emit error event when exceptions are encountered</p>
</dd>
</dl>
<p>By default only <em>message</em>, <em>warning</em> and <em>error</em> events will be logged by
sending them to the error stream as a <code>message()</code>.
</p>


<h3>Access Logs</h3>

<p>Of particular interest are logs that detail requests made to the server.
These are the <code>request</code> events detailed above. There are different standards
for how requests are logged. <code>fiery</code> uses the <em>Common Log Format</em> by default,
but this can be modified by setting the <code>access_log_format</code> field to a
glue expression that has access to the following variables:
</p>

<dl>
<dt><code>start_time</code></dt>
<dd>
<p>The time the request was recieved</p>
</dd>
<dt><code>end_time</code></dt>
<dd>
<p>The time the response was send back</p>
</dd>
<dt><code>request</code></dt>
<dd>
<p>The <code>Request</code> object</p>
</dd>
<dt><code>response</code></dt>
<dd>
<p>The <code>Response</code> object</p>
</dd>
<dt><code>id</code></dt>
<dd>
<p>The client id</p>
</dd>
</dl>
<p>To change the format:
</p>
<div class="sourceCode"><pre>app$access_log_format &lt;- combined_log_format
</pre></div>


<h3>Custom logs</h3>

<p>Apart from the standard logs described above it is also possible to send
messages to the log as you please, e.g. inside event handlers. This is done
through the <code>log()</code> method where you at the very least specify an event and a
message. In general it is better to send messages through <code>log()</code> rather than
with <code>warning()</code> and <code>stop()</code> even though the latters will eventually be
caught, as it gives you more control over the logging and what should happen
in the case of an exception.
</p>
<p>An example of using <code>log()</code> in a handler could be:
</p>
<div class="sourceCode"><pre>app$on('header', function(server, id, request) {
  server$log('info', paste0('request from ', id, ' received'), request)
})
</pre></div>
<p>Which would log the timepoint the headers of a request has been recieved.
</p>


</div>