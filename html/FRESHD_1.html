<div class="container">

<table style="width: 100%;"><tr>
<td>maximin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Maximin signal estimation</h2>

<h3>Description</h3>

<p>Efficient procedure for solving the maximin estimation problem 
with identical design across groups, see (Lund, 2022).
</p>


<h3>Usage</h3>

<pre><code class="language-R">maximin(y,
        x,
        penalty = "lasso", 
        alg ="aradmm",
        kappa = 0.99,
        nlambda = 30,
        lambda_min_ratio = 1e-04,
        lambda = NULL,
        penalty_factor = NULL,
        standardize = TRUE,
        tol = 1e-05,
        maxiter = 1000,
        delta = 1,
        gamma = 1,
        eta = 0.1,
        aux_par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Array of size <code class="reqn">n_1 \times\cdots\times n_d \times G</code> containing
the response values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Either i) the design matrix, ii) a list containing the Kronecker
components (2 or 3) if  the design matrix has Kronecker structure or iii) a 
string indicating the name of the wavelet to use (see <code>wt</code> for options)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>string specifying the penalty type. Possible values are
<code>"lasso"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alg</code></td>
<td>
<p>string specifying the optimization algorithm. Possible values are
<code>"admm", "aradmm", "tos", "tosacc"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kappa</code></td>
<td>
<p>Strictly positive float controlling the maximum sparsity in the 
solution. Only used with  ADMM type algorithms. Should be between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>Positive integer giving the number of <code>lambda</code> values.
Used when lambda is not specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_min_ratio</code></td>
<td>
<p>strictly positive float giving the smallest value for
<code>lambda</code>, as a fraction of <code class="reqn">\lambda_{max}</code>; the (data dependent) 
smallest value for which all coefficients are zero. Used when lambda is not 
specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Sequence of strictly positive floats used as penalty parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty_factor</code></td>
<td>
<p>A vector of length <code class="reqn">p</code> containing positive floats that are 
multiplied with each element in <code>lambda</code> to allow differential penalization 
on the coefficients. For tensor models an array of size <code class="reqn">p_1 \times \cdots \times p_d</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>Boolean indicating if response <code>y</code> should be scaled. 
Default is TRUE to avoid numerical problems.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>Strictly positive float controlling the convergence tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Positive integer giving the maximum number of iterations
allowed for each <code>lambda</code> value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Positive float controlling the step size in the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>Positive float controlling the relaxation parameter in the 
algorithm. Should be between 0 and 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eta</code></td>
<td>
<p>Scaling parameter for the step size in the accelerated TOS algorithm. 
Should be between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aux_par</code></td>
<td>
<p>Auxiliary parameters for the algorithms.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For <code class="reqn">n</code> heterogeneous data points divided into <code class="reqn">G</code> equal sized
groups with <code class="reqn">m&lt;n</code> data points in each, let <code class="reqn">y_g=(y_{g,1},\ldots,y_{g,m})</code>
denote the vector  of observations in group <code class="reqn">g</code>. For a <code class="reqn">m\times p</code>
design matrix <code class="reqn">X</code> consider the model
</p>
<p style="text-align: center;"><code class="reqn">y_g=Xb_g+\epsilon_g</code>
</p>

<p>for <code class="reqn">b_g</code> a random group specific coefficient vector and <code class="reqn">\epsilon_g</code>
an error term, see Meinshausen and Buhlmann (2015). For the model above following 
Lund (2022) this package solves the maximin estimation problem
</p>
<p style="text-align: center;"><code class="reqn">\min_{\beta} -\hat V_g(\beta)) + \lambda\Vert\beta\Vert_1,\lambda \ge 0</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat V_g(\beta):=\frac{1}{n}(2\beta^\top X^\top y_g - \beta^\top X^\top X\beta),</code>
</p>

<p>is the empirical explained variance in group <code class="reqn">g</code>. See <cite>Lund, 2022</cite>
for more details and references.
</p>
<p>The package solves the problem using different algorithms depending on <code class="reqn">X</code>:
</p>
<p>i) If <code class="reqn">X</code> is orthogonal (e.g. the inverse wavelet transform) either
an ADMM algorithm (standard or relaxed) or an adaptive relaxed
ADMM (ARADMM) with auto tuned step size is used, see Xu et al (2017).
</p>
<p>ii) For general <code class="reqn">X</code>, a three operator splitting (TOS) algorithm
is implemented, see Damek and Yin (2017). Note if  the design is 
tensor structured, <code class="reqn">X = \bigotimes_{i=1}^d X_i</code> for <code class="reqn">d\in\{1, 2,3\}</code>, 
the procedure  accepts a list containing the tensor components (matrices).
</p>


<h3>Value</h3>

<p>An object with S3 Class "FRESHD".
</p>
<table>
<tr style="vertical-align: top;">
<td><code>spec</code></td>
<td>
<p>A string indicating the array dimension (1, 2 or 3) and the penalty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>A <code class="reqn">p_1\cdots p_d \times</code> <code>nlambda</code> matrix containing the
estimates of the model coefficients (<code>beta</code>) for each <code>lambda</code>-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A vector containing the sequence of penalty values used in the
estimation procedure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimcoef</code></td>
<td>
<p>A vector giving the dimension of the model coefficient array
<code class="reqn">\beta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimobs</code></td>
<td>
<p>A vector giving the dimension of the observation (response) array <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Integer indicating the dimension of of the array model. Equal to 1
for non array.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wf</code></td>
<td>
<p>A string indicating the wavelet name if used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostics</code></td>
<td>
<p>A list where item <code>iter</code> is a vector containing  the 
number of iterations for each <code>lambda</code> value for which the algorithm 
converged. Item <code>stop_maxiter</code> is 1 if maximum iterations is reached 
otherwise zero. Item <code>stop_sparse</code> is 1 if  maximum sparsity is reached 
otherwise zero.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Adam Lund
</p>
<p>Maintainer: Adam Lund, <a href="mailto:adam.lund@math.ku.dk">adam.lund@math.ku.dk</a>
</p>


<h3>References</h3>

<p>Lund, Adam (2022). Fast Robust Signal Estimation for Heterogeneous data.
<em>In preparation</em>.
</p>
<p>Meinshausen, N and P. Buhlmann (2015). Maximin effects in inhomogeneous large-scale data.
<em>The Annals of Statistics</em>. 43, 4, 1801-1830.
</p>
<p>Davis, Damek and Yin, Wotao, (2017). A three-operator splitting scheme and its
optimization applications. <em>Set-valued and variational analysis</em>. 25, 4,
829-858.
</p>
<p>Xu, Zheng and Figueiredo, Mario AT and Yuan, Xiaoming and Studer, Christoph and Goldstein, Tom
(2017). Adaptive relaxed admm: Convergence theory and practical implementation.
<em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>
7389-7398.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## general 3d tensor design matrix
set.seed(42)
G &lt;- 20; n &lt;- c(65, 26, 13)*3; p &lt;- c(13, 5, 4)*3
sigma &lt;- 1

##marginal design matrices (Kronecker components)
x &lt;- list()
for(i in 1:length(n)){x[[i]] &lt;- matrix(rnorm(n[i] * p[i], 0, sigma), n[i], p[i])}

##common features and effects
common_features &lt;- rbinom(prod(p), 1, 0.1)
common_effects &lt;- rnorm(prod(p), 0, 0.1) * common_features

##simulate group response
y &lt;- array(NA, c(n, G))
for(g in 1:G){
bg &lt;- rnorm(prod(p), 0, 0.1) * (1 - common_features) + common_effects
Bg &lt;- array(bg, p)
mu &lt;- RH(x[[3]], RH(x[[2]], RH(x[[1]], Bg)))
y[,,, g] &lt;- array(rnorm(prod(n), 0, var(mu)), dim = n) + mu
}

##fit model for range of lambda
system.time(fit &lt;- maximin(y, x, penalty = "lasso", alg = "tosacc"))

##estimated common effects for specific lambda
modelno &lt;- 10
betafit &lt;- fit$coef[, modelno]
plot(common_effects, type = "h", ylim = range(betafit, common_effects), col = "red")
lines(betafit, type = "h")

##size of example
set.seed(42)
G &lt;- 50; p &lt;- n &lt;- c(2^6, 2^5, 2^6);

##common features and effects
common_features &lt;- rbinom(prod(p), 1, 0.1) #sparsity of comm. feat.
common_effects &lt;- rnorm(prod(p), 0, 1) * common_features

##group response
y &lt;- array(NA, c(n, G))
for(g in 1:G){
bg &lt;- rnorm(prod(p), 0, 0.1) * (1 - common_features) + common_effects
Bg &lt;- array(bg, p)
mu &lt;- iwt(Bg)
y[,,, g] &lt;- array(rnorm(prod(n),0, 0.5), dim = n) + mu
}

##orthogonal wavelet design with 1d data
G = 50; N1 = 2^10; p = 101; J = 2; amp = 20; sigma2 = 10
y &lt;- matrix(0, N1, G)
z &lt;- seq(0, 2, length.out = N1)
sig &lt;- cos(10 * pi * z) + 1.5 * sin(5 * pi * z)

for (i in 1:G){
freqs &lt;- sample(1:100, size = J, replace = TRUE)
y[, i] &lt;- sig * 2 + rnorm(N1, sd = sqrt(sigma2))
for (j in 1:J){
y[, i] &lt;- y[, i] + amp * sin(freqs[j] * pi * z + runif(1, -pi, pi))
}
}

system.time(fit &lt;- maximin(y, "la8", alg = "aradmm", kappa = 0.9))
mmy &lt;- predict(fit, "la8")
plot(mmy[,1], type = "l")
lines(sig, col = "red")

</code></pre>


</div>