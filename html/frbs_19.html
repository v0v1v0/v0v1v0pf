<div class="container">

<table style="width: 100%;"><tr>
<td>frbs.gen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The frbs model generator</h2>

<h3>Description</h3>

<p>The purpose of this function is to generate a FRBS model from user-given 
input without a learning process.
</p>


<h3>Usage</h3>

<pre><code class="language-R">frbs.gen(range.data, num.fvalinput, names.varinput,
  num.fvaloutput = NULL, varout.mf = NULL, names.varoutput = NULL,
  rule, varinp.mf, type.model = "MAMDANI", type.defuz = "WAM",
  type.tnorm = "MIN", type.snorm = "MAX", func.tsk = NULL,
  colnames.var = NULL, type.implication.func = "ZADEH",
  name = "Sim-0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>range.data</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of the data, where <code class="reqn">n</code> is the number of variables, and
first and second rows are the minimum and maximum values, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.fvalinput</code></td>
<td>
<p>a matrix representing the number of linguistic terms of each input variables.
</p>
<p>For example: <code>num.fvalinput &lt;- matrix(c(3,2), nrow = 1)</code>
</p>
<p>means that there are two variables where the first variable has three linguistic terms and the second one has two linguistic terms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.varinput</code></td>
<td>
<p>a list containing names to the linguistic terms for input variables. See <code>rulebase</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num.fvaloutput</code></td>
<td>
<p>the number of linguistic terms of the output variable. This parameter is required for the Mamdani model only. 
</p>
<p>For example: <code>num.fvaloutput &lt;- matrix(3, nrow = 1)</code>
</p>
<p>means there are 3 linguistic terms for the output variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varout.mf</code></td>
<td>
<p>a matrix for constructing the membership functions of the output variable. 
The form is the same as for the <code>varinp.mf</code> parameter. This parameter is required for the Mamdani model only. 
See <code>fuzzifier</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names.varoutput</code></td>
<td>
<p>a list giving names of the linguistic terms for the output variable. The form is the same as 
for the <code>names.varinput</code> parameter. This parameter is required for the Mamdani model only. See <code>rulebase</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rule</code></td>
<td>
<p>a list of fuzzy IF-THEN rules. There are some types of rule structures, for example: Mamdani, Takagi Sugeno Kang,
and fuzzy rule-based classification systems (FRBCS). If we use the Mamdani model then the consequent part is a linguistic term,
but if we use Takagi Sugeno Kang then we build a matrix representing linear equations in the consequent part.
e.g., "a1", "and", "b1, "-&gt;", "e1" means that 
"IF inputvar.1 is a1 and inputvar.2 is b1 THEN outputvar.1 is e1". 
Make sure that each rule has a "-&gt;" sign.
Furthermore, we are allowed to use linguistic hedges (e.g., "extremely", "slightly", etc), negation (i.e., "not"),
and the "dont_care" value representing degree of membership is always 1. 
For more detail, see <code>rulebase</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>varinp.mf</code></td>
<td>
<p>a matrix for constructing the shapes of the membership functions. See how to construct it in <code>fuzzifier</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.model</code></td>
<td>
<p>the type of the model. There are three types available as follows. 
</p>

<ul>
<li> <p><code>MAMDANI</code> means we are using the Mamdani model. 
</p>
</li>
<li> <p><code>TSK</code> means we are using the Takagi Sugeno Kang model.
</p>
</li>
<li> <p><code>FRBCS</code> means we are using fuzzy rule-based classification systems (FRBCS).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.defuz</code></td>
<td>
<p>the type of the defuzzification method. It is used in the Mamdani model only. 
See <code>defuzzifier</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.tnorm</code></td>
<td>
<p>the type of the t-norm method. See <code>inference</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.snorm</code></td>
<td>
<p>the type of the s-norm method. See <code>inference</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func.tsk</code></td>
<td>
<p>a matrix of parameters of the function on the consequent part using the Takagi Sugeno Kang model. 
This parameter must be defined when we are using Takagi Sugeno Kang. See <code>rulebase</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colnames.var</code></td>
<td>
<p>a list of names of input and output variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.implication.func</code></td>
<td>
<p>a type of implication function. See <code>WM</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>a name of the simulation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It can be used if rules have already been obtained manually, without employing the 
learning process. 
In the examples shown, we generate a fuzzy model using <code>frbs.gen</code> and generate the
fuzzy rule-based systems step by step manually. Additionally, the examples show several scenarios as follows.
</p>

<ul>
<li>
<p> Using <code>frbs.gen</code> for constructing the Mamdani model on a regression task. 
</p>
</li>
<li>
<p> Using <code>frbs.gen</code> for constructing the Takagi Sugeno Kang model on a regression task.
</p>
</li>
<li>
<p> Constructing the Mamdani model by executing internal functions such as <code>rulebase</code>, <code>fuzzifier</code>,
<code>inference</code>, and <code>defuzzifier</code> for the Mamdani model.
</p>
</li>
<li>
<p> Using <code>frbs.gen</code> for constructing fuzzy rule-based classification systems (FRBCS) model.
</p>
</li>
</ul>
<h3>Value</h3>

<p>The <code>frbs-object</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#################################################
## 1. The following codes show how to generate a fuzzy model 
## using the frbs.gen function for regression tasks. 
## The following are three scenarios:
## 1a. Using the Mamdani model
## 1b. Using the Takagi Sugeno Kang model
## 1c. Using the Mamdani model and internal functions: fuzzifier, etc.
## Note:
## In the examples, let us consider four input variabels and one output variable.
## Some variables could be shared together for other examples.  
#################################################

## Define shape and parameters of membership functions of input variables.
## Please see the fuzzifier function to construct the matrix.
## It can be seen that in this case we employ TRAPEZOID as the membership functions.
varinp.mf &lt;- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA,
                      2, 0, 35, 75, NA, 3, 35, 75, 100, NA,
                      2, 0, 20, 40, NA, 1, 20, 50, 80, NA, 3, 60, 80, 100, NA,
                      2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
                      nrow = 5, byrow = FALSE)

## Define number of linguistic terms of the input variables.
## Suppose, we have 3, 2, 3, and 3 numbers of linguistic terms 
## for the first, second, third and fourth variables, respectively.
num.fvalinput &lt;- matrix(c(3, 2, 3, 3), nrow=1)

## Give the names of the linguistic terms of each input variables.
varinput.1 &lt;- c("a1", "a2", "a3")
varinput.2 &lt;- c("b1", "b2")
varinput.3 &lt;- c("c1", "c2", "c3")
varinput.4 &lt;- c("d1", "d2", "d3")
names.varinput &lt;- c(varinput.1, varinput.2, varinput.3, varinput.4)

## Set interval of data.
range.data &lt;- matrix(c(0,100, 0, 100, 0, 100, 0, 100, 0, 100), nrow=2)

## Define inference parameters.
type.defuz &lt;- "WAM"
type.tnorm &lt;- "MIN"
type.snorm &lt;- "MAX"
type.implication.func &lt;- "ZADEH"

## Give the name of simulation.
name &lt;- "Sim-0"

## Provide new data for testing. 
newdata &lt;- matrix(c(15, 80, 85, 85, 45, 75, 78, 70), nrow = 2, byrow = TRUE)
## the names of variables
colnames.var &lt;- c("input1", "input2", "input3", "input4", "output1")

###################################################################
## 1a. Using the Mamdani Model 
####################################################################
## Define number of linguistic terms of output variable.
## In this case, we set the number of linguistic terms to 3.
num.fvaloutput &lt;- matrix(c(3), nrow = 1)

## Give the names of the linguistic terms of the output variable.
varoutput.1 &lt;- c("e1", "e2", "e3")
names.varoutput &lt;- c(varoutput.1)

## Define the shapes and parameters of the membership functions of the output variables.
varout.mf &lt;- matrix(c(2, 0, 20, 40, NA, 4, 20, 40, 60, 80, 3, 60, 80, 100, NA),
                      nrow = 5, byrow = FALSE)

## Set type of model which is "MAMDANI" or "TSK" for Mamdani or 
## Takagi Sugeno Kang models, respectively.
## In this case, we choose the Mamdani model.
type.model &lt;- "MAMDANI"

## Define the fuzzy IF-THEN rules; In this case, we provide two scenarios using different operators:
rule.or &lt;- matrix(c("a1", "or", "b1", "or", "c1", "or", "d1", "-&gt;", "e1",
                 "a2", "and", "b2", "and", "c2", "and", "d2", "-&gt;", "e2", 
                 "a3", "and", "b2", "and", "c2", "and", "d1", "-&gt;", "e3"), 
                 nrow = 3, byrow = TRUE) 
			  
## Define the fuzzy IF-THEN rules; 
rule.and &lt;- matrix(c("a1", "and", "b1", "and", "c1", "and", "d1", "-&gt;", "e1",
                 "a2", "and", "b2", "and", "c2", "and", "d2", "-&gt;", "e2", 
                 "a3", "and", "b2", "and", "c2", "and", "d1", "-&gt;", "e3"), 
                 nrow = 3, byrow = TRUE)  

## Generate a fuzzy model with frbs.gen.
object.or &lt;- frbs.gen(range.data, num.fvalinput, names.varinput, 
                 num.fvaloutput, varout.mf, names.varoutput, rule.or, 
                 varinp.mf, type.model, type.defuz, type.tnorm, 
                 type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)

object.and &lt;- frbs.gen(range.data, num.fvalinput, names.varinput, 
                 num.fvaloutput, varout.mf, names.varoutput, rule.and, 
                 varinp.mf, type.model, type.defuz, type.tnorm, 
                 type.snorm, func.tsk = NULL, colnames.var, type.implication.func, name)

## Plot the membership function.
plotMF(object.and)

## Predicting using new data.
res.or &lt;- predict(object.or, newdata)$predicted.val
res.and &lt;- predict(object.and, newdata)$predicted.val

#####################################################################
## 1b. Using the Takagi Sugeno Kang (TSK) Model 
#####################################################################
## Define "TSK" for the Takagi Sugeno Kang model
type.model &lt;- "TSK"

## Define linear equations for consequent parts. 
## The following command means that we have three equation related to the rules we have.
## e.g., the first equation is 1*inputvar.1 + 1*inputvar.2 + 5*inputvar.3 + 2*inputvar.4 + 1, 
## where inputvar.i is a value of the i-th input variable.
func.tsk &lt;- matrix(c(1, 1, 5, 2, 1, 3, 1, 0.5, 0.1, 2, 1, 3, 2, 2, 2), 
            nrow = 3, byrow = TRUE)

## Define the fuzzy IF-THEN rules; 
## For TSK model, it isn't necessary to put linguistic term in consequent parts.
## Make sure that each rule has a "-&gt;" sign. 
rule &lt;- matrix(c("a1", "and", "b1", "and", "c1", "and", "d1", "-&gt;",
                 "a2", "and", "b2", "and", "c2", "and", "d2", "-&gt;",  
                 "a3", "and", "b2", "and", "c2", "and", "d1", "-&gt;"), 
                 nrow = 3, byrow = TRUE) 
			  
## Generate a fuzzy model with frbs.gen.
## It should be noted that for TSK model, we do not need to input: 
## num.fvaloutput, varout.mf, names.varoutput, type.defuz.
object &lt;- frbs.gen(range.data, num.fvalinput, names.varinput, 
             num.fvaloutput = NULL, varout.mf = NULL, names.varoutput = NULL, rule, 
			varinp.mf, type.model, type.defuz = NULL, type.tnorm, type.snorm, 
             func.tsk, colnames.var, type.implication.func, name)
			
## Plot the membership function.
plotMF(object)

## Predicting using new data.
res &lt;- predict(object, newdata)$predicted.val

######################
## 1c. Using the same data as in the previous example, this example performs 
## step by step of the generation of a fuzzy rule-based system
######################
## Using the Mamdani model.
type.model &lt;- "MAMDANI"

## Construct rules.
rule &lt;- matrix(c("a1", "and", "b1", "and", "c1", "and", "d1", "-&gt;", "e1",
                 "a2", "and", "b2", "and", "c2", "and", "d2", "-&gt;", "e2", 
                 "a3", "and", "b2", "and", "c2", "and", "d1", "-&gt;", "e3"), 
                 nrow = 3, byrow = TRUE) 

## Check input data given by user.
rule &lt;- rulebase(type.model, rule, func.tsk = NULL)

## Fuzzification Module:
## In this function, we convert crisp into linguistic values/terms
## based on the data and the parameters of the membership function.
## The output: a matrix representing the degree of the membership of the data
num.varinput &lt;- ncol(num.fvalinput)
MF &lt;- fuzzifier(newdata, num.varinput, num.fvalinput, varinp.mf)

## Inference Module:
## In this function, we will calculate the confidence factor on the antecedent for each rule
## considering t-norm and s-norm.
miu.rule &lt;- inference(MF, rule, names.varinput, type.tnorm, type.snorm)

## Defuzzification Module.
## In this function, we calculate and convert the linguistic values back into crisp values. 
range.output &lt;- range.data[, ncol(range.data), drop = FALSE]
result &lt;- defuzzifier(newdata, rule, range.output, names.varoutput,
                  varout.mf, miu.rule, type.defuz, type.model, func.tsk = NULL)


#################################################
## 2. The following codes show how to generate a fuzzy model 
## using the frbs.gen function for classification tasks using the Mamdani model. 
#################################################
## define range of data.
## Note. we only define range of input data. 
range.data.input &lt;- matrix(c(0, 1, 0, 1, 0, 1, 0, 1), nrow=2)

## Define shape and parameters of membership functions of input variables.
## Please see fuzzifier function to construct the matrix.
## In this case, we are using TRIANGLE for membership functions.
varinp.mf &lt;- matrix(c(1, 0, 0, 0.5, NA, 1, 0, 0.5, 1, NA, 1, 0.5, 1, 1, NA,
                      1, 0, 0, 0.5, NA, 1, 0, 0.5, 1, NA, 1, 0.5, 1, 1, NA,
                      1, 0, 0, 0.5, NA, 1, 0, 0.5, 1, NA, 1, 0.5, 1, 1, NA,
                      1, 0, 0, 0.5, NA, 1, 0, 0.5, 1, NA, 1, 0.5, 1, 1, NA),
                      nrow = 5, byrow = FALSE)

## Define number of linguistic terms of input variables.
## Suppose, we have 3, 3, 3, and 3 numbers of linguistic terms 
## for first up to fourth variables, respectively.
num.fvalinput &lt;- matrix(c(3, 3, 3, 3), nrow=1)

## Give the names of the linguistic terms of each input variable.
varinput.1 &lt;- c("v.1_a.1", "v.1_a.2", "v.1_a.3")
varinput.2 &lt;- c("v.2_a.1", "v.2_a.2", "v.2_a.3")
varinput.3 &lt;- c("v.3_a.1", "v.3_a.2", "v.3_a.3")
varinput.4 &lt;- c("v.4_a.1", "v.4_a.2", "v.4_a.3")
names.varinput &lt;- c(varinput.1, varinput.2, varinput.3, varinput.4)

## Provide inference parameters.
type.tnorm &lt;- "MIN"
type.snorm &lt;- "MAX"
type.implication.func &lt;- "ZADEH"
type.model &lt;- "FRBCS"

## Give the name of simulation.
name &lt;- "Sim-0"

## Provide new data for testing. 
newdata&lt;- matrix(c(0.45, 0.5, 0.89, 0.44, 0.51, 0.99, 0.1, 0.98, 0.51,
                   0.56, 0.55, 0.5), nrow = 3, byrow = TRUE)

## the names of variables
colnames.var &lt;- c("input1", "input2", "input3", "input4", "output1")

## Construct rules.
## It should be noted that on consequent parts we define categorical values instead of 
## linguistic terms. 
rule &lt;- matrix(
       c("v.1_a.2", "and", "v.2_a.2", "and", "v.3_a.3", "and", "v.4_a.2", "-&gt;", "3",
         "v.1_a.2", "and", "v.2_a.3", "and", "v.3_a.1", "and", "v.4_a.3", "-&gt;", "1",
         "v.1_a.2", "and", "v.2_a.2", "and", "v.3_a.2", "and", "v.4_a.2", "-&gt;", "2"), 
         nrow = 3, byrow = TRUE) 

## Generate frbs object.
object &lt;- frbs.gen(range.data = range.data.input, num.fvalinput, 
             names.varinput, num.fvaloutput = NULL, varout.mf = NULL, 
             names.varoutput = NULL, rule, varinp.mf, type.model, 
             type.defuz = NULL, type.tnorm, type.snorm, func.tsk = NULL, 
             colnames.var, type.implication.func, name)
			
## Plot the shape of membership functions.
plotMF(object)

## Predicting using new data.
res &lt;- predict(object, newdata)

####################################################
## 3. The following example shows how to convert 
##    the frbs model into frbsPMML 
####################################################
## In this example, we are using the last object of FRBS.
## Display frbsPMML in R
objPMML &lt;- frbsPMML(object)

## Write into a file with .frbsPMML extention
## Not run: write.frbsPMML(objPMML, fileName="obj_frbsPMML")

## Read the frbsPMML file into an R object of FRBS
obj &lt;- read.frbsPMML("obj_frbsPMML.frbsPMML")
## End(Not run)
</code></pre>


</div>