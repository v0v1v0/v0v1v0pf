<div class="container">

<table style="width: 100%;"><tr>
<td>Extract_Eigencomp_fDA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract/estimate eigenfunction from a sparse functional or longitudinal design
by simulating from a large number of subjects.</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>The function <code>Extract_Eigencomp_fDA()</code> computes the eigenfunctions and the
covariance of the shrinkage scores required to conduct
the projection-based test of mean function between two groups of longitudinal data
or sparsely observed functional data under a random irregular design, as developed by Wang (2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">Extract_Eigencomp_fDA(
  nobs_per_subj,
  obs.design,
  mean_diff_fnm,
  cov.type = c("ST", "NS"),
  cov.par,
  sigma2.e,
  missing_type = c("nomiss", "constant"),
  missing_percent = 0,
  eval_SS = 5000,
  alloc.ratio = c(1, 1),
  fpca_method = c("fpca.sc", "face"),
  work.grid = NULL,
  nWgrid = ifelse(is.null(work.grid), 101, length(work.grid)),
  data.driven.scores = FALSE,
  mean_diff_add_args = list(),
  fpca_optns = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>nobs_per_subj</code></td>
<td>
<p>The number of observations per subject. Each element of it must be greater than 3.
It could also be a vector to indicate that the number of observation for each is randomly varying
between the elements of the vector, or a scalar to ensure that the number of observations are same
for each subject. See examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.design</code></td>
<td>
<p>The sampling design of the observations. Must be provided as
a list with the following elements. If the design is longitudinal (e.g. a clinical trial
where there is pre-specified schedule of visit for the participants) it must be
a named list with elements <code>design</code>, <code>visit.schedule</code> and <code>visit.window</code>, where
<code>obs.design$design</code> must be specified as <code>'longitudinal'</code>, <code>visit.schedule</code>
specifying schedule of visits (in months or days or any unit of time), other than the baseline visit
and <code>visit.window</code> denoting the maximum time window for every visit.
For functional design (where the observation points are either densely observed within a
compact interval or under a sparse random design), the argument must be provided
as a named list with elements <code>design</code> and <code>fun.domain</code>, where
<code>obs.design$design</code> must be specified as <code>'functional'</code> and <code>obs.design$fun.domain</code>
must be specified as a two length vector indicating the domain of the function.
See Details on the specification of arguments section below more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_diff_fnm</code></td>
<td>
<p>The name of the function that output of the difference of the mean between the
two groups at any given time. It must be supplied as character, so that <code>match.fun(mean_diff_fnm)</code>
returns a valid function, that takes a vector input, and returns a vector of the same length of the input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.type</code></td>
<td>
<p>The type of the covariance structure of the data, must be either of 'ST' (stationary) or
'NS' (non-stationary). This argument along with the <code>cov.par</code> argument must be
specified compatibly to ensure that the function does not return an error. See the details
of <code>cov.par</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.par</code></td>
<td>
<p>The covariance structure of the latent response trajectory.
If <code>cov.type == 'ST'</code> then, <code>cov.par</code>
must be specified a named list of two elements, <code>var</code> and <code>cor</code>,
where <code>var</code> is the common variance of the observations, which must be a
positive number; and <code>cor</code> specifies the correlation structure between
the observations. <code>cov.par$cor</code> must be specified in the form of the
nlme::corClasses specified in R package <span class="pkg">nlme</span>.
Check the package documentation for more details for each of the correlation classes.
The <code>cov.par$cor</code> must be a <code>corStruct</code> class so it can be
passed onto the <code>nlme::corMatrix()</code> to extract the subject-specific covariance matrix.
If <code>cov.type='NS'</code> then, <code>cov.par</code>
must be a named list of two elements, <code>cov.obj</code> and <code>eigen.comp</code>,
where only one of the <code>cov.par$cov.obj</code> or <code>cov.par$eigen.comp</code>
must be non-null. This is to specify that the covariance structure of the
latent trajectory can be either provided in the form of covariance function or
in the form of eigenfunction and eigenvalues (Spectral decomposition).
If the <code>cov.par$cov.obj</code> is specified, then it must be a bivariate function,
with two arguments. Alternatively, if the true eigenfunctions  are known,
then the user can specify that by specifying <code>cov.par$eigen.comp</code>.
In this case, the <code>cov.par$eigen.comp</code> must be a named list with two elements,
<code>eig.obj</code> and <code>eig.val</code>, where <code>cov.par$eigen.comp$eig.val</code>
must be positive vector and <code>cov.par$eigen.comp$eig.obj</code>
must be a vectorized function so that its evaluation at a vector of time points
returns a matrix of dimension r by <code>length(cov.par$eigen.comp$eig.val)</code>,
with r being the length of time points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma2.e</code></td>
<td>
<p>Measurement error variance, should be set as zero or a very small number
if the measurement error is not significant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_type</code></td>
<td>
<p>The type of missing in the number of observations of the subjects. Can be one of
<code>'nomiss'</code> for no missing observations
or <code>'constant'</code> for constant
missing percentage at every time point. The current version of package only supports
<code>missing_type = 'constant'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_percent</code></td>
<td>
<p>The percentage of missing at each observation points for each subject.
Must be supplied as number between [0, 0.8], as missing percentage more than 80% is not practical.
If <code>nobs_per_subj</code> is supplied as vector, then <code>missing_type</code>
is forced to set as <code>'nomiss'</code> and <code>missing_percent = 0</code>, because
the <code>missing_type = 'constant'</code> has no meaning if the number of observations are
varying between the subject at the first, typically considered in
the case of sparse random functional design.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eval_SS</code></td>
<td>
<p>The sample size based on which the eigencomponents will be estimated from data.
To compute the theoretical power of the test we must make sure that we use a large enough sample size
to generate the data such that the estimated eigenfunctions are very close to the true eigenfunctions
and that the sampling design will not have much effect on the loss of precision. Default value 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alloc.ratio</code></td>
<td>
<p>The allocation ratio of samples in the each group. Note that the eigenfunctions
will still be estimated based on the total sample_size, however, the variance
of the <code>shrinkage</code> scores (which is required to compute the power function) will be
estimated based on the allocation of the samples in each group. Must be given as vector of
length 2. Default value is set at <code>c(1, 1)</code>, indicating equal sample size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fpca_method</code></td>
<td>
<p>The method by which the FPCA is computed. Must be one of
'fpca.sc' and 'face'. If <code>fpca_method == 'fpca.sc'</code> then the eigencomponents
are estimated using the function <code>refund::fpca.sc()</code>. However, since the <code>refund::fpca.sc()</code>
function fails to estimate the correct <code>shrinkage</code> scores, and throws <code>NA</code> values
when the measurement errors is estimated to be zero, we wrote out a similar function
where we corrected those error in current version of <code>refund::fpca.sc()</code>. Check out
the <code>fpca_sc()</code> function for details. If <code>fpca_method == 'face'</code>, then
the eigencomponents are estimated using <code>face::face.sparse()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>work.grid</code></td>
<td>
<p>The working grid in the domain of the functions, where the eigenfunctions
and other covariance components will be estimated. Default is NULL, then, a equidistant
grid points of length <code>nWgrid</code> will be internally created to as the default <code>work.grid</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nWgrid</code></td>
<td>
<p>The length of the <code>work.grid</code> in the domain of the function based on which
the eigenfunctions will be estimated. Default value is 101. If <code>work.grid</code>
is specified, then <code>nWgrid</code> must be null, and vice-versa.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.driven.scores</code></td>
<td>
<p>Indicates whether the scores are estimated from the full data, WITHOUT
assuming the mean function is unknown, rather the mean function is estimated using
<code>mgcv::gam()</code> function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_diff_add_args</code></td>
<td>
<p>Additional arguments to be passed to group difference
function specified in the argument <code>mean_diff_fnm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fpca_optns</code></td>
<td>
<p>Additional options to be passed onto either of <code>fpca_sc()</code>
or <code>face::face.sparse()</code> function in order
to estimate the eigencomponents. It must be a named list with elements
to be passed onto the respective function, depending on the <code>fpca_method</code>.
The names of the list must not match either of
<code>c('data', 'newdata', 'argvals.new')</code>
for <code>fpca_method == 'face'</code> and must not match either of
<code>c('ydata', 'Y.pred')</code> for  <code>fpca_method == 'fpca.sc'</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function can handle data from wide variety of covariance structure, can be parametric,
or non-parametric. Additional with traditional stationary structures assumed for longitudinal
data (see nlme::corClasses), the user can specify any other non-stationary covariance
function in the form of either a covariance function or in terms of eigenfunctions and
eigenvalues. The user have a lot of flexibility into tweaking the arguments <code>nobs_per_subject</code>,
<code>obs.design</code>, and <code>cov.par</code> to compute the eigencomponents
under different sampling design and covariance process of the response trajectory, and
for any arbitrary mean difference function. Internally, using the sampling
design and the covariance structure specified, we generate a large data with
large number of subjects, and estimate the eigenfunctions and the covariance of the estimated
<code>shrinkage</code> scores by means of functional principal component analysis (fPCA). We put the option of using
two most commonly used softwares for fPCA in the functional data literature, <code>refund::fpca.sc()</code>
and <code>face::face.sparse()</code>. However, since the <code>refund::fpca.sc()</code> do not compute the <code>shrinkage</code>
scores correctly, especially when the measurement error variance is estimated to be zero,
we made a duplicate version of that function in our package, where we write out
the scoring part on our own. The new function is named as <code>fpca_sc()</code>, please check it out.
</p>


<h3>Value</h3>

<p>A list with the elements listed below.
</p>

<ol>
<li> <p><code>mean_diff_vec</code> - The evaluation of the mean function at the working grid.
</p>
</li>
<li> <p><code>est_eigenfun</code> - The evaluation of the estimated eigenfunctions at the working grid.
</p>
</li>
<li> <p><code>est_eigenval</code> - Estimated eigen values.
</p>
</li>
<li> <p><code>working.grid</code> - The grid points at which <code>mean_diff_vec</code> and
<code>est_eigenfun</code> are evaluated.
</p>
</li>
<li> <p><code>fpcCall</code> - The exact call of either of the <code>fpca_sc()</code> or <code>face::face.sparse()</code>
used to compute the eigencomponents.
</p>
</li>
<li> <p><code>scores_var1</code> - Estimated covariance of the <code>shrinkage</code> scores for the treatment group.
</p>
</li>
<li> <p><code>scores_var2</code> - Estimated covariance of the <code>shrinkage</code> scores for the placebo group.
</p>
</li>
<li> <p><code>pooled_var</code>  - Pooled covariance of the scores combining both the groups. This is required
if the user wants to compute the power of Hotelling T statistic under equal variance assumption.
</p>
</li>
</ol>
<p>If <code>data.driven.scores ==  TRUE</code> additional components are returned
</p>

<ol>
<li> <p><code>scores_1</code> - Estimated <code>shrinkage</code> scores for all the subjects in treatment group.
</p>
</li>
<li> <p><code>scores_2</code> - Estimated <code>shrinkage</code> scores for all the subjects in placebo group.
</p>
</li>
</ol>
<p>The output of this function is designed such a way the
user can directly input the output obtained from this function into the arguments of
<code>Power_Proj_Test_ufDA()</code> function to obtain the power and the sample size right away. The function
PASS_Proj_Test_ufDA does the same, it is essentially a wrapper of<code>Extract_Eigencomp_fDA()</code>
and <code>Power_Proj_Test_ufDA()</code> together.
</p>


<h3>Specification of key arguments</h3>

<p>If <code>obs.design$design == 'functional'</code> then a dense grid of length,
specified by ngrid (typically 101/201) is internally created, and
the observation points will be randomly chosen from them.
The time points could also randomly chosen between
any number between the interval, but then for large number of subject,
<code>fpca_sc()</code> function will take huge
time to estimate the eigenfunction. For dense design, the user must set
a large value of the argument <code>nobs_per_subj</code> and for sparse (random) design,
<code>nobs_per_subj</code> should be set small (and varying).
On the other hand, typical to longitudinal data, if the measurements are
taken at fixed time points (from baseline)
for each subject, then the user must set <code>obs.design$design == 'longitudinal'</code> and
the time points must be accordingly specified
in the argument <code>obs.design$visit.schedule</code>. The length of <code>obs.design$visit.schedule</code>
must match <code>length(nobs_per_subj)-1</code>. Internally, when
<code>obs.design$design == 'longitudinal'</code>, the function scale the visit times
so that it lies between [0, 1], so the user should not
specify any element named <code>fun.domain</code> in the
list for <code>obs.design$design == 'longitudinal'</code>. Make sure that
the mean function and the covariance function specified
in the <code>cov.par</code> and <code>mean_diff_fnm</code> parameter also scaled to
take argument between [0, 1]. Also, it is imperative to say that <code>nobs_per_subj</code> must
be of a scalar positive integer for <code>design == 'longitudinal'</code>.
</p>


<h3>Author(s)</h3>

<p>Salil Koner <br> Maintainer: Salil Koner
<a href="mailto:salil.koner@duke.edu">salil.koner@duke.edu</a>
</p>


<h3>References</h3>

<p>Wang, Qiyao (2021)
<em>Two-sample inference for sparse functional data,  Electronic Journal of Statistics,
Vol. 15, 1395-1423</em> <br><a href="https://doi.org/10.1214/21-EJS1802">doi:10.1214/21-EJS1802</a>.
</p>


<h3>See Also</h3>

<p>See <code>Power_Proj_Test_ufDA()</code>, <code>refund::fpca.sc()</code> and <code>face::face.sparse()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Example 1: Extract eigencomponents from stationary covariance.

set.seed(12345)
mean.diff &lt;- function(t) {t};
obs.design &lt;- list("design" = "longitudinal",
"visit.schedule" = seq(0.1, 0.9, length.out=7),
"visit.window" = 0.05)
cor.str &lt;- nlme::corExp(1, form = ~ time | Subject);
sigma2 &lt;- 1; sigma2.e &lt;- 0.25; nobs_per_subj &lt;- 8;
missing_type &lt;- "constant"; missing_percent &lt;- 0.01;
eigencomp  &lt;- Extract_Eigencomp_fDA(obs.design = obs.design,
mean_diff_fnm = "mean.diff", cov.type = "ST",
cov.par = list("var" = sigma2, "cor" = cor.str),
sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
missing_type = missing_type,
missing_percent = missing_percent, eval_SS = 1000,
alloc.ratio = c(1,1), nWgrid = 201,
fpca_method = "fpca.sc", data.driven.scores = FALSE,
mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))

# Example 2: Extract eigencomponents from non-stationary covariance.

alloc.ratio  &lt;- c(1,1)
mean.diff    &lt;- function(t) {1 * (t^3)};
eig.fun &lt;- function(t, k) { if (k==1) {
ef &lt;- sqrt(2)*sin(2*pi*t)
} else if (k==2) {ef &lt;- sqrt(2)*cos(2*pi*t)}
return(ef)}
eig.fun.vec  &lt;- function(t){cbind(eig.fun(t, 1),eig.fun(t, 2))}
eigen.comp   &lt;- list("eig.val" = c(1, 0.5), "eig.obj" = eig.fun.vec)
obs.design   &lt;- list(design = "functional", fun.domain = c(0,1))
cov.par      &lt;- list("cov.obj" = NULL, "eigen.comp" = eigen.comp)
sigma2.e     &lt;- 0.001; nobs_per_subj &lt;- 4:7;
missing_type &lt;- "nomiss"; missing_percent &lt;- 0;
fpca_method  &lt;- "fpca.sc"
eigencomp  &lt;- Extract_Eigencomp_fDA(obs.design = obs.design,
 mean_diff_fnm = "mean.diff",
 cov.type = "NS", cov.par = cov.par,
 sigma2.e = sigma2.e, nobs_per_subj = nobs_per_subj,
 missing_type = missing_type,
 missing_percent = missing_percent, eval_SS = 1000,
 alloc.ratio = alloc.ratio, nWgrid = 201,
 fpca_method = "fpca.sc", data.driven.scores = FALSE,
 mean_diff_add_args = list(), fpca_optns = list(pve = 0.95))

</code></pre>


</div>