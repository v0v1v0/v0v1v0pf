<div class="container">

<table style="width: 100%;"><tr>
<td>overlapping_sbm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create an undirected overlapping degree corrected stochastic blockmodel object</h2>

<h3>Description</h3>

<p>To specify a overlapping stochastic blockmodel, you must specify
the number of nodes (via <code>n</code>),
the mixing matrix (via <code>k</code> or <code>B</code>), and the  block
probabilities (optional, via <code>pi</code>). We provide defaults for most of these
options to enable rapid exploration, or you can invest the effort
for more control over the model parameters. We <strong>strongly recommend</strong>
setting the <code>expected_degree</code> or <code>expected_density</code> argument
to avoid large memory allocations associated with
sampling large, dense graphs.
</p>


<h3>Usage</h3>

<pre><code class="language-R">overlapping_sbm(
  n,
  k = NULL,
  B = NULL,
  ...,
  pi = rep(1/k, k),
  sort_nodes = TRUE,
  force_pure = TRUE,
  poisson_edges = TRUE,
  allow_self_loops = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of nodes in the overlapping SBM.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>(mixing matrix) The number of blocks in the blockmodel.
Use when you don't want to specify the mixing-matrix by hand.
When <code>k</code> is specified, <code>B</code> is set to a diagonal dominant matrix with
value <code>0.8</code> along the diagonal and <code>0.1 / (k - 1)</code> on the
off-diagonal. <code>k</code> defaults to <code>NULL</code>. You must specify either <code>k</code>
or <code>B</code>, but not both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>(mixing matrix) A <code>k</code> by <code>k</code> matrix of block connection
probabilities. The probability that a node in block <code>i</code> connects
to a node in community <code>j</code> is <code>Poisson(B[i, j])</code>. Must be
an <em>invertible</em>, symmetric square matrix.
<code>matrix</code> and <code>Matrix</code> objects are both
acceptable. If <code>B</code> is not symmetric, it will be
symmetrized via the update <code>B := B + t(B)</code>. Defaults to <code>NULL</code>.
You must specify either <code>k</code> or <code>B</code>, but not both.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>undirected_factor_model</code>
</p>

<dl>
<dt><code>expected_degree</code></dt>
<dd>
<p>If specified, the desired expected degree
of the graph. Specifying <code>expected_degree</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
<dt><code>expected_density</code></dt>
<dd>
<p>If specified, the desired expected density
of the graph. Specifying <code>expected_density</code> simply rescales <code>S</code>
to achieve this. Defaults to <code>NULL</code>. Do not specify both
<code>expected_degree</code> and <code>expected_density</code> at the same time.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pi</code></td>
<td>
<p>(block probabilities) Probability of membership in each
block. Membership in each block is independent under the
overlapping SBM. Defaults to <code>rep(1 / k, k)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort_nodes</code></td>
<td>
<p>Logical indicating whether or not to sort the nodes
so that they are grouped by block. Useful for plotting.
Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force_pure</code></td>
<td>
<p>Logical indicating whether or not to force presence of
"pure nodes" (nodes that belong only to a single community) for the sake
of identifiability. To include pure nodes, block membership sampling
first proceeds as per usual. Then, after it is complete, <code>k</code> nodes
are chosen randomly as pure nodes, one for each block. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>poisson_edges</code></td>
<td>
<p>Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds
as usual, and duplicate edges are removed afterwards. Further,
when <code>FALSE</code>, we assume that <code>S</code> specifies a desired between-factor
connection probability, and back-transform this <code>S</code> to the
appropriate Poisson intensity parameter to approximate Bernoulli
factor connection probabilities. See Section 2.3 of Rohe et al. (2017)
for some additional details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_self_loops</code></td>
<td>
<p>Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to <code>TRUE</code>. When <code>FALSE</code>, sampling proceeds allowing
self-loops, and these are then removed after the fact.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>undirected_overlapping_sbm</code> S3 object, a subclass of the
<code>undirected_factor_model()</code> with the following additional
fields:
</p>

<ul>
<li> <p><code>pi</code>: Sampling probabilities for each block.
</p>
</li>
<li> <p><code>sorted</code>: Logical indicating where nodes are arranged by
block (and additionally by degree heterogeneity parameter)
within each block.
</p>
</li>
</ul>
<h3>Generative Model</h3>

<p>There are two levels of randomness in a degree-corrected
overlapping stochastic blockmodel. First, for each node, we
independently determine if that node is a member of each block. This is
handled by <code>overlapping_sbm()</code>. Then, given these block memberships,
we randomly sample edges between nodes. This second
operation is handled by <code>sample_edgelist()</code>,
<code>sample_sparse()</code>, <code>sample_igraph()</code> and
<code>sample_tidygraph()</code>, depending depending on your desired
graph representation.
</p>


<h4>Identifiability</h4>

<p>In order to be identifiable, an overlapping SBM must satisfy two conditions:
</p>

<ol>
<li> <p><code>B</code> must be invertible, and
</p>
</li>
<li>
<p> the must be at least one "pure node" in each block that belongs to no
other blocks.
</p>
</li>
</ol>
<h4>Block memberships</h4>

<p>Note that some nodes may not belong to any blocks.
</p>
<p><strong>TODO</strong>
</p>



<h4>Edge formulation</h4>

<p>Once we know the block memberships, we need one more
ingredient, which is the baseline intensity of connections
between nodes in block <code>i</code> and block <code>j</code>. Then each edge
<code class="reqn">A_{i,j}</code> is Poisson distributed with parameter
</p>
<p><strong>TODO</strong>
</p>



<h3>References</h3>

<p>Kaufmann, Emilie, Thomas Bonald, and Marc Lelarge.
"A Spectral Algorithm with Additive Clustering for the Recovery of
Overlapping Communities in Networks," Vol. 9925.
Lecture Notes in Computer Science.
Cham: Springer International Publishing, 2016.
https://doi.org/10.1007/978-3-319-46379-7.
</p>
<p>Latouche, Pierre, Etienne Birmelé, and Christophe Ambroise.
"Overlapping Stochastic Block Models with Application to the
French Political Blogosphere." The Annals of Applied Statistics 5,
no. 1 (March 2011): 309–36. https://doi.org/10.1214/10-AOAS382.
</p>
<p>Zhang, Yuan, Elizaveta Levina, and Ji Zhu. "Detecting
Overlapping Communities in Networks Using Spectral Methods."
ArXiv:1412.3432, December 10, 2014. http://arxiv.org/abs/1412.3432.
</p>


<h3>See Also</h3>

<p>Other stochastic block models: 
<code>dcsbm()</code>,
<code>directed_dcsbm()</code>,
<code>mmsbm()</code>,
<code>planted_partition()</code>,
<code>sbm()</code>
</p>
<p>Other undirected graphs: 
<code>chung_lu()</code>,
<code>dcsbm()</code>,
<code>erdos_renyi()</code>,
<code>mmsbm()</code>,
<code>planted_partition()</code>,
<code>sbm()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
set.seed(27)

lazy_overlapping_sbm &lt;- overlapping_sbm(n = 1000, k = 5, expected_density = 0.01)
lazy_overlapping_sbm

# sometimes you gotta let the world burn and
# sample a wildly dense graph

dense_lazy_overlapping_sbm &lt;- overlapping_sbm(n = 500, k = 3, expected_density = 0.8)
dense_lazy_overlapping_sbm

k &lt;- 5
n &lt;- 1000
B &lt;- matrix(stats::runif(k * k), nrow = k, ncol = k)

pi &lt;- c(1, 2, 4, 1, 1) / 5

custom_overlapping_sbm &lt;- overlapping_sbm(
  n = 200,
  B = B,
  pi = pi,
  expected_degree = 5
)

custom_overlapping_sbm

edgelist &lt;- sample_edgelist(custom_overlapping_sbm)
edgelist

# efficient eigendecompostion that leverages low-rank structure in
# E(A) so that you don't have to form E(A) to find eigenvectors,
# as E(A) is typically dense. computation is
# handled via RSpectra

population_eigs &lt;- eigs_sym(custom_overlapping_sbm)

</code></pre>


</div>