<div class="container">

<table style="width: 100%;"><tr>
<td>frscore</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>frscore</h2>

<h3>Description</h3>

<p>Calculate fit-robustness scores for a set of <code>cna</code>
solutions/models
</p>


<h3>Usage</h3>

<pre><code class="language-R">frscore(
  sols,
  dat = NULL,
  scoretype = c("full", "supermodel", "submodel"),
  normalize = c("truemax", "idealmax", "none"),
  maxsols = 50,
  verbose = FALSE,
  print.all = FALSE,
  comp.method = c("causal_submodel", "is.submodel")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sols</code></td>
<td>
<p>Character vector of class "stdAtomic" or "stdComplex" (as generated by <code>cna()</code>) that contains the solutions/models to be scored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dat</code></td>
<td>
<p>A <code>configTable</code>, a data frame, a matrix, or a list that specifies the range of admissible factor values
for the factors featured in the models included in <code>sols</code>. Only needed when the models in
<code>sols</code> are multi-valued, otherwise ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoretype</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>  String specifying the scoring method: <code>"full"</code>
(default; scoring is based on counting sub- and supermodel relations), <code>"supermodel"</code>
(count supermodels only), <code>"submodel"</code> (count
submodels only). Allowed for backward compatibility only, due to be dropped
in next version.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>String that determines the method used in
normalizing the scores. <code>"truemax"</code> (default) normalizes by the highest score among the elements of <code>sols</code>,
such that the highest scoring solution types get score 1. <code>"idealmax"</code>
normalizes by a theoretical maximum score (see Details). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxsols</code></td>
<td>
<p>Integer determining the maximum number of unique solution
types found in <code>sols</code> to be included in the scoring (see Details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, additional
information about causal compatibility relations among the unique solution types found
in <code>sols</code> is printed. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>print.all</code></td>
<td>
<p>Logical, controls the number of entries printed when
printing the results. If <code>TRUE</code>, results are printed as when using the defaults of
<code>print.data.frame</code>. If <code>FALSE</code>, 20 highest scoring
solutions/models are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp.method</code></td>
<td>
<p>String that determines how the models in <code>sols</code> are compared
to determine their fr-score. <code>"causal_submodel"</code> (the default) checks for causal submodel relations using <code>causal_submodel()</code>,
<code>"is.submodel"</code> checks for syntactic submodel relations with <code>is.submodel()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>frscore()</code> implements fit-robustness scoring as introduced in Parkkinen and Baumgartner (2021). The function calculates the
fit-robustness scores of Boolean solutions/models output by the <code>cna()</code> function of the <span class="pkg">cna</span> package. The solutions are given to <code>frscore()</code> as a character vector <code>sols</code> obtained by reanalyzing
a data set repeatedly, e.g. with <code>rean_cna()</code>, using different consistency and coverage
thresholds in each analysis.
</p>
<p>For multi-valued
models, the range of admissible values for the factors featured
in the models must be provided via the argument <code>dat</code>, which accepts a data
frame, <code>configTable</code>, or a list of factor-value ranges as its value,
in the same manner as <code>cna::full.ct()</code>.
Typically, one would use the data set that the models in <code>sols</code>
were inferred from, and this is what is done automatically when
<code>frscore()</code> is called within <code>frscored_cna()</code>. When the models in <code>sols</code>
are binary, <code>dat</code> should be left to its default value <code>NULL</code>,
and will in any case be ignored.
</p>
<p>The argument <code>scoretype</code> is deprecated as of <code>frscore</code> 0.3.1, and will be dropped
in the next version.
Giving it a non-default value
is allowed so that older code can be run without errors, but doing this is otherwise discouraged.
When set to its default value <code>"full"</code>,
the score of each <code>sols[i]</code> is calculated by counting the (either syntactic or
causal) sub- and supermodel relations <code>sols[i]</code> has to the other elements
of <code>sols</code>. Setting scoretype to <code>"supermodel"</code> or <code>"submodel"</code> forces the scoring to be based on,
respectively, supermodel and submodel relations only. Whether causal or syntactic submodel relations
are counted depends on the value of <code>comp.method</code>: <code>"causal_submodel"</code> (default)
counts causal submodel relations using <code>causal_submodel()</code>,
<code>"is.submodel"</code> counts syntactic submodel relations using <code>cna::is.submodel()</code>.
In future versions of <code>frscore</code>, fit-robustness
scores will always be calculated as with <code>scoretype = "full"</code>, and
changing this will not be possible. If additional information about the numbers of
sub- vs. supermodel relations a particular model has to other models is needed, this
can be acquired by inspecting the <code>"verbout"</code> element of the output of <code>frscore()</code>.
</p>
<p>The fit-robustness scores can be normalized in two ways. In the default setting <code>normalize = "truemax"</code>, the score of each <code>sols[i]</code> is divided by the maximum score obtained by an element of <code>sols</code>. In case of <code>normalize = "idealmax"</code>, the score is normalized not by an actually obtained
maximum but by an idealized maximum, which is calculated by assuming that all solutions of equal
complexity in <code>sols</code> are identical and that for every <code>sols[i]</code> of a given complexity, all less complex
elements of <code>sols</code> are its submodels and all more complex elements of <code>sols</code> are its supermodels.
When normalization is applied, the normalized score is shown in its own column <code>norm.score</code> in
the results. The raw scores are shown in the column <code>score</code>.
</p>
<p>If the size of the consistency and coverage interval scanned in the reanalysis series generating <code>sols</code> is large or there are many model ambiguities, <code>sols</code> may contain so many different types of solutions/models that robustness cannot be calculated for all of them in reasonable time. In that case, the argument <code>maxsols</code> allows for capping the number of solution types to be included in the scoring (defaults to 50). <code>frscore()</code> then selects the most frequent solutions/models in <code>sols</code> of each complexity level until  <code>maxsols</code> is reached and only scores the thus selected elements of <code>sols</code>.
</p>
<p>If the argument <code>verbose</code> is set to <code>TRUE</code>, <code>frscore()</code> also prints a list indicating for each <code>sols[i]</code> how many raw score points it receives from which elements of <code>sols</code>. The verbose list is ordered with decreasing fit robustness scores.
</p>


<h3>Value</h3>

<p>A named list where the first element is a data frame containing
the unique solution/model types and their scores. Rest of the elements
contain additional information about the submodel relations among
the unique solutions types and about how
the function was called.
</p>


<h3>References</h3>

<p>V.P. Parkkinen and M. Baumgartner (2021), “Robustness and Model Selection in Configurational Causal Modeling,” <em>Sociological Methods and Research</em>, doi:10.1177/0049124120986200.
</p>
<p>Basurto, Xavier. 2013. “Linking Multi-Level Governance to Local Common-Pool
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from
Twenty Years of Biodiversity Conservation in Costa Rica.” <em>Global Environmental Change</em> <strong>23</strong> (3):573-87.
</p>


<h3>See Also</h3>

<p><code>rean_cna()</code>, <code>cna()</code>,
<code>causal_submodel()</code>, <code>is.submodel()</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># Artificial data from Parkkinen and Baumgartner (2021)
sols1 &lt;- rean_cna(d.error, attempt = seq(1, 0.8, -0.1))
sols1 &lt;- do.call(rbind, sols1)
frscore(sols1$condition)


# Real fuzzy-set data from Basurto (2013)
sols2 &lt;- rean_cna(d.autonomy, type="fs", ordering = list("EM", "SP"),
         strict = TRUE, maxstep = c(3,3,9))
sols2 &lt;- do.call(rbind, sols2)$condition  # there are 217 solutions
# At the default maxsols only 50 of those solutions are scored.
frscore(sols2)
# By increasing maxsols the number of solutions to be scored can be controlled.
frscore(sols2, maxsols = 100)


# Multi-valued data/models (data from Hartmann and Kemmerzell (2010))
# Short reanalysis series, change `attempt` value to mimick a more realistic use case
sols3 &lt;- rean_cna(d.pban, outcome = "PB=1", attempt = seq(0.8, 0.7, -0.1), type = "mv")
sols3 &lt;- do.call(rbind, sols3)$condition
# For mv data, frscore() needs the data to determine admissible factor values
frscore(sols3, dat = d.pban)

# Changing the normalization
frscore(sols2, normalize = "none")
frscore(sols2, normalize = "truemax")
frscore(sols2, normalize = "idealmax")

# verbose
frscore(sols2, maxsols = 20, verbose = TRUE)




</code></pre>


</div>