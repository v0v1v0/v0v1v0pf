<div class="container">

<table style="width: 100%;"><tr>
<td>fitkienerX</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation and Regression Functions for Kiener Distributions</h2>

<h3>Description</h3>

<p>Several functions to estimate the parameters of asymmetric Kiener distributions 
and display the results in a numeric vector or in a matrix. 
Algorithm <code>"reg"</code> (the default) uses a nonlinear regression and handle 
difficult cases. Algorithm <code>"estim"</code> has been completely rewritten 
in version 1.8-0 and is now very accurate, even for <code>k&lt;1</code>. Adjustement 
on extreme quantiles can be controlled very precisely.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitkienerX(X, algo = c("r", "reg", "e", "estim"), ord = 7, maxk = 10,
  mink = 1.53, maxe = 0.5, probak = pprobs2, dgts = NULL,
  exfitk = NULL, dimnames = FALSE, ncores = 1)

paramkienerX(X, algo = c("r", "reg", "e", "estim"), ord = 7, maxk = 10,
  mink = 1.53, maxe = 0.5, dgts = 3, parnames = TRUE,
  dimnames = FALSE, ncores = 1)

paramkienerX7(X, dgts = 3, n = 10, maxk = 20, maxe = 0.9,
  parnames = TRUE, dimnames = FALSE, ncores = 1)

paramkienerX5(X, dgts = 3, i = 4, maxk = 20, maxe = 0.9,
  parnames = TRUE, dimnames = FALSE, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>numeric. Vector, matrix, array or list of quantiles.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algo</code></td>
<td>
<p>character. The algorithm used: <code>"r"</code> or <code>"reg"</code>
for regression (default) and <code>"e"</code> or <code>"estim"</code>
for quantile estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ord</code></td>
<td>
<p>integer. Option for probability selection and treatment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxk</code></td>
<td>
<p>numeric. The maximum value of tail parameter <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mink</code></td>
<td>
<p>numeric. The minimum value of tail parameter <code>k</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxe</code></td>
<td>
<p>numeric. The maximum value of absolute tail parameter <code>|e|</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probak</code></td>
<td>
<p>numeric. Ordered vector of probabilities.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dgts</code></td>
<td>
<p>integer. The rounding of output parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exfitk</code></td>
<td>
<p>character. A vector of parameter names to subset the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimnames</code></td>
<td>
<p>boolean. Display dimnames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>integer. The number of cores for parallel processing of arrays.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parnames</code></td>
<td>
<p>boolean. Display parameter names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>integer. The 1:n and (N+i-n):N elements of <code>X</code> used to 
calculate synthetic quantiles at probability levels p1 and 1-p1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>integer. The i-th and (N-i)-th elements of <code>X</code> used to 
extract probabilities p1 and 1-p1 and quantiles x(p) and x(1-p).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>FatTailsR package currently uses two different algorithms to estimate the 
parameters of Kiener distributions K1, K2, K3 and K4.
</p>

<ul>
<li>
<p>Functions <code>fitkienerX(algo = "reg")</code>, <code>paramkienerX(algo = "reg")</code> 
and <code>regkienerLX</code> use an unweighted  
nonlinear regression from <code>logit(p)</code> to <code>X</code> over the whole dataset.  
Depending the size of the dataset, calculation can be slow but is usually
accurate and describes very well the last 1-10 points in the tails 
(except if there is a huge outlier). 
</p>
</li>
<li>
<p>Functions <code>fitkienerX(algo = "estim")</code>, <code>paramkienerX(algo = "estim")</code>, 
<code>paramkienerX5</code> and <code>paramkienerX7</code> estimate the parameters with 
just 5 to 11 quantiles, 5 being the minimum. For averaging purpose, 
11 quantiles are proposed (see below). Computation is almost instantaneous 
and reasonnably accurate. This is the recommanded method for intensive computation.
</p>
</li>
</ul>
<p>A typical input is a numeric vector or a matrix that describes the returns of a stock. 
A matrix must be in the format DS with DATES as rownames, STOCKS as colnames and 
(log-)returns as the content of the matrix. 
An array must be in the format DSL with DATES as rownames, STOCKS as colnames 
LAGS in the third dimension and (log-)returns as the content of the array. 
A list can be a list of numeric but neither a list of matrix, a list of data.frame 
or a list of arrays.
</p>
<p>Conversion from a (possible) time series format to a sorted numeric vector 
is done automatically and without any check of the initial format. 
Empirical probabilities of each point in the sorted dataset is calculated 
with the function <code>ppoints</code> whose parameter <code>a</code> has been set to 
<code>a = 0</code> as large datasets are very common in finance. 
The lowest acceptable size of a dataset is not clear at this moment. A minimum 
of 11 points has been set in <code>"reg"</code> algorithm and a minimum of 15 points 
has been set in <code>"estim"</code> algorithm. It might change in the future. 
If possible, use at least 21 points. 
</p>
<p>Parameter <code>algo</code> controls the algorithm used. Default is "reg".
</p>
<p>When <code>algo = "reg"</code> (or <code>algo = "r"</code>), a nonlinear regression is performed 
with <code>nlsLM</code> from the logit of the empirical probabilities 
<code>logit(p)</code> over the quantiles X with the function <code>qlkiener4</code>. 
The maximum value of the tail parameter <code>k</code> is controlled by <code>maxk</code>.
An upper value <code>maxk = 10</code> is appropriate for datasets
of low and medium size, less than 20.000 or 50.000 points. For larger datasets, the
upper limit can be extended up to <code>maxk = 20</code>. When this limit is reached, 
the shape of the distribution is very similar to the logistic distribution 
(at least when <code>e = 0</code>) and the use of this distribution should be considered. 
Remember that value <code>k &lt; 2</code> describes a distribution with no stable variance and 
<code>k &lt; 1</code> describes a distribution with no stable mean.
</p>
<p>When <code>algo = "estim"</code> (or <code>algo = "e"</code>),
5 to 11 quantiles are used to estimate the parameters. 
The minimum is 5 quantiles : the median x.50, two quantiles at medium distance 
to the median, usually x.25 and x.75 and two quantiles located close to the extremes 
of the dataset, for instance x.01 and x.99 if the dataset <code>X</code> has more 
than 100 points, x.0001 and x.9999 if the dataset <code>X</code> has more than 
10.000 points and so on if the dataset is larger. 
These quantiles are extracted with function <code>fiveprobs</code>. 
Small datasets must contain at least 15 different points. 
</p>
<p>With the idea of averaging the results (but without any guarantee of better 
estimates), calculation has been extended to 11 probabilities  
extracted from <code>X</code> with the function <code>elevenprobs</code> where    
p1, p2 and p3 are the most extreme probabilities of the dataset <code>X</code>  
with values finishing either by <code>.x01</code> or <code>.x025</code> or <code>.x05</code>:
</p>

<ul><li>
<p><code>p11 = c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li></ul>
<p>Selection of subsets among these 11 probabilities is controlled with the option 
<code>ord</code> which can take 12 different values.  
For instance, the default <code>ord = 7</code> computes the  parameters at probabilities 
<code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code> and <code>c(p2, 0.25, 0.50, 0.75, 1-p2)</code>.
Parameters <code>d</code> and <code>k</code> are averaged first and the results of these 
averages are used to compute the other parameters <code>g, a, w, e</code>. 
Small dataset should consider <code>ord = 5</code> and 
large dataset can consider <code>ord = 12</code>. 
The 12 possible values of <code>ord</code> are: 
</p>

<ol>
<li> <p><code>c(p1, 0.35, 0.50, 0.65, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.35, 0.50, 0.65, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.35, 0.50, 0.65, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.35, 0.50, 0.65, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.50, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.50, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.50, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2)</code>
</p>
</li>
<li> <p><code>c(p1, p2, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p2, 1-p1)</code>
</p>
</li>
<li> <p><code>c(p1, p2, p3, 0.25, 0.35, 0.50, 0.65, 0.75, 1-p3, 1-p2, 1-p1)</code>
</p>
</li>
</ol>
<p><code>paramkienerX5</code> is a simplified version of <code>paramkienerX</code> with  
predefined values <code>algo = "estim"</code>, <code>ord = 5</code>, <code>maxk = 10</code> 
and direct access to internal subfunctions. 
It uses the following probabilities:
</p>

<ul><li> <p><code>p5 = c(p1, 0.25, 0.50, 0.75, 1-p1)</code> 
</p>
</li></ul>
<p><code>paramkienerX7</code> is a simplified version of <code>paramkienerX</code> with 
predefined values <code>algo = "estim"</code>, <code>ord = 7</code>, <code>maxk = 10</code> 
and direct access to internal subfunctions.
It uses the following probabilities:
</p>

<ul><li> <p><code>p7 = c(p1, p2, 0.25, 0.50, 0.75, 1-p2, 1-p1)</code> 
</p>
</li></ul>
<p>The quantiles corresponding to the above probabilities are then extracted 
with the function <code>quantile</code> whose parameter <code>type</code> 
has been set to <code>type = 6</code> as it returns the closest values 
to the true quantiles (according to our experience) for all <code>k &gt; 1.9</code>. 
(Note: when <code>k &lt; 1.5</code>, algorithm <code>algo = "reg"</code> returns better  
results). 
Both probabilities and quantiles are then transfered to <code>estimkiener11</code> 
for calculation.
</p>
<p><code>probak</code> controls the probabilities at which the model is tested with the parameter 
estimates. <code>fitkienerX</code> and <code>regkienerLX</code> share the same subroutines.
The default for <code>fitkienerX</code> and <code>regkienerLX</code> is 
<code>pprobs2 = c(0.01, 0.025, 0.05, 0.95, 0.975, 0.99)</code> as those values 
are usual in finance. Other sets of values are provided at <code>pprobs0</code>.
</p>
<p>Rounding the results is useful to display nice results, especially 
in a matrix or in a data.frame. <code>dgts = 13</code> is recommanded 
as <code>a</code>, <code>k</code>, <code>w</code> are usually significant at 1 digit.
</p>

<ul>
<li> <p><code>dgts = NULL</code> does not perform any rounding. 
</p>
</li>
<li> <p><code>dgts = 0 to 9</code> rounds all parameters at the same level. 
</p>
</li>
<li> <p><code>dgts = 10 to 27</code> rounds the parameters at various levels for nice display.  
See <code>roundcoefk</code> for the details. (Note: the
rounding <code>10 to 27</code> currently works with <code>paramkienerX</code>, <code>paramkienerX5</code>,  
<code>paramkienerX7</code> but not yet with <code>fitkienerX</code>). 
</p>
</li>
</ul>
<p>Extracting the most useful parameters from the (quite long) vector/matrix 
<code>fitk</code> is controlled by parameter <code>exfitk</code> that calls user-defined or
predefined parameter subsets like <code>exfit0</code>, ..., <code>exfit7</code>.
IMPORTANT: never subset <code>fitk</code> by rank number as new items may be added 
in the future and rank may vary.
</p>
<p>Calculation of vectors, matrices and lists is not parallelized. Parallelization 
of code for arrays was introduced in version 1.5-0 and improved in version 1.5-1. 
<code>ncores</code> controls the number of cores allowed to the process (through 
<code>parApply</code> which runs on Unices and Windows and requires
about 2 seconds to start). <code>ncores = 1</code> means no parallelization. 
<code>ncores = 0</code> is the recommanded option. It uses the maximum number of cores 
available on the computer, as detected by <code>detectCores</code>,  
minus 1 core, which gives the best performance in most cases. 
Although appealing, this automatic selection may be sometimes dangerous. For instance, 
the instruction <code>f(X, ncores_max) - f(X, ncores_max)</code>, a nice way to compute 
an array of 0, will call <code>2 ncores_max</code> and crash R. <code>ncores = 2,..,99</code> 
sets manually the number of cores. If the requested value is larger than the maximum 
number of cores, this value is automatically reduced (with a warning) to this maximum.
Hence, this latest option provides one core more than option <code>ncores = 0</code>.
</p>
<p>NOTE: <code>fitkienerLX</code>, <code>regkienerX</code>, <code>estimkiener(X,5,7)</code> were   
introduced in v1.2-0 and replaced in version v1.4-1 by <code>fitkienerX</code> and 
<code>paramkiener(X,5,7)</code> to accomodate vector, matrix, arrays and lists. 
We apologize to early users who need to rewrite their codes.
</p>


<h3>Value</h3>

<p><code>paramkienerX</code>: a vector (or a matrix) of parameter estimates 
<code>c(m, g, a, k, w, d, e)</code>.
</p>
<p><code>fitkienerX</code>: a vector (or a matrix) made of several parts:
</p>

<ul>
<li> <p><code>ret</code> : the return over the period calculated with <code>sum(x)</code>. 
Thus, assume log-returns.  
</p>
</li>
<li> <p><code>m, g, a, k, w, d, e</code> : the parameter estimates.  
</p>
</li>
<li> <p><code>m1, sd, sk, ke</code> : the mean, standard deviation, 
skewness and excess of kurtosis computed from the parameter estimates.  
</p>
</li>
<li> <p><code>m1x, sdx, skx, kex</code> : The mean, standard deviation,  
skewness and excess of kurtosis computed from the dataset.  
</p>
</li>
<li> <p><code>lh</code> : the length of the dataset over the period.  
</p>
</li>
<li> <p><code>q.</code> : quantile estimated with the parameter estimates. 
</p>
</li>
<li> <p><code>VaR.</code> : Value-at-Risk, positive in most cases.  
</p>
</li>
<li> <p><code>c.</code> : corrective tail coefficient = (q - m) / (q_logistic_function - m). 
</p>
</li>
<li> <p><code>ltm.</code> : left tail mean (signed ES on the left tail, usually negative).  
</p>
</li>
<li> <p><code>rtm.</code> : right tail mean (signed ES on the right tail, usually positive). 
</p>
</li>
<li> <p><code>dtmq.</code> : (p&lt;=0.5 left, p&gt;0.5 right) tail mean minus quantile. 
</p>
</li>
<li> <p><code>ES.</code> : expected shortfall, positive in most cases. 
</p>
</li>
<li> <p><code>h.</code> : corrective ES  = (ES - m) / (ES_logistic_function - m). 
</p>
</li>
<li> <p><code>desv.</code> : ES - VaR, usually positive.  
</p>
</li>
<li> <p><code>l.</code> : quantile estimated by the tangent logistic function. 
</p>
</li>
<li> <p><code>dl.</code> : quantile - quantile_logistic_function. 
</p>
</li>
<li> <p><code>g.</code> : quantile estimated by the Laplace-Gauss function.  
</p>
</li>
<li> <p><code>dg.</code> : quantile - quantile_Laplace_Gauss_function. 
</p>
</li>
</ul>
<p>IMPORTANT : if you need to subset <code>fitk</code>, always subset it by parameter names 
and never subset it by rank number as new items may be added in the future and rank may vary. 
Use for instance <code>exfit0</code>, ..., <code>exfit7</code>.
</p>


<h3>References</h3>

<p>P. Kiener, Fat tail analysis and package FatTailsR, 
9th R/Rmetrics Workshop and Summer School, Zurich, 27 June 2015. 
<a href="https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf">https://www.inmodelia.com/exemples/2015-0627-Rmetrics-Kiener-en.pdf</a>
</p>


<h3>See Also</h3>

<p><code>regkienerLX</code>, <code>estimkiener11</code>, 
<code>roundcoefk</code>, <code>exfit6</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">    

require(minpack.lm)
require(timeSeries)

### Load the datasets and choose j in 1:16
DS     &lt;- getDSdata()
j      &lt;- 5

### and run this block
probak &lt;- c(0.01, 0.05, 0.95, 0.99)
X      &lt;- DS[[j]] ; names(DS)[j]
elevenprobs(X)
fitkienerX(X, algo = "reg", dgts = 3, probak = probak)
fitkienerX(X, algo = "estim", ord = 5, probak = probak, dgts = 3)
paramkienerX(X)
paramkienerX5(X)

### Compare the 12 values of paramkienerX(ord/row = 1:12) and paramkienerX (row 13)
compare &lt;- function(ord, X) { paramkienerX(X, ord, algo = "estim", dgts = 13) }
rbind(t(sapply( 1:12, compare, X)), paramkienerX(X, algo = "reg", dgts = 13))

### Analyze DS in one step
t(sapply(DS, paramkienerX, algo = "reg", dgts = 13))
t(sapply(DS, paramkienerX, algo = "estim", dgts = 13))
paramkienerX(DS, algo = "reg", dgts = 13)
paramkienerX(DS, algo = "estim", dgts = 13)
system.time(fitk_rDS &lt;- fitkienerX(DS, algo = "r", probak = pprobs2, dgts = 3))
system.time(fitk_eDS &lt;- fitkienerX(DS, algo = "e", probak = pprobs2, dgts = 3))
fitk_rDS
fitk_eDS

### Subset rDS and eDS with exfit0,..,exfit7
fitk_rDS[,exfit4]
fitk_eDS[,exfit7]
fitkienerX(DS, algo = "e", probak = pprobs2, dgts = 3, exfitk = exfit7)

### Array (new example introduced in v1.5-1)
### Increase the number of cores and crash R.
## Not run:
arr &lt;- array(rkiener1(3000), c(4,3,250))
paramkienerX7(arr, ncores = 2)
## paramkienerX7(arr, ncores = 2) - paramkienerX(arr, ncores = 2)
## End(Not run)

### End


</code></pre>


</div>