<div class="container">

<table style="width: 100%;"><tr>
<td>fitTsfm.control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>List of control parameters for <code>fitTsfm</code>
</h2>

<h3>Description</h3>

<p>Creates a list of control parameters for <code>fitTsfm</code>. 
All control parameters that are not passed to this function are set to 
default values. This function is meant for internal use only!!
</p>


<h3>Usage</h3>

<pre><code class="language-R">fitTsfm.control(
  decay = 0.95,
  weights,
  model = TRUE,
  x = FALSE,
  y = FALSE,
  qr = TRUE,
  nrep = NULL,
  bb = 0.5,
  efficiency = 0.95,
  family = "mopt",
  tuning.psi,
  tuning.chi,
  compute.rd = FALSE,
  corr.b = TRUE,
  split.type = "f",
  initial = "S",
  max.it = 100,
  refine.tol = 1e-07,
  rel.tol = 1e-07,
  refine.PY = 10,
  solve.tol = 1e-07,
  trace.lev = 0,
  psc_keep = 0.5,
  resid_keep_method = "threshold",
  resid_keep_thresh = 2,
  resid_keep_prop = 0.2,
  py_maxit = 20,
  py_eps = 1e-05,
  mscale_maxit = 50,
  mscale_tol = 1e-06,
  mscale_rho_fun = "bisquare",
  scope,
  scale,
  direction,
  steps = 1000,
  k = 2,
  nvmin = 1,
  nvmax = 8,
  force.in = NULL,
  force.out = NULL,
  method,
  really.big = FALSE,
  type,
  normalize = TRUE,
  eps = .Machine$double.eps,
  max.steps,
  plot.it = FALSE,
  lars.criterion = "Cp",
  K = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>decay</code></td>
<td>
<p>a scalar in (0, 1] to specify the decay factor for "DLS". 
Default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting 
process for <code>fit.method="LS","Robust"</code>, or 
<code>variable.selection="subsets"</code>. Should be <code>NULL</code> or a numeric 
vector. The length of <code>weights</code> must be the same as the number of 
observations. The weights must be nonnegative and it is strongly 
recommended that they be strictly positive.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model, x, y, qr</code></td>
<td>
<p>logicals passed to <code>lm</code> for 
<code>fit.method="LS"</code>. If <code>TRUE</code> the corresponding components of the 
fit (the model frame, the model matrix, the response, the QR decomposition) 
are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>
<p>the number of random subsamples to be drawn for 
<code>fit.method="Robust"</code>. If the data set is small and "Exhaustive" 
resampling is being used, the value of <code>nrep</code> is ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bb</code></td>
<td>
<p>tuning constant (between 0 and 1/2) for the M-scale used to compute the initial S-estimator. It
determines the robustness (breakdown point) of the resulting MM-estimator, which is
<code>bb</code>. Defaults to 0.5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>efficiency</code></td>
<td>
<p>desired asymptotic efficiency of the final regression M-estimator. Defaults to 0.85.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>string specifying the name of the family of loss function to be used (current valid
options are "bisquare", "optimal" and "modopt" from the RobStatTM package). Incomplete entries will be matched to
the current valid options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning.psi</code></td>
<td>
<p>tuning parameters for the regression M-estimator computed with a rho function
as specified with argument <code>family</code>. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>efficiency</code> according to the family of rho functions specified in <code>family</code>.
Appropriate values for <code>tuning.psi</code> for a given desired efficiency for Gaussian errors
can be constructed using the functions <code>bisquare</code>, <code>mopt</code> and <code>opt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tuning.chi</code></td>
<td>
<p>tuning constant for the function used to compute the M-scale
used for the initial S-estimator. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>bb</code> according to the family of rho functions specified in <code>family</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.rd</code></td>
<td>
<p>logical value indicating whether robust leverage distances need to be computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>corr.b</code></td>
<td>
<p>logical value indicating whether a finite-sample correction should be applied
to the M-scale parameter <code>bb</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split.type</code></td>
<td>
<p>determines how categorical and continuous variables are split. See
<code>splitFrame</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>string specifying the initial value for the M-step of the MM-estimator. Valid
options are <code>'S'</code>, for an S-estimator and <code>'MS'</code> for an M-S estimator which is
appropriate when there are categorical explanatory variables in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.it</code></td>
<td>
<p>maximum number of IRWLS iterations for the MM-estimator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine.tol</code></td>
<td>
<p>relative convergence tolerance for the S-estimator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p>relative convergence tolerance for the IRWLS iterations for the MM-estimator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine.PY</code></td>
<td>
<p>number of refinement steps for the Pen~a-Yohai candidates</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solve.tol</code></td>
<td>
<p>relative tolerance for inversion</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace.lev</code></td>
<td>
<p>positive values (increasingly) provide details on the progress of the MM-algorithm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psc_keep</code></td>
<td>
<p>For pyinit, proportion of observations to remove based on PSCs. The effective proportion of removed
observations is adjusted according to the sample size to be <code>prosac*(1-p/n)</code>. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_keep_method</code></td>
<td>
<p>For pyinit, how to clean the data based on large residuals. If
<code>"threshold"</code>, all observations with scaled residuals larger than <code>C.res</code> will
be removed, if <code>"proportion"</code>, observations with the largest <code>prop</code> residuals will
be removed. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_keep_thresh</code></td>
<td>
<p>See parameter <code>resid_keep_method</code> above. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resid_keep_prop</code></td>
<td>
<p>See parameter <code>resid_keep_method</code> above. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py_maxit</code></td>
<td>
<p>Maximum number of iterations. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>py_eps</code></td>
<td>
<p>Relative tolerance for convergence.  See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mscale_maxit</code></td>
<td>
<p>Maximum number of iterations for the M-scale algorithm. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mscale_tol</code></td>
<td>
<p>Convergence tolerance for the M-scale algorithm. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mscale_rho_fun</code></td>
<td>
<p>String indicating the loss function used for the M-scale. See <code>pyinit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scope</code></td>
<td>
<p>defines the range of models examined in the <code>"stepwise"</code> 
search. This should be either a single formula, or a list containing 
components <code>upper</code> and <code>lower</code>, both formulae. See 
<code>step</code> for how to specify the formulae and usage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>optional parameter for <code>variable.selection="stepwise"</code>. 
The argument is passed to <code>step</code> or 
<code>step.lmrobdetMM</code> as appropriate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>the mode of <code>"stepwise"</code> search, can be one of "both", 
"backward", or "forward", with a default of "both". If the <code>scope</code> 
argument is missing the default for <code>direction</code> is "backward".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>steps</code></td>
<td>
<p>the maximum number of steps to be considered for 
<code>"stepwise"</code>. Default is 1000 (essentially as many as required). It is 
typically used to stop the process early.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the multiple of the number of degrees of freedom used for the 
penalty in <code>"stepwise"</code>. Only <code>k = 2</code> gives the genuine AIC. 
<code>k = log(n)</code> is sometimes referred to as BIC or SBC. Default is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvmin</code></td>
<td>
<p>minimum size of subsets to examine for <code>"subsets"</code>. 
Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nvmax</code></td>
<td>
<p>maximum size of subsets to examine for <code>"subsets"</code>. 
Default is 8.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.in</code></td>
<td>
<p>index to columns of design matrix that should be in all 
models for <code>"subsets"</code>. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>force.out</code></td>
<td>
<p>index to columns of design matrix that should be in no 
models for <code>"subsets"</code>. Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>one of "exhaustive", "forward", "backward" or "seqrep" 
(sequential replacement) to specify the type of subset search/selection. 
Required if <code>variable selection="subsets"</code> is chosen. Default is 
"exhaustive".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>really.big</code></td>
<td>
<p>option for <code>"subsets"</code>; Must be <code>TRUE</code> to 
perform exhaustive search on more than 50 variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>option for <code>"lars"</code>. One of "lasso", "lar", 
"forward.stagewise" or "stepwise". The names can be abbreviated to any 
unique substring. Default is "lasso".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>option for <code>"lars"</code>. If <code>TRUE</code>, each variable is 
standardized to have unit L2 norm, otherwise they are left alone. Default 
is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>option for <code>"lars"</code>; An effective zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.steps</code></td>
<td>
<p>Limit the number of steps taken for <code>"lars"</code>; the 
default is <code>8 * min(m, n-intercept)</code>, with <code>m</code> the number of 
variables, and <code>n</code> the number of samples. For <code>type="lar"</code> or 
<code>type="stepwise"</code>, the maximum number of steps is 
<code>min(m,n-intercept)</code>. For <code>type="lasso"</code> and especially 
<code>type="forward.stagewise"</code>, there can be many more terms, because 
although no more than <code>min(m,n-intercept)</code> variables can be active 
during any step, variables are frequently droppped and added as the 
algorithm proceeds. Although the default usually guarantees that the 
algorithm has proceeded to the saturated fit, users should check.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.it</code></td>
<td>
<p>option to plot the output for <code>cv.lars</code>. 
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lars.criterion</code></td>
<td>
<p>an option to assess model selection for the 
<code>"lars"</code> method; one of "Cp" or "cv". See details. Default is "Cp".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of folds for computing the K-fold cross-validated mean 
squared prediction error for <code>"lars"</code>. Default is 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>If positive (or, not <code>FALSE</code>), info is printed during the 
running of  <code>step</code>, <code>lars</code> or 
<code>cv.lars</code> as relevant. Larger values may give more 
detailed information. Default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This control function is used to process optional arguments passed 
via <code>...</code> to <code>fitTsfm</code>. These arguments are validated and defaults
are set if necessary before being passed internally to one of the following
functions: <code>lm</code>, <code>lmrobdetMM</code>, 
<code>step</code>, <code>regsubsets</code>, 
<code>lars</code> and <code>cv.lars</code>. See their 
respective help files for more details. The arguments to each of these 
functions are listed above in approximately the same order for user 
convenience.
</p>
<p>The scalar <code>decay</code> is used by <code>fitTsfm</code> to compute 
exponentially decaying weights for <code>fit.method="DLS"</code>. Alternately, one 
can directly specify <code>weights</code>, a weights vector, to be used with 
"LS" or "Robust". Especially when fitting multiple assets, care should be 
taken to ensure that the length of the weights vector matches the number of
observations (excluding cases ignored due to NAs).
</p>
<p><code>lars.criterion</code> selects the criterion (one of "Cp" or "cv") to 
determine the best fitted model for <code>variable.selection="lars"</code>. The 
"Cp" statistic (defined in page 17 of Efron et al. (2004)) is calculated 
using <code>summary.lars</code>. While, "cv" computes the K-fold 
cross-validated mean squared prediction error using 
<code>cv.lars</code>.
</p>


<h3>Value</h3>

<p>A list of the above components. This is only meant to be used by 
<code>fitTsfm</code>.
</p>


<h3>Author(s)</h3>

<p>Sangeetha Srinivasan
</p>


<h3>References</h3>

<p>Efron, B., Hastie, T., Johnstone, I., &amp; Tibshirani, R. (2004). Least angle 
regression. The Annals of statistics, 32(2), 407-499.
</p>


<h3>See Also</h3>

<p><code>fitTsfm</code>, <code>lm</code>, 
<code>lmrobdetMM</code>, <code>step</code>, 
<code>regsubsets</code>, <code>lars</code> and 
<code>cv.lars</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# check argument list passed by fitTsfm.control
tsfm.ctrl &lt;- fitTsfm.control(method="exhaustive", nvmin=2)
print(tsfm.ctrl)


# used internally by fitTsfm in the example below
 # load data
data(managers, package = 'PerformanceAnalytics')
 # Make syntactically valid column names
colnames(managers)
colnames(managers) &lt;- make.names( colnames(managers))
colnames(managers)

fit &lt;- fitTsfm(asset.names=colnames(managers[,(1:6)]),
               factor.names=colnames(managers[,(7:9)]), 
               data=managers, variable.selection="subsets", 
               method="exhaustive", nvmin=2)

</code></pre>


</div>