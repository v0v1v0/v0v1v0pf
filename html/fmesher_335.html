<div class="container">

<table style="width: 100%;"><tr>
<td>fm_mesh_2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Make a 2D mesh object</h2>

<h3>Description</h3>

<p>Make a 2D mesh object
</p>


<h3>Usage</h3>

<pre><code class="language-R">fm_mesh_2d(...)

fm_mesh_2d_inla(
  loc = NULL,
  loc.domain = NULL,
  offset = NULL,
  n = NULL,
  boundary = NULL,
  interior = NULL,
  max.edge = NULL,
  min.angle = NULL,
  cutoff = 1e-12,
  max.n.strict = NULL,
  max.n = NULL,
  plot.delay = NULL,
  crs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently passed on to <code>fm_mesh_2d_inla</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>Matrix of point locations to be used as initial triangulation
nodes.  Can alternatively be a <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc.domain</code></td>
<td>
<p>Matrix of point locations used to determine the domain
extent.  Can alternatively be a <code>SpatialPoints</code> or
<code>SpatialPointsDataFrame</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>The automatic extension distance.  One or two values, for an
inner and an optional outer extension.  If negative, interpreted as a factor
relative to the approximate data diameter (default=-0.10???)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of initial nodes in the automatic extensions
(default=16)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary</code></td>
<td>
<p>one or more (as list) of <code>fm_segm()</code> objects, or objects
supported by <code>fm_as_segm()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interior</code></td>
<td>
<p>one object supported by <code>fm_as_segm()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.edge</code></td>
<td>
<p>The largest allowed triangle edge length.  One or two
values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.angle</code></td>
<td>
<p>The smallest allowed triangle angle.  One or two values.
(Default=21)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.n.strict</code></td>
<td>
<p>The maximum number of vertices allowed, overriding
<code>min.angle</code> and <code>max.edge</code> (default=-1, meaning no limit).  One or
two values, where the second value gives the number of additional vertices
allowed for the extension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.n</code></td>
<td>
<p>The maximum number of vertices allowed, overriding
<code>max.edge</code> only (default=-1, meaning no limit).  One or two values,
where the second value gives the number of additional vertices allowed for
the extension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.delay</code></td>
<td>
<p>If logical <code>TRUE</code> or a negative numeric value,
activates displaying the
result after each step of the multi-step domain extension algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>An optional <code>fm_crs()</code>, <code>sf::crs</code> or <code>sp::CRS</code> object</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>inla.mesh</code> object.
</p>


<h3>Functions</h3>


<ul><li> <p><code>fm_mesh_2d_inla()</code>: Legacy method for <code>INLA::inla.mesh.2d()</code>
Create a triangle mesh based on initial point locations, specified or
automatic boundaries, and mesh quality parameters.
</p>
</li></ul>
<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code>fm_rcdt_2d_inla()</code>, <code>fm_mesh_2d_inla()</code>,
and <code>fm_nonconvex_hull_inla()</code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code>fm_rcdt_2d()</code>, <code>fm_mesh_2d()</code>, and <code>fm_nonconvex_hull()</code> interfaces may be
different, and potentially change in the future.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>fm_rcdt_2d()</code>, <code>fm_mesh_2d()</code>, <code>fm_delaunay_2d()</code>,
<code>fm_nonconvex_hull()</code>, <code>fm_extensions()</code>, <code>fm_refine()</code>
</p>
<p>Other object creation and conversion: 
<code>fm_as_fm()</code>,
<code>fm_as_lattice_2d()</code>,
<code>fm_as_mesh_1d()</code>,
<code>fm_as_mesh_2d()</code>,
<code>fm_as_segm()</code>,
<code>fm_as_sfc()</code>,
<code>fm_as_tensor()</code>,
<code>fm_lattice_2d()</code>,
<code>fm_mesh_1d()</code>,
<code>fm_segm()</code>,
<code>fm_simplify()</code>,
<code>fm_tensor()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">fm_mesh_2d_inla(boundary = fm_extensions(cbind(2, 1), convex = 1, 2))

</code></pre>


</div>