<div class="container">

<table style="width: 100%;"><tr>
<td>get_mfd_df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Get Multivariate Functional Data from a data frame</h2>

<h3>Description</h3>

<p>Get Multivariate Functional Data from a data frame
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_mfd_df(
  dt,
  domain,
  arg,
  id,
  variables,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dt</code></td>
<td>
<p>A <code>data.frame</code> containing the discrete data.
For each functional variable, a single column,
whose name is provided in the argument <code>variables</code>,
contains discrete values of that variable for all functional observation.
The column indicated by the argument <code>id</code>
denotes which is the functional observation in each row.
The column indicated by the argument <code>arg</code>
gives the argument value at which
the discrete values of the functional variables are observed for each row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>domain</code></td>
<td>
<p>A numeric vector of length 2 defining
the interval over which the functional data object
can be evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arg</code></td>
<td>
<p>A character variable, which is the name of
the column of the data frame <code>dt</code>
giving the argument values at which the functional variables
are evaluated for each row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>A character variable indicating
which is the functional observation in each row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variables</code></td>
<td>
<p>A vector of characters of the column names
of the data frame <code>dt</code>
indicating the functional variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_basis</code></td>
<td>
<p>An integer variable specifying the number of basis functions;
default value is 30.
See details on basis functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_order</code></td>
<td>
<p>An integer specifying the order of b-splines,
which is one higher than their degree.
The default of 4 gives cubic splines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisobj</code></td>
<td>
<p>An object of class <code>basisfd</code> defining
the basis function expansion.
Default is <code>NULL</code>, which means that
a <code>basisfd</code> object is created by doing
<code>create.bspline.basis(rangeval = domain,
nbasis = n_basis,  norder = n_order)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lfdobj</code></td>
<td>
<p>An object of class <code>Lfd</code> defining a
linear differential operator of order m.
It is used to specify a roughness penalty through <code>fdPar</code>.
Alternatively, a nonnegative integer
specifying the order m can be given and is
passed as <code>Lfdobj</code> argument to the function <code>fdPar</code>,
which indicates that the derivative of order m is penalized.
Default value is 2, which means that the
integrated squared second derivative is penalized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>A non-negative real number.
If you want to use a single specified smoothing parameter
for all functional data objects in the dataset,
this argument is passed to the function <code>fda::fdPar</code>.
Default value is NULL, in this case the smoothing parameter is chosen
by minimizing the generalized cross-validation (GCV)
criterion over the grid of values given by the argument.
See details on how smoothing parameters work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_grid</code></td>
<td>
<p>A vector of non-negative real numbers.
If <code>lambda</code> is provided as a single number, this argument is ignored.
If <code>lambda</code> is NULL, then this provides the grid of values
over which the optimal smoothing parameter is
searched. Default value is <code>10^seq(-10,1,l=20)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when doing GCV separately on all observations.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Basis functions are created with
<code>fda::create.bspline.basis(domain, n_basis)</code>, i.e.
B-spline basis functions of order 4 with equally spaced knots
are used to create <code>mfd</code> objects.
</p>
<p>The smoothing penalty lambda is provided as
<code>fda::fdPar(bs, 2, lambda)</code>,
where bs is the basis object and 2 indicates
that the integrated squared second derivative is penalized.
</p>
<p>Rather than having a data frame with long format,
i.e. with all functional observations in a single column
for each functional variable,
if all functional observations are observed on a common equally spaced grid,
discrete data may be available in matrix form for each functional variable.
In this case, see <code>get_mfd_list</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mfd</code>.
See also <code>?mfd</code> for additional details on the
multivariate functional data class.
</p>


<h3>See Also</h3>

<p><code>get_mfd_list</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(funcharts)

x &lt;- seq(1, 10, length = 25)
y11 &lt;- cos(x)
y21 &lt;- cos(2 * x)
y12 &lt;- sin(x)
y22 &lt;- sin(2 * x)
df &lt;- data.frame(id = factor(rep(1:2, each = length(x))),
                 x = rep(x, times = 2),
                 y1 = c(y11, y21),
                 y2 = c(y12, y22))

mfdobj &lt;- get_mfd_df(dt = df,
                     domain = c(1, 10),
                     arg = "x",
                     id = "id",
                     variables = c("y1", "y2"),
                     lambda = 1e-5)

</code></pre>


</div>