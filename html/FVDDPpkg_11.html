<div class="container">

<table style="width: 100%;"><tr>
<td>smooth</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the smoothing distribution of the Fleming-Viot latent signal</h2>

<h3>Description</h3>

<p>Compute the smoothing distribution of the Fleming-Viot latent signal
</p>


<h3>Usage</h3>

<pre><code class="language-R">smooth(fvddp.past, fvddp.future, t.past, t.future, y.new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fvddp.past</code></td>
<td>
<p>An instance of class <code>fvddp</code>, progressively updated ad propagated
with data referring to past times via <code>update()</code> and <code>propagate()</code>
(or its approximate version, <code>approx.propagate()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fvddp.future</code></td>
<td>
<p>Same as <code>fvddp.past</code>, but in this case the propagation has
been performed with time data from times later than the one to be estimated. Its
hyperparameters must be equals to the ones of <code>fvddp.past</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.past</code></td>
<td>
<p>The time between the last collection of data (in the past) and the
time at which the smoothing is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t.future</code></td>
<td>
<p>Same as <code>t.past</code>, but in this case it is referred to the future.
<code>t.future</code> is positive too.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y.new</code></td>
<td>
<p>The data collected at the time the smoothing is performed.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function returns an instance of class <code>fvddp</code> whose hyperparametrs
are the same of <code>fvddp.past</code> and <code>fvddp.future</code>. The values of <code>y.star</code>and  <code>M</code>
are such that to represent the state of the FVDDP signal in the present time,
i.e. the one Which is <code>t.past</code> away from the time at which <code>fvddp.past</code> i
estimated, and is <code>t.future</code> away from the time at which <code>fvddp.future</code> is ,
estimated. Since the computation is usually extemely long, one can rely on the
Monte-Carlo approximation provided by <code>approx.smooth()</code>.
</p>


<h3>References</h3>


<p>Ascolani F, Lijoi A, Ruggiero M (2023).
“Smoothing distributions for conditional Fleming–Viot and Dawson–Watanabe diffusions.”
<em>Bernoulli</em>, <b>29</b>(2), 1410 – 1434.
<a href="https://doi.org/10.3150/22-BEJ1504">doi:10.3150/22-BEJ1504</a>.

</p>


<h3>See Also</h3>

<p><code>approx.smooth()</code> for a (faster) approximation based on importance
sampling.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#create wo process and sequentilly update and propagate them
FVDDP = initialize(3, function(x) rbinom(x, 10, .2),
                   function(x) dbinom(x, 10, .2), TRUE)
#for the past
FVDDP.PAST = update(FVDDP, c(2,3))
#for the future
FVDDP.FUTURE = update(FVDDP, c(4))
FVDDP.FUTURE = propagate(FVDDP.FUTURE, 0.5)
FVDDP.FUTURE = update(FVDDP.FUTURE, c(1))
#get a smoothed  FVDDP merging them (with new values too)
smooth(fvddp.past = FVDDP.PAST, fvddp.future = FVDDP.FUTURE,
       t.past= 0.4, t.future = 0.3, y.new = c(1,3))

</code></pre>


</div>