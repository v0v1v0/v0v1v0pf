<div class="container">

<table style="width: 100%;"><tr>
<td>lamest</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computation of Liu Tuning Parameter</h2>

<h3>Description</h3>

<p><code>lamest</code> computes the Liu tuning parameters provided in the literature.
The tuning parameter estimates are based on
</p>

<ul>
<li>
<p> Liu (1993) <a href="doi:10.1080/03610929308831027">doi:10.1080/03610929308831027</a>,
</p>
</li>
<li>
<p> Ozkale and Kaciranlar (2007) <a href="doi:10.1080/03610920601126522">doi:10.1080/03610920601126522</a>,
</p>
</li>
<li>
<p> Liu (2011) <a href="doi:10.1016/j.jspi.2010.05.030">doi:10.1016/j.jspi.2010.05.030</a>.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">lamest(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>An object of class <code>liureg</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used in this implemetation.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>lamest</code> function computes the following tuning
parameter estimates available in the literature.
</p>

<table>
<tr>
<td style="text-align: left;">
<code>lam.mm</code> (Liu, 1993) </td>
<td style="text-align: left;"> <code class="reqn">\displaystyle{1-\hat{\sigma}^{2}\left(\frac{\sum\limits _{j=1}^{p}\frac{1}{\lambda_{j}\left(1+\lambda_{j}\right)}}{\sum\limits _{j=1}^{p}\frac{\hat{\alpha}_{j}^{2}}{\left(1+\lambda_{j}\right)^{2}}}\right)}</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>lam.CL</code>  (Liu, 1993) </td>
<td style="text-align: left;"> <code class="reqn">\displaystyle{1-\hat{\sigma}^{2}\left(\frac{\sum\limits _{j=1}^{p}\frac{1}{\left(1+\lambda_{j}\right)}}{\sum\limits _{j=1}^{p}\frac{\lambda_{j}\hat{\alpha}_{j}^{2}}{\left(1+\lambda_{j}\right)^{2}}}\right)}</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>lam.opt</code> (Liu, 1993) </td>
<td style="text-align: left;"> <code class="reqn">\displaystyle{\frac{\sum\limits _{j=1}^{p}\left(\frac{\alpha_{j}^{2}-\sigma^{2}}{\left(1+\lambda_{j}\right)^{2}}\right)}{\sum\limits _{j=1}^{p}\left(\frac{\sigma^{2}+\lambda_{j}\alpha_{j}^{2}}{\lambda_{j}\left(1+\lambda_{j}\right)^{2}}\right)}}</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>lam.OK</code> (Ozkale and Kaciranlar, 2007; Liu, 2011) </td>
<td style="text-align: left;"> <code class="reqn">\displaystyle{\frac{\sum\limits _{i=1}^{n}\frac{\tilde{e}_{i}}{1-g_{ii}}\left(\frac{\tilde{e}_{i}}{1-h_{1-ii}}-\frac{\hat{e}_{i}}{1-h_{ii}}\right)}{\sum\limits _{i=1}^{n}\left(\frac{\tilde{e}_{i}}{1-g_{ii}}-\frac{\hat{e}_{i}}{1-h_{ii}}\right)^{2}}}</code> with <code class="reqn">\hat{e}_{i}=y_{i}-\mathbf{x}_{i}^{T}\left(\mathbf{X}^{T}\mathbf{X}-\mathbf{x}_{i}\mathbf{x}_{i}^{T}\right)^{-1}\left(\mathbf{X}^{T}\mathbf{y}-\mathbf{x}_{i}y_{i}\right)</code> and <code class="reqn">\tilde{e}_{i}=y_{i}-\mathbf{x}_{i}^{T}\left(\mathbf{X}^{T}\mathbf{X}+\mathbf{I}-\mathbf{x}_{i}\mathbf{x}_{i}^{T}\right)^{-1}\left(\mathbf{X}^{T}\mathbf{y}-\mathbf{x}_{i}y_{i}\right)</code> where <code class="reqn">g_{ii}</code> and <code class="reqn">h_{ii}</code> are the <code class="reqn">i</code>th diagonal elements of <code class="reqn">\mathbf{G}=\mathbf{X}\left(\mathbf{X}^{T}\mathbf{X}+\mathbf{I}\right)^{-1}\mathbf{X}^{T}</code> and <code class="reqn">\mathbf{H=}\mathbf{X}\left(\mathbf{X}^{T}\mathbf{X}\right)^{-1}\mathbf{X}^{T}</code>, respectively.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
<code>lam.GCV</code> </td>
<td style="text-align: left;"> This is the <code class="reqn">\lambda</code> value corresponding to the minimum of the generalized cross-validition (GCV) values. The GCV is computed by <code class="reqn">\frac{\mathrm{SSR}_{\lambda}}{n-1-\mathrm{trace}\left(\mathbf{H}_{\lambda}\right)}</code> where <code class="reqn">\mathrm{SSR}_{\lambda}</code> is the residual sum of squares and <code class="reqn">\mathrm{trace}\left(\mathbf{H}_{\lambda}\right)</code> is the trace of the hat matrix at corresponding value of <code class="reqn">\lambda</code> from Liu regression.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
<td style="text-align: left;"> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Value</h3>

<p>The return object is the Liu tuning parameter
estimates based on the literature.
</p>


<h3>Author(s)</h3>

<p>Murat Genç and Ömer Özbilen
</p>


<h3>References</h3>

<p>Liu, K. (1993). A new class of blased estimate in linear regression.
<em>Communications in Statistics-Theory and Methods</em>, <strong>22</strong>(2), 393-402.
<a href="https://doi.org/10.1080/03610929308831027">doi:10.1080/03610929308831027</a>.
</p>
<p>Liu, X. Q. (2011). Improved Liu estimator in a linear regression model.
<em>Journal of Statistical Planning and Inference</em>, <strong>141</strong>(1), 189-196.
<a href="https://doi.org/10.1016/j.jspi.2010.05.030">doi:10.1016/j.jspi.2010.05.030</a>.
</p>
<p>Ozkale, M. R. and Kaciranlar, S. (2007). A prediction-oriented
criterion for choosing the biasing parameter in Liu estimation.
<em>Communications in Statistics-Theory and Methods</em>, <strong>36</strong>(10), 1889-1903.
<a href="https://doi.org/10.1080/03610920601126522">doi:10.1080/03610920601126522</a>.
Imdadullah, M., Aslam, M., and Altaf, S., (2017).
liureg: A Comprehensive R Package for the Liu Estimation of Linear Regression Model with
Collinear Regressors.  <em>The R Journal</em>, <strong>9</strong>(2), 232-247.
</p>


<h3>See Also</h3>

<p><code>liureg()</code>, <code>predict()</code>, <code>summary()</code>, <code>pressliu()</code>, <code>residuals()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Hitters &lt;- na.omit(Hitters)
X &lt;- model.matrix(Salary ~ ., Hitters)[, -1]
y &lt;- Hitters$Salary
lam &lt;- seq(0, 1, 0.01)
liu.mod &lt;- liureg(X, y, lam)
lamest(liu.mod)
</code></pre>


</div>