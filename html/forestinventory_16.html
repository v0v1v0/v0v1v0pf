<div class="container">

<table style="width: 100%;"><tr>
<td>twophase</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>twophase</h2>

<h3>Description</h3>

<p><code>twophase</code> is used to calculate estimations based on double sampling under the
<em>model-assisted Monte Carlo approach</em>. A <em>first phase</em> of auxiliary information
(e.g. taken from remote sensing data) is used to generate model predictions based on multiple linear
regression  using the method of ordinary least squares. A subsample of the first phase comprises
the <em>second phase</em> which contains terrestrial observations (i.e. the <em>local densities</em>
of the ground truth) that is used to correct for bias in the design-based sense.
The estimation method is available for <em>simple</em> and <em>cluster sampling</em> and includes
the special case where the first phase is based on an <em>exhaustive</em> sample (i.e. a census).
<em>Small-area applications</em> are supported for synthetic estimation as well as two varieties
of bias-corrected estimators: the traditional small-area estimator and an asymptotically
equivalent version derived under Mandallaz' extended model approach.
</p>


<h3>Usage</h3>

<pre><code class="language-R">twophase(
  formula,
  data,
  phase_id,
  cluster = NA,
  small_area = list(sa.col = NA, areas = NA, unbiased = TRUE),
  boundary_weights = NA,
  exhaustive = NA,
  progressbar = FALSE,
  psmall = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>an object of class "<code>formula</code>" as would be used in the function <code>lm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data frame containing all variables contained in <code>formula</code> and a column indexing
phase membership.  Additional columns designating small-area membership, cluster ID and
boundary weights should also be contained in the data frame if they are
requested in the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>phase_id</code></td>
<td>
<p>an object of class "<code>list</code>" containing two elements:
</p>

<ul>
<li> <p><code>phase.col</code>: the column name in <code>data</code> that specifies the
phase membership of each observation
</p>
</li>
<li> <p><code>terrgrid.id</code>: the indicator identifying the terrestrial
(a.k.a. "ground truth") phase for that column
(must be of type "<code>numeric</code>")
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>(<em>Optional</em>) Specifies the column name in <code>data</code>
containing the cluster ID. Only used in case of
cluster sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>small_area</code></td>
<td>
<p>(<em>Optional</em>) a list that if containing three elements:
</p>

<ul>
<li> <p><code>sa.col</code>: the column name in <code>data</code> containing
domain identification
</p>
</li>
<li> <p><code>areas</code>: vector of desired small-area domain identifiers
</p>
</li>
<li> <p><code>unbiased</code>: an object of type "<code>logical</code>"
that when FALSE designates that the estimator is allowed to be
biased (i.e. the synthetic estimator) and when TRUE forces
it to be design-unbiased. See <em>'Details'</em>.
</p>
</li>
</ul>
<p><strong>Note</strong>: If <code>small_area</code> is left unchanged then <code>twophase</code> defaults to global estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary_weights</code></td>
<td>
<p>(<em>Optional</em>) Specifies the column name in <code>data</code>
containing the weights for boundary adjustment.  See <em>'Details'</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exhaustive</code></td>
<td>
<p>(<em>Optional</em>) For global estimation, a vector of true auxiliary means corresponding to
an exhaustive first phase.
The vector must be input in the same order that <code>lm</code> processes a <code>formula</code> object
and include the intercept term.
For small area estimation, <code>exhaustive</code> is a <code>data.frame</code> containing column names
(<code>colnames</code>) for every variable appearing in the parameter <code>formula</code> including
the variable "Intercept".Rownames (<code>row.names</code>) have to be used and must correspond
to the names of the small areas. See <em>'Details'</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progressbar</code></td>
<td>
<p>(<em>Optional</em>) an object a type "<code>logical</code>" that when TRUE prints
the progress of the calculation in the console (recommended for large amount of small areas).  Defaults to FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>psmall</code></td>
<td>
<p>(<em>Optional</em>) an object a type "<code>logical</code>" used for small area estimations
that only works when <code>unbiased</code> in the parameter <code>small_area</code> is set to TRUE. See <em>'Details'</em>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If estimations for multiple small-area domains should be computed, the domains have to be
defined within a <code>character</code> vector using <code>c()</code>. Using <code>small_area(..., unbiased=FALSE)</code>
calculates design-based estimates with the synthetic estimator and may be design-biased if
the model is biased in that small area.  The default, <code>small_area(..., unbiased=TRUE)</code>, allows for a residual
correction by one of two asymptotically equivalent methods to create design-unbiased estimates:
</p>

<ul>
<li>
<p> Mandallaz' extended model approach calculates the residual correction by extending the
model formula with an indicator variable in the small area.  It is the default method
<code>psmall</code>=FALSE.
</p>
</li>
<li>
<p> the traditional small area estimator calculates the residual correction by taking the
synthetic estimator and adding the mean residual observed in the small area.  It is activated
when <code>psmall</code>=TRUE.
</p>
</li>
</ul>
<p>Missing values (<code>NA</code>) in the auxiliary variables (i.e. at least one auxiliary variable cannot be observed at
an inventory location) are automatically removed from the dataset <em>before</em> the estimations are computed.
Note that missingness in the auxiliary variables is only allowed if we assume that they are <em>missing at random</em>,
since the unbiasedness of the estimates is based on the sampling design.
</p>
<p>The boundary weight adjustment is pertinent for auxiliary information derived from remote sensing and
is equal to the percentage of forested area (e.g. as defined by a forest mask) in the interpretation area.
</p>
<p>Exhaustive estimation refers to when the true means of certain auxiliary variables are known
and an exhaustive first phase (i.e. a census).  For global estimation, the vector must be input
in the same order that <code>lm</code> processes a <code>formula</code> object including the intercept term whose
true mean will always be one.  For small area estimation, <code>exhaustive</code> is a <code>data.frame</code> containing column names for every variable appearing in
the parameter <code>formula</code> including the variable "Intercept".  The observations of the data.frame
must represent the true auxiliary means in the same order as was presented in <code>areas</code> from the
parameter <code>small_area</code>.  See <em>'Examples'</em>.
</p>


<h3>Value</h3>

<p><code>twophase</code> returns an object of class <code>"twophase"</code>.
</p>
<p>An object of class <code>"twophase"</code> returns a <code>list</code> of the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>a <code>list</code> containing the function's inputs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimation</code></td>
<td>
<p>a data frame containing the following components:
</p>

<ul>
<li> <p><code>area:</code> the domain (only present if argument <code>areas</code> has been used)
</p>
</li>
<li> <p><code>estimate:</code> the point estimate
</p>
</li>
<li> <p><code>ext_variance:</code> the external variance of the point estimate that doesn't account for
fitting the model from the current inventory
</p>
</li>
<li> <p><code>g_variance:</code> the internal (g-weight) variance that accounts for
fitting the model from the current inventory
</p>
</li>
<li> <p><code>n1</code> the first phase sample size of plots
</p>
</li>
<li> <p><code>n2</code> the second phase (i.e. terrestrial) sample size of plots
</p>
</li>
<li> <p><code>n1G</code> the first phase sample size in the small area
</p>
</li>
<li> <p><code>n2G</code> the second phase (i.e. terrestrial) sample size in the small area
</p>
</li>
<li> <p><code>r.squared</code> the R squared of the linear model
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>samplesizes</code></td>
<td>
<p>a <code>data.frame</code> summarizing all samplesizes: in case of cluster sampling both,
the number of individual plots and the number of clusters is reported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>the linear model coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_coef</code></td>
<td>
<p>the design-based covariance matrix of the model coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z_bar_1G</code></td>
<td>
<p>the estimated auxiliary means of <code>formula</code> based on the first phase.
If the first phase is exhaustive, these are the true auxiliary means specified in the input-argument <code>exhaustive</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov_Z_bar_1G</code></td>
<td>
<p>the covariance matrix of <code>Z_bar_1G</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rc_x_hat_G</code></td>
<td>
<p>the small-area residuals at either the plot level or cluster level depending on the call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rc_x_hat</code></td>
<td>
<p>the residuals at either the plot level or cluster level depending on the call</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Yx_s2G</code></td>
<td>
<p>the local densities in the small area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Mx_s2G</code></td>
<td>
<p>the cluster weights in the small area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_Rc_x_hat_G</code></td>
<td>
<p>the mean residual (weighted mean in the case of cluster sampling) in the small area</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_Rc_x_hat</code></td>
<td>
<p>the mean residual (weighted mean in the case of cluster sampling)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn.messages</code></td>
<td>
<p>logical indicating if warning messages were issued</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>In the special case of cluster sampling, the reported sample sizes in <code>estimation</code> are the number of clusters.
The <code>samplesize</code>-object also provides the respective number of single plot units for cluster sampling.
The reported <code>r.squared</code> describe the model fit of the applied linear regression
model (i.e. on <em>plot-level</em>, not on <em>cluster level</em>).
</p>


<h3>References</h3>

<p>Hill, A., Massey, A. F. (2021). <em>The R Package forestinventory: Design-Based Global and Small Area Estimations for Multiphase Forest Inventories.</em> Journal of Statistical Software, 97(4), 1-40.
</p>
<p>Mandallaz, D. (2007). <em>Sampling techniques for forest inventories.</em> Chapter 4. CRC Press.
</p>
<p>Mandallaz, D. (2013). <em>Design-based properties of some small-area estimators in forest inventory with two-phase sampling.</em> Can. J. For. Res. 43: 441-449
</p>
<p>Mandallaz, D. and Hill, A. and Massey, A. (2016). <em>Design-based properties of some small-area estimators in forest inventory with two-phase sampling.</em> ETH Zurich, Department of Environmental Systems Science,Tech. rep. Available from <a href="http://e-collection.library.ethz.ch">http://e-collection.library.ethz.ch</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## load datasets:
data(grisons)
data(zberg)

# ------------------------------------------------#
# ----------- GLOBAL ESTIMATION ------------------#

#----
## 1) -- Design-based estimation with non-exhaustive auxiliary information
#----

# 1.1) non-cluster-sampling:
summary(twophase(formula = tvol ~mean + stddev + max + q75,
                 data = grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2)))

# 1.2) cluster-sampling (see eqns. [57] and [58] in Mandallaz, Hill, Massey 2016):
summary(twophase(formula = basal ~ stade + couver + melange,
                data = zberg,
                phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                cluster = "cluster"))

# 1.3) example for boundary weight adjustment (non-cluster example):
summary(twophase(formula=tvol ~ mean + stddev + max + q75,
                 data=grisons,
                 phase_id=list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 boundary_weights = "boundary_weights"))

#----
## 2) -- Design-based estimation with exhaustive auxiliary information
#----

# establish order for vector of true auxiliary means:
colnames(lm(formula = tvol ~ mean + stddev + max + q75, data = grisons, x = TRUE)$x)
true.means &lt;- c(1, 11.39, 8.84, 32.68, 18.03)

# 2.1) non-cluster-sampling:
summary(twophase(formula = tvol ~ mean + stddev + max + q75,
                 data = grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 exhaustive = true.means))

# 2.2) cluster-sampling:
summary(twophase(formula = stem ~ stade + couver + melange,
                 data = zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 exhaustive = c(1, 0.10, 0.7, 0.10, 0.6, 0.8)))


# ----------------------------------------------------#
# ----------- SMALL AREA ESTIMATION ------------------#

#----
## 1) -- Design-based estimation with non-exhaustive auxiliary information
#----

# 1.1) Mandallaz's extended pseudo small area estimator (see eqns. [35] and [36] in Mandallaz 2013):
summary(twophase(formula = tvol ~ mean + stddev + max + q75, data = grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 small_area = list(sa.col = "smallarea", areas = c("A", "B","C", "D"),
                                   unbiased = TRUE)))

summary(twophase(formula = basal ~ stade + couver + melange, data=zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 small_area = list(sa.col = "ismallg23", areas = c("2", "3"),
                                   unbiased = TRUE)))


# 1.2) pseudo small area estimator (see eqns. [25] and [26] in Mandallaz 2013):
summary(twophase(formula = tvol ~ mean + stddev + max + q75, data = grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 small_area = list(sa.col = "smallarea", areas = c("A", "B"),
                                   unbiased = TRUE),
                 psmall = TRUE))

summary(twophase(formula = basal ~ stade + couver + melange, data=zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 small_area = list(sa.col = "ismallg23", areas = c("2", "3"),
                                   unbiased = TRUE),
                 psmall = TRUE))


# 1.3) pseudosynthetic small area estimator (see eqns. [35] and [36] in Mandallaz 2013):
summary(twophase(formula = tvol ~ mean + stddev + max + q75, data=grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 small_area = list(sa.col = "smallarea", areas = c("B", "A"),
                                   unbiased = FALSE)))

summary(twophase(formula = basal ~ stade + couver + melange, data=zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 small_area = list(sa.col = "ismallg23", areas = c("2", "3"),
                                   unbiased = FALSE)))


#----
## 2) -- Design-based estimation with exhaustive auxiliary information
#----

# establish order for vector of true auxiliary means:
colnames(lm(formula = tvol ~ mean + stddev + max + q75, data = grisons, x = TRUE)$x)
colnames(lm(formula = basal ~ stade + couver + melange, data = zberg, x = TRUE)$x)

# true auxiliary means taken from Mandallaz et al. (2013):
truemeans.G &lt;- data.frame(Intercept = rep(1, 4),
                         mean = c(12.85, 12.21, 9.33, 10.45),
                         stddev = c(9.31, 9.47, 7.90, 8.36),
                         max = c(34.92, 35.36, 28.81, 30.22),
                         q75 = c(19.77, 19.16, 15.40, 16.91))
rownames(truemeans.G) &lt;- c("A", "B", "C", "D")

# true auxiliary means taken from Mandallaz (1991):
truemeans.G.clust &lt;- data.frame(Intercept = 1,
                               stade400 = 0.175,
                               stade500 = 0.429,
                               stade600 = 0.321,
                               couver2 = 0.791,
                               melange2 = 0.809)
rownames(truemeans.G.clust) &lt;- c("1")


# 2.1) Mandallaz's extended small area estimator (see eqns. [31] and [33] in Mandallaz 2013):
summary(twophase(formula = tvol ~ mean + stddev + max + q75, data = grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 small_area = list(sa.col ="smallarea", areas = c("A", "B"),
                                   unbiased = TRUE),
                 exhaustive = truemeans.G))

summary(twophase(formula = basal ~ stade + couver + melange, data=zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 small_area = list(sa.col = "ismallold", areas = c("1"),
                                   unbiased = TRUE),
                 exhaustive = truemeans.G.clust))


# 2.2) small area estimator (see eqns. [20] and [21] in Mandallaz 2013):
summary(twophase(formula = tvol ~ mean + stddev + max + q75, data = grisons,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 small_area = list(sa.col = "smallarea", areas = c("A"),
                                   unbiased = TRUE),
                 exhaustive = truemeans.G, psmall = TRUE))

summary(twophase(formula = basal ~ stade + couver + melange, data = zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 small_area = list(sa.col ="ismallold", areas = c("1"),
                                   unbiased = TRUE),
                 psmall = TRUE,
                 exhaustive = truemeans.G.clust))


# 2.3) synthetic small area estimator (see eqns. [18] and [19] in Mandallaz 2013):
summary(twophase(formula=tvol ~ mean + stddev + max + q75, data=grisons,
                 phase_id=list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 small_area=list(sa.col = "smallarea", areas = c("A", "B"),
                                 unbiased = FALSE),
                 exhaustive = truemeans.G))

summary(twophase(formula = basal ~ stade + couver + melange, data = zberg,
                 phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
                 cluster = "cluster",
                 small_area = list(sa.col = "ismallold", areas = c("1"),
                                   unbiased = FALSE),
                 exhaustive = truemeans.G.clust))

</code></pre>


</div>