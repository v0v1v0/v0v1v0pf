<div class="container">

<table style="width: 100%;"><tr>
<td>optim.np</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Smoothing of functional data using nonparametric kernel estimation</h2>

<h3>Description</h3>

<p>Smoothing of functional data using nonparametric kernel
estimation with cross-validation (CV) or generalized cross-validation 
(GCV) methods.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optim.np(
  fdataobj,
  h = NULL,
  W = NULL,
  Ker = Ker.norm,
  type.CV = GCV.S,
  type.S = S.NW,
  par.CV = list(trim = 0, draw = FALSE),
  par.S = list(),
  correl = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdataobj</code></td>
<td>
<p><code>fdata</code> class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Smoothing parameter or bandwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>Matrix of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ker</code></td>
<td>
<p>Type of kernel used, by default normal kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.CV</code></td>
<td>
<p>Type of cross-validation. By default generalized
cross-validation (GCV) method. Possible values are <em>GCV.S</em> and
<em>CV.S</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.S</code></td>
<td>
<p>Type of smothing matrix <code>S</code>. By default <code>S</code> is
calculated by Nadaraya-Watson kernel estimator (<code>S.NW</code>). Possible
values are <code>S.KNN</code>,  <code>S.LLR</code>, 
<code>S.LPR</code> and  <code>S.LCR</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.CV</code></td>
<td>
<p>List of parameters  for type.CV: <code>trim</code>, the alpha of the
trimming and <code>draw=TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.S</code></td>
<td>
<p>List of parameters for <code>type.S</code>:
<code>tt</code> for argvals,  <code>h</code> for bandwidth,  
<code>Ker</code> for kernel, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correl</code></td>
<td>
<p>logical. If <code>TRUE</code> the bandwidth parameter <code>h</code> is computed following the 
procedure described for De  Brabanter et al. (2018). (option avalaible since v1.6.0 version)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If <code>TRUE</code> information about GCV values and input
parameters is printed. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods. Arguments to
be passed for kernel method.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Calculate the minimum GCV for a vector of values of the smoothing parameter
<code>h</code>.
Nonparametric smoothing is performed by the kernel function.
The type of kernel to use with the parameter <code>Ker</code> and the type of
smothing matrix <code>S</code> to use with the parameter <code>type.S</code> can be
selected by the user, see function <code>Kernel</code>.
W is the matrix of weights of the discretization points.
</p>


<h3>Value</h3>

<p>Returns GCV or CV values calculated for input parameters.
</p>

<ul>
<li> <p><code>gcv</code> GCV or CV for a vector of values of the smoothing parameter
<code>h</code>  
</p>
</li>
<li> <p><code>fdataobj</code> <code>fdata</code> class object.
</p>
</li>
<li> <p><code>fdata.est</code> Estimated <code>fdata</code> class object. 
</p>
</li>
<li> <p><code>h.opt</code> <code>h</code> value that minimizes CV or GCV method. 
</p>
</li>
<li> <p><code>S.opt</code> Smoothing matrix for the minimum CV or GCV method. 
</p>
</li>
<li> <p><code>gcv.opt</code> Minimum of CV or GCV method. 
</p>
</li>
<li> <p><code>h</code> Smoothing parameter or bandwidth.
</p>
</li>
</ul>
<h3>Note</h3>

<p>min.np deprecated.
</p>


<h3>Author(s)</h3>

<p>Manuel Febrero-Bande, Manuel Oviedo de la Fuente
<a href="mailto:manuel.oviedo@udc.es">manuel.oviedo@udc.es</a>
</p>


<h3>References</h3>

<p>Ferraty, F. and Vieu, P. (2006). <em>Nonparametric functional
data analysis.</em> Springer Series in Statistics, New York.
</p>
<p>Wasserman, L. <em>All of Nonparametric Statistics</em>. Springer Texts in
Statistics, 2006.
</p>
<p>Hardle, W. <em>Applied Nonparametric Regression</em>. Cambridge University
Press, 1994. 
</p>
<p>De Brabanter, K., Cao, F., Gijbels, I., Opsomer, J. (2018). Local polynomial regression with correlated errors in random design and
unknown correlation structure.  <em>Biometrika</em>, 105(3), 681-69.
</p>
<p>Febrero-Bande, M., Oviedo de la Fuente, M. (2012). Statistical Computing in
Functional Data Analysis: The R Package fda.usc. <em>Journal of
Statistical Software</em>, 51(4), 1-28. <a href="https://www.jstatsoft.org/v51/i04/">https://www.jstatsoft.org/v51/i04/</a>
</p>


<h3>See Also</h3>

<p>Alternative method:  <code>optim.basis</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Exemple, phoneme DATA
data(phoneme)
mlearn&lt;-phoneme$learn[1:100]

out1&lt;-optim.np(mlearn,type.CV=CV.S,type.S=S.NW)
np&lt;-ncol(mlearn)
# variance calculations
y&lt;-mlearn
out&lt;-out1
i&lt;-1
z=qnorm(0.025/np)
fdata.est&lt;-out$fdata.est
tt&lt;-y[["argvals"]]
var.e&lt;-Var.e(y,out$S.opt)
var.y&lt;-Var.y(y,out$S.opt)
var.y2&lt;-Var.y(y,out$S.opt,var.e)

# plot estimated fdata and point confidence interval
upper.var.e&lt;-fdata.est[i,]-z*sqrt(diag(var.e))
lower.var.e&lt;-fdata.est[i,]+z*sqrt(diag(var.e))
dev.new()
plot(y[i,],lwd=1, 
ylim=c(min(lower.var.e$data),max(upper.var.e$data)),xlab="t")
lines(fdata.est[i,],col=gray(.1),lwd=1)
lines(fdata.est[i,]+z*sqrt(diag(var.y)),col=gray(0.7),lwd=2)
lines(fdata.est[i,]-z*sqrt(diag(var.y)),col=gray(0.7),lwd=2)
lines(upper.var.e,col=gray(.3),lwd=2,lty=2)
lines(lower.var.e,col=gray(.3),lwd=2,lty=2)
legend("bottom",legend=c("Var.y","Var.error"),
col = c(gray(0.7),gray(0.3)),lty=c(1,2))

## End(Not run)

</code></pre>


</div>