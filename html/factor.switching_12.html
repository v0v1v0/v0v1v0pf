<div class="container">

<table style="width: 100%;"><tr>
<td>weighted_procrustes_switching</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Weighted Orthogonal Procrustes rotations
</h2>

<h3>Description</h3>

<p>Weighted Orthogonal Procrustes (WOP) post-processing (Assmann et al. 2016) augmented with a final varimax rotation as implemented in Papastamoulis and Ntzoufras (2020). The algorithm uses the <code>procrustes</code> function of the MCMCpack package. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">weighted_procrustes_switching(lambda_mcmc, maxIter, threshold, verbose, 
    weight, printIter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lambda_mcmc</code></td>
<td>

<p>Input matrix containing a MCMC sample of factor loadings. The column names should read as 'LambdaV1_1',..., 'LambdaV1_q', ..., 'LambdaVp_1',..., 'LambdaVp_q', where <code class="reqn">p</code> and <code class="reqn">q</code> correspond to the number of variables and factors, respectively. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxIter</code></td>
<td>

<p>Maximum number of iterations of the RSP algorithm. Default: 100.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>

<p>Positive threshold for declaring convergence. The actual convergence criterion is <code>threshold</code> m p q with m denoting the number of MCMC iterations. Default: 1e-6.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Logical value indicating whether to print intermediate output or not. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>This is argument is always set to TRUE. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printIter</code></td>
<td>

<p>Print the progress of the algorithm when processing <code>printIter</code> MCMCdraws, per iteration. Default: 1000.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lambda_reordered_mcmc </code></td>
<td>
<p>Post-processed MCMC sample of factor loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda_hat </code></td>
<td>
<p>The resulting average of the post-processed MCMC sample of factor loadings.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective_function </code></td>
<td>
<p>A two-column matrix containing the time-to-reach and the value of the objective function for each iteration.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Panagiotis Papastamoulis
</p>


<h3>References</h3>

<p>Assmann, C., Boysen-Hogrefem J. and Pape M. (2016). 
Bayesian analysis of static and dynamic factor models: An ex-post approach towards the rotation problem.
<em>Journal of Econometrics</em>: 192 (1): Pages 190-206. 
</p>
<p>Martin AD, Quinn KM, Park JH (2011). 
MCMCpack: Markov Chain Monte Carlo in R. 
<em>Journal of Statistical Software</em>: 42(9), 22.
</p>
<p>Papastamoulis, P. and Ntzoufras, I. (2020).
On the identifiability of Bayesian Factor Analytic models.
<em>arXiv:2004.05105 [stat.ME]</em>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load small mcmc sample of 100 iterations
#	with p=6 variables and q=2 factors.
data(small_posterior_2chains)
# post-process it
reorderedPosterior &lt;- weighted_procrustes_switching(
	lambda_mcmc = small_posterior_2chains[[1]])
# summarize the post-processed MCMC sample with coda
summary(reorderedPosterior$lambda_reordered_mcmc)
</code></pre>


</div>