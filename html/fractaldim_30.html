<div class="container">

<table style="width: 100%;"><tr>
<td>fd.estim.method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation of Fractal Dimension via Specific Methods</h2>

<h3>Description</h3>

<p>The functions estimate a fractal dimension of the given data. Each function uses a different method. Functions for boxcount, hallwood, variogram, madogram, rodogram, variation, incr1, genton, periodogram, wavelet and dctII methods are to be used on one-dimensional time series. The remaining functions (transect, isotropic, squareincr, and filter1) are to be used on two-dimensional data. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">fd.estim.boxcount (data, plot.loglog = FALSE, nlags = "auto", 
    shift.up=TRUE, plot.allpoints = FALSE, legend.type = 's', 
    ..., debuglevel = 0)
fd.estim.hallwood (data, plot.loglog = FALSE, nlags = "auto", 
    plot.allpoints = FALSE, legend.type = 's', ..., debuglevel = 0)
fd.estim.variogram (data, ...)
fd.estim.madogram (data, ...)
fd.estim.rodogram (data, ...)
fd.estim.variation (data, p.index = 1, ...)
fd.estim.incr1(data, p.index=2, ...)
fd.estim.genton (data, ...)
fd.estim.periodogram (data, plot.loglog = FALSE, nlags = "auto", ...)
fd.estim.wavelet (data, plot.loglog=FALSE, plot.allpoints = FALSE, 
    filter = "haar", J1 = max(1,floor(log2(length(data))/3-1)), 
    J0 = floor(log2(length(data))), legend.type = 's', 
    ..., debuglevel = 0)
fd.estim.dctII (data, plot.loglog = FALSE, nlags = "auto", ...)
    
fd.estim.transect.var (data, p.index = 2, ...)
fd.estim.transect.incr1 (data, p.index = 2, ...)
fd.estim.isotropic (data, p.index = 2, direction = 'hvd+d-',
    plot.loglog = FALSE, nlags = "auto", plot.allpoints = FALSE, 
    legend.type = 's', ..., debuglevel=0)
fd.estim.squareincr (data, p.index = 2, 
    plot.loglog = FALSE, nlags = "auto", plot.allpoints = FALSE, 
    legend.type = 's', ..., debuglevel=0)
fd.estim.filter1 (data, p.index = 2, direction = 'hvd+d-',
    plot.loglog = FALSE, nlags = "auto", plot.allpoints = FALSE, 
    legend.type = 's', ..., debuglevel=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>For the first eleven functions <code>data</code> is a one-dimensional vector. For the last five functions <code>data</code> is a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.index</code></td>
<td>
<p>Parameter <code class="reqn">p</code> of the variation method (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>For the 2d estimators, this argument specifies the direction of the estimation (see details below). It can be any combination of the characters ‘h’ (horizontal), ‘v’ (vertical), ‘d+’ (diagonal with positive gradient), and ‘d-’ (diagonal with negative gradient). These characters should be combined into one string.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.loglog</code></td>
<td>
<p>Logical value determining if the underlying log-log
plots should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlags</code></td>
<td>
<p>Number of lags to be used in the
estimation. Possible values are <code>"auto"</code>, <code>"all"</code> or a
single number.  If <code>nlags = "auto"</code>, each method sets the number of lags
to the theoretically "best" value for that method.  <code>"all"</code> means
that all lags are included in the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift.up</code></td>
<td>
<p>For each interval on the horizontal axis, it moves the boxes vertically up to the smallest data point of that interval. If it is <code>FALSE</code>, all boxes are on a regular grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.allpoints</code></td>
<td>
<p>Logical. If <code>FALSE</code>, only points that were considered in 
the regression are shown. Otherwise, all points of the log-log 
plot are shown in the graph and those considered in the regression are marked by filled circles.
This argument is only used if 
<code>plot.loglog = TRUE</code>.  Note that setting this argument to <code>TRUE</code> might (depending on the method)
considerably increase the computation run-time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>Argument passed to the <code>modwt</code> function of the <span class="pkg">wavelets</span> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>J0, J1</code></td>
<td>
<p>Parameters of the wavelet method controlling the number of frequencies used in the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>legend.type</code></td>
<td>
<p>One of the characters 'f', 's', or 'n'. It controlls the amount of information in the legend of the log-log plot. If it is 'f' (full), values of fd and scale, including the raw values of the corresponding slope and intercept are shown. If it is 's' (short), only fd is shown. Value of 'n' (None) causes no legend being plotted. The argument is only used if <code>plot.loglog = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to the plotting function if <code>plot.loglog = TRUE</code>. For some functions, ... contain additional arguments, see Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debuglevel</code></td>
<td>
<p>Controls the amount of debugging
messages. The functions produce messages on level 5.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The methodology of these functions is based on the theory
described in Gneiting et al (2010). Please refer to this paper for notation. Here we give only a few comments about the implementation.
</p>




<dl>
<dt><em>Box-count
estimator:</em></dt>
<dd>









<p>The function <code>fd.estim.boxcount</code> determines the smallest possible value of <code class="reqn">m</code> 
for which <code class="reqn">n\leq 2^m</code> is a power of 2.  Only data points <code class="reqn">x_1,\dots,x_{n_{eff}}</code> are considered for the estimation, 
where <code class="reqn">n_{eff} = 2^{m-1}+1</code>.  The value of <code class="reqn">K</code> can be given by the user through the argument <code>nlags</code>.  If <code>nlags = "auto"</code>, box sizes <code class="reqn">\epsilon_k</code> for <code class="reqn">k=j,j+1,\dots,m-2</code> are considered, 
where for all <code class="reqn">i&lt;j</code> is <code class="reqn">N(\epsilon_i) &gt; \frac{n_{eff}}{5}</code>, i.e. 
the two largest box sizes and very small boxes are eliminated (corresponds to the
Liebovitch and Toth modification).
</p>
<p>If <code>shift.up=TRUE</code>, the algorithm shifts each vertical column of boxes up to the smallest data value in that column. 
</p>
<p><code class="reqn">N(\epsilon_k)</code> for a particular box is increased if either a data point is contained in the box, 
or if a line connecting two neighboring data points crosses the box.
</p>
</dd>
<dt><em>Hall-Wood estimator</em></dt>
<dd>
<p>This estimator is a version of box-count that 
instead of number of boxes considers the area of boxes that cover 
the underlying curve.  















Hall and Wood (1993) recommend
the use of <code class="reqn">L = 2</code> which the function <code>fd.estim.hallwood</code> uses
if the arguments <code>nlags = "auto"</code>.
</p>
</dd>
<dt><em>Variation, Variogram, Madogram, Rodogram, and Incr1 estimators:</em></dt>
<dd>
<p>The <code>p.index</code> argument of <code>fd.estim.variation</code> and <code>fd.estim.incr1</code> is the power index <code class="reqn">p</code>. The madogram, variogram, and rodogram, respectively, correspond to the Variation estimator with <code class="reqn">p</code> equals 1, 2, and 1/2, respectively. The Incr1 estimator is like Variation but based on second order differences.




</p>








<p>Any argument that can be passed to <code>fd.estim.hallwood</code> can be passed here as well. In addition,
as in the Hall-Wood case, <code class="reqn">L</code> is set to 2 for these estimators, if <code>nlags = "auto"</code>.
</p>
</dd>
<dt><em>Genton robust estimator:</em></dt>
<dd>
<p>This is a highly robust variogram estimator as proposed by Genton (1998). Given <code class="reqn">U_i(d) = X_{i/n} - X_{(i-d)/n}</code>, define
</p>
<p style="text-align: center;"><code class="reqn">
\hat{V}(d) = \left[2.2191\{|U_i(d) - U_j(d)|; i&lt;j \}_{(k)}\right]^2 ,
\quad \mbox{where} \;\; k={\lfloor (n-d)/2\rfloor +1 \choose 2}\,.</code>
</p>

<p>Thus, the estimator is derived from the <code class="reqn">k</code>-th quantile of the <code class="reqn">U_i(d)</code> values. The <code class="reqn">\hat{D}_k</code> estimator is derived from the log-log plot of <code class="reqn">\log(d)</code> against <code class="reqn">\log(\hat{V}(d))</code>. The implementation uses the <code>qn</code> function of the <span class="pkg">pcaPP</span> package to compute <code class="reqn">\hat{V}(d)</code>.
</p>
<p>Here again, the number of lags is set to 2 if  <code>nlags = "auto"</code> and any arguments of the <code>fd.estim.hallwood</code> are accepted here as well.
</p>
</dd>
<dt><em>Periodogram estimator:</em></dt>
<dd>
<p>The method is implemented as proposed by Chan et al. (1995) with notation from Gneiting et al (2010).  







</p>















<p>As Chan et al. (1995) recommend, we use <code class="reqn">L=\lfloor \min(m/2, n^{2/3})\rfloor</code> if <code>nlags = "auto"</code>. Any arguments of the <code>fd.estim.hallwood</code> are also accepted here.
</p>
</dd>
<dt><em>Wavelet estimator:</em></dt>
<dd>
<p>This method uses <code class="reqn">J_0</code> vectors of wavelet coefficients  which are obtained using the function <code>modwt</code> of the <span class="pkg">wavelets</span> package. The choice of <code>J0</code> and <code>J1</code> determine the number of frequencies used in the estimation.

















</p>
</dd>
<dt><em>DCT-II estimator:</em></dt>
<dd>
<p>If <code>nlags = "auto"</code>, we use <code class="reqn">L=\lfloor \min(2m, 4n^{2/3})\rfloor</code>. Any arguments of the <code>fd.estim.hallwood</code> are also accepted here.
</p>
</dd>
</dl>
<p>The two-dimensional estimators are all based on the Variation method with the power index <code class="reqn">p</code> (argument <code>p.index</code>) with the following alternatives:
</p>

<dl>
<dt><em>Transect</em></dt>
<dd>
<p>For every given direction, a variation estimate (or a variant that uses second differences) is found in each row (for horizontal direction) and/or column (for vertical direction). The resulting estimate is the median over the set of estimates. In the function <code>fd.estim.transect.var</code> the line transect estimates are based on first differences; In the function <code>fd.estim.transect.incr1</code> they are based on second differences.
</p>
<p>This method does not support the feature of creating a log-log plot, since there are many log-log regressions from which the results are derived. The methods also accept arguments <code>direction</code>, <code>nlags</code> and <code>debuglevel</code>. </p>
</dd>
<dt><em>Isotropic</em></dt>
<dd>
<p>Davies and Hall (1999) on page 12 define the isotropic empirical variogram. This is here implemented more generally using the variation estimator. If <code>nlags = "auto"</code>, the number of lags is set to either 3 if diagonal direction is used together with either horizontal or vertical direction or both. If only horizontal or/and vertical direction is used, the number of lags is set to 2.</p>
</dd>
<dt><em>Square-increment</em></dt>
<dd>
<p>We use the square-increment estimator proposed in eqs. (4.2) through (4.7) of Chan and Wood (2000). Note that this method is equivalent to the Filter 3 approach of Zhu and Stein (2002) which is the way it is implemented in the package. The automatic setting of number of lags is done as for the Isotropic method.</p>
</dd>
<dt><em>Filter 1</em></dt>
<dd>
<p>Here,  the Filter 1 approach of Zhu and Stein (2002) is implemented. Again, the automatic setting of number of lags is done as for the Isotropic method.</p>
</dd>
</dl>
<p>For all methods (but Transect), if the argument <code>plot.loglog</code> is <code>TRUE</code>, a graph with the log-log plot is shown,
including the fitted regression line.  Only points included in the regression are plotted, unless the argument <code>plot.allpoints</code> is set to <code>TRUE</code>. In such a case, points used for fitting the regression line are marked by filled circles.
</p>
<p>For using multiple estimation methods via one function see <code>fd.estimate</code>.
</p>


<h3>Value</h3>

<p>Each function returns an object of class <code>FractalDim</code> with elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Here it is always 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fd, scale</code></td>
<td>
<p>Single value, namely the estimated fractal dimension and scale, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methods, methods.coding</code></td>
<td>
<p>Method name and code used for the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window.size, step.size</code></td>
<td>
<p>Size of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.dim</code></td>
<td>
<p>Dimension of the data used for the estimation. It is either one or two.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglog</code></td>
<td>
<p>Object of class <code>FDloglog</code> used for the estimation.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Function <code>fd.estimate</code> can be used as a wrapper for these functions.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Don Percival, Tilmann Gneiting</p>


<h3>References</h3>

<p>Chan, G., Hall, P., Poskitt, D. (1995) Periodogram-Based Estimators of Fractal
Properties. Annals of Statistics <b>23</b> (5), 1684–1711.
</p>
<p>Chan, G., Wood, A. (2000) Increment-based estimators of fractal dimension for two-dimensional surface data.
Statistica Sinica <b>10</b>, 343–376.
</p>
<p>Davies, S., Hall, P. (1999) Fractal analysis of surface roughness by using spatial data.
Journal of the Royal Statistical Society Series B <b>61</b>, 3–37.
</p>
<p>Genton, M. G. (1998) Highly robust variogram estimation. Mathematical Geology <b>30</b>, 213–221.
</p>
<p>Gneiting, T., Sevcikova, H. and Percival, D. B. (2012). Estimators of fractal dimension: Assessing the smoothness of time series and spatial data. Statistical Science, 27(2), 247-277. (Version as technical report available at <a href="https://stat.uw.edu/sites/default/files/files/reports/2010/tr577.pdf">https://stat.uw.edu/sites/default/files/files/reports/2010/tr577.pdf</a>)
</p>
<p>Hall, P., Wood, A. (1993) On the Performance of Box-Counting Estimators of
Fractal Dimension. Biometrika <b>80</b> (1), 246–252.
</p>
<p>Zhu, Z., Stein, M. (2002) Parameter estimation for fractional Brownian surfaces.
Statistica Sinica <b>12</b>, 863–883.
</p>


<h3>See Also</h3>

<p><code>fd.estimate</code></p>


<h3>Examples</h3>

<pre><code class="language-R">if (requireNamespace("RandomFields", quietly = TRUE)) withAutoprint({
library(RandomFields)
# 1d time series
n &lt;- 256
rf &lt;- GaussRF(x = c(0,1, 1/n), model = "stable", 
    grid = TRUE, gridtriple = TRUE,
    param = c(mean=0, variance=1, nugget=0, scale=1, kappa=1))
par(mfrow=c(4,2))
fd.estim.variogram (rf, nlags = 20, plot.loglog = TRUE)
fd.estim.variation (rf, nlags = 20, plot.loglog = TRUE)
fd.estim.variogram (rf,  nlags = 3, plot.loglog = TRUE, 
    plot.allpoints = TRUE)
fd.estim.variation (rf, plot.loglog = TRUE, plot.allpoints = TRUE)
fd.estim.hallwood (rf, nlags = 10, plot.loglog = TRUE)
fd.estim.boxcount (rf, nlags = "all", plot.loglog = TRUE, 
    plot.allpoints = TRUE)
fd.estim.periodogram (rf, plot.loglog = TRUE)
fd.estim.dctII (rf, plot.loglog = TRUE)

# 2d random fields
n &lt;- 128
rf2d &lt;- GaussRF(x = c(0,1, 1/n), y = c(0,1, 1/n), model = "stable", 
    grid = TRUE, gridtriple = TRUE,
    param = c(mean=0, variance=1, nugget=0, scale=1, kappa=1))
par(mfrow=c(1,3))
fd.estim.isotropic (rf2d, p.index = 1, direction='hv',
                       plot.loglog = TRUE, plot.allpoints = TRUE)
fd.estim.squareincr (rf2d, p.index = 1, plot.loglog = TRUE, plot.allpoints = TRUE)
fd.estim.filter1 (rf2d, p.index = 1, plot.loglog = TRUE, plot.allpoints = TRUE)
})
</code></pre>


</div>