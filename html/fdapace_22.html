<div class="container">

<table style="width: 100%;"><tr>
<td>FCReg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional Concurrent Regression using 2D smoothing</h2>

<h3>Description</h3>

<p>Functional concurrent regression with dense or sparse functional data for scalar or functional dependent variables. Note: function-to-scalar regression can also be handled using the VCAM function in fdapace.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FCReg(
  vars,
  userBwMu,
  userBwCov,
  outGrid,
  kern = "gauss",
  measurementError = TRUE,
  diag1D = "none",
  useGAM = FALSE,
  returnCov = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>A list of input functional/scalar covariates. Each field corresponds to a functional (a list) or scalar (a vector) covariate. The last entry is assumed to be the response if no entry is names 'Y'. If a field corresponds to a functional covariate, it should have two fields: 'Lt', a list of time points, and 'Ly', a list of function values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>userBwMu</code></td>
<td>
<p>A scalar with bandwidth used for smoothing the mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>userBwCov</code></td>
<td>
<p>A scalar with bandwidth used for smoothing the auto- and cross-covariances</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outGrid</code></td>
<td>
<p>A vector with the output time points</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kern</code></td>
<td>
<p>Smoothing kernel choice, common for mu and covariance; "rect", "gauss", "epan", "gausvar", "quar" (default: "gauss")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>measurementError</code></td>
<td>
<p>Indicator measurement errors on the functional observations should be assumed. If TRUE the diagonal raw covariance will be removed when smoothing. (default: TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diag1D</code></td>
<td>
<p>A string specifying whether to use 1D smoothing for the diagonal line of the covariance. 
'none': don't use 1D smoothing; 'cross': use 1D only for cross-covariances; 'all': use 1D for both auto- and cross-covariances. (default : 'none')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useGAM</code></td>
<td>
<p>Indicator to use gam smoothing instead of local-linear smoothing (semi-parametric option) (default: FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnCov</code></td>
<td>
<p>Indicator to return the covariance surfaces, which is a four dimensional array. The first two dimensions correspond to outGrid
and the last two correspond to the covariates and the response, i.e. (i, j, k, l) entry being Cov(X_k(t_i), X_l(t_j)) (default: FALSE)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If measurement error is assumed, the diagonal elements of the raw covariance will be removed. This could result in highly unstable estimate if the design is very sparse, or strong seasonality presents. 
WARNING! For very sparse functional data, setting measurementError = TRUE is not recommended.
</p>


<h3>Value</h3>

<p>A list containing the following fields:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A matrix for the concurrent regression effects, where rows correspond to different predictors and columns to different time points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta0</code></td>
<td>
<p>A vector containing the time-varying intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outGrid</code></td>
<td>
<p>A vector of the output time points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>A 4-dimensional array for the (cross-)covariance surfaces, with the (i, j, k, l) entry being Cov(X_k(t_i), X_l(t_j))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R2</code></td>
<td>
<p>A vector of the time-varying R2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The sample size.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p><cite>Yao, F., Müller, H.G., Wang, J.L. "Functional Linear Regression Analysis for Longitudinal Data." Annals of Statistics 33, (2005): 2873-2903.(Dense data)</cite> 
<cite>Sentürk, D., Müller, H.G. "Functional varying coefficient models for longitudinal data." J. American Statistical Association, 10, (2010): 1256–1264.</cite>
<cite>Sentürk, D., Nguyen, D.V. "Varying Coefficient Models for Sparse Noise-contaminated Longitudinal Data", Statistica Sinica 21(4), (2011): 1831-1856. (Sparse data)</cite>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Y(t) = \beta_0(t) + \beta_1(t) X_1(t) + \beta_2(t) Z_2 + \epsilon

# Settings
set.seed(1)
n &lt;- 75
nGridIn &lt;- 150
sparsity &lt;- 5:10 # Sparse data sparsity
T &lt;- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw &lt;- 0.1
outGrid &lt;- round(seq(min(T), 1, by=0.05), 2)

# Simulate functional data 
mu &lt;- T * 2 # mean function for X_1
sigma &lt;- 1

beta_0 &lt;- 0
beta_1 &lt;- 1
beta_2 &lt;- 1

Z &lt;- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 &lt;- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon &lt;- rnorm(n, sd=sigma)
Y &lt;- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
  Y[i, ] &lt;- beta_0 + beta_1 * X_1[i, ] + beta_2 * Z[i, 2] + epsilon[i]
}

# Sparsify functional data
set.seed(1)
X_1sp &lt;- Sparsify(X_1, T, sparsity)
set.seed(1)
Ysp &lt;- Sparsify(Y, T, sparsity)
vars &lt;- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
withError2D &lt;- FCReg(vars, bw, bw, outGrid)
</code></pre>


</div>