<div class="container">

<table style="width: 100%;"><tr>
<td>Cross Validation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Generalised Rolling Origin Evaluation
</h2>

<h3>Description</h3>

<p>This function implements the Generalised Rolling Origin Evaluation of Fioruci et al (2015).
Its particular cases include the cross validation methods: Rolling Origin Evaluation and Fixed Origin Evaluation of Tashman(2000).

</p>


<h3>Usage</h3>

<pre><code class="language-R">	groe(y, forecFunction, g="sAPE", n1=length(y)-10, m=5,
	        H=length(y)-n1, p=1+floor((length(y)-n1)/m), ...)

	rolOrig(y, forecFunction, g="sAPE", n1=length(y)-10, ...)

	fixOrig(y, forecFunction, g="sAPE", n1=length(y)-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>Object of time series class or a vector

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forecFunction</code></td>
<td>

<p>A forecasting method as one object of the <code>forecast</code> class of forecast package.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>

<p>The prediction error type of <code>errorMetric</code> function. The possible values are <code>"sAPE", "APE", "AE"</code> and <code>"SE"</code>.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n1</code></td>
<td>

<p>The index of the first origin element.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>

<p>The number of movements of the origin in each update.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>

<p>The number of predictions forward of each origin.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>

<p>The number of origin updates.
Default is the maximum.

</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments for <code>forecFunction</code>.

</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>m=1</code> is computed the Rolling Origin Evaluation.
If <code>m&gt;=length(y)-n1</code> is computed the Fixed Origin Evaluation.

</p>


<h3>Value</h3>

<p>The sum of the prediction errors.





</p>


<h3>Note</h3>

<p>The <code>otm.arxiv</code> function use this function for estimate the theta parameter when the <code>theta</code> argument is <code>NULL</code>.
Your computer may go into an infinite looping if you use <code>forecFunction = otm.arxiv</code> without specific a numeric value for the <code>theta</code> argument.

</p>


<h3>Author(s)</h3>

<p>Jose Augusto Fiorucci and Francisco Louzada

</p>


<h3>References</h3>

<p>Fioruci J.A., Pellegrini T.R., Louzada F., Petropoulos F. (2015). <em>The Optimised Theta Method</em>. arXiv preprint, arXiv:1503.03529.
</p>
<p>Tashman, L.J. (2000). <em>Out-of-sample tests of forecasting accuracy: an analysis and review</em>. International Journal of Forecasting 16 (4), 437â€“450.

</p>


<h3>See Also</h3>

<p><code>forecTheta-package</code>, <code>dotm</code>, <code>otm.arxiv</code>

</p>


<h3>Examples</h3>

<pre><code class="language-R">y1 = 2+ 0.15*(1:20) + rnorm(20,2)
y2 = y1[20]+ 0.3*(1:30) + rnorm(30,2)
y =  as.ts(c(y1,y2))

## Rolling Origin Evaluation
rolOrig( y=y, forecFunction = dotm, n1=40)
rolOrig( y=y, forecFunction = expSmoot, n1=40)
rolOrig( y=y, forecFunction = stheta, n1=40)
rolOrig( y=y, forecFunction = otm.arxiv, n1=40, theta=3)

## Fixed Origin Evaluation
fixOrig( y=y, forecFunction = dotm, n1=40)
fixOrig( y=y, forecFunction = expSmoot, n1=40)
fixOrig( y=y, forecFunction = stheta, n1=40)
fixOrig( y=y, forecFunction = otm.arxiv, n1=40, theta=3)

## Generalised Rolling Origin Evaluation with two origin updates.
## Where the first is the 40th element and second is the 45th element
groe( y=y, forecFunction = dotm, m=5, n1=40)
groe( y=y, forecFunction = expSmoot, m=5, n1=40)
groe( y=y, forecFunction = stheta, m=5, n1=40)
groe( y=y, forecFunction = otm.arxiv, m=5, n1=40, theta=3)
</code></pre>


</div>