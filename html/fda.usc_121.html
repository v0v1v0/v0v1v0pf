<div class="container">

<table style="width: 100%;"><tr>
<td>fregre.np.cv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross-validation functional regression with scalar response using kernel
estimation.</h2>

<h3>Description</h3>

<p>Computes functional regression between functional explanatory variables and
scalar response using asymmetric kernel estimation by cross-validation
method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fregre.np.cv(
  fdataobj,
  y,
  h = NULL,
  Ker = AKer.norm,
  metric = metric.lp,
  type.CV = GCV.S,
  type.S = S.NW,
  par.CV = list(trim = 0),
  par.S = list(w = 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fdataobj</code></td>
<td>
<p><code>fdata</code> class object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Scalar response with length <code>n</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>Bandwidth, <code>h&gt;0</code>. Default argument values are provided as the
sequence of length 25 from 2.5%–quantile to 25%–quantile of the distance
between <code>fdataobj</code> curves, see <code>h.default</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ker</code></td>
<td>
<p>Type of asymmetric kernel used, by default asymmetric normal
kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metric</code></td>
<td>
<p>Metric function, by default <code>metric.lp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.CV</code></td>
<td>
<p>Type of cross-validation. By default generalized
cross-validation <code>GCV.S</code> method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.S</code></td>
<td>
<p>Type of smothing matrix <code>S</code>. By default <code>S</code> is
calculated by Nadaraya-Watson kernel estimator (<code>S.NW</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.CV</code></td>
<td>
<p>List of parameters for <code>type.CV</code>: <code>trim</code>, the alpha
of the trimming<br> and <code>draw=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>par.S</code></td>
<td>
<p>List of parameters for <code>type.S</code>: <code>w</code>, the weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to be passed for <code>metric.lp</code> o other
metric function.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The non-parametric functional regression model can be written as follows
</p>
<p style="text-align: center;"><code class="reqn"> y_i =r(X_i) + \epsilon_i </code>
</p>
<p> where the unknown smooth real function
<code class="reqn">r</code> is estimated using kernel estimation by means of
</p>
<p style="text-align: center;"><code class="reqn">\hat{r}(X)=\frac{\sum_{i=1}^{n}{K(h^{-1}d(X,X_{i}))y_{i}}}{\sum_{i=1}^{n}{K(h^{-1}d(X,X_{i}))}}</code>
</p>

<p>where <code class="reqn">K</code> is an kernel function (see <code>Ker</code> argument), <code>h</code> is
the smoothing parameter and <code class="reqn">d</code> is a metric or a semi-metric (see
<code>metric</code> argument).
</p>
<p>The function estimates the value of smoothing parameter (also called
bandwidth) <code>h</code> through Generalized Cross-validation <code>GCV</code>
criteria, see <code>GCV.S</code> or <code>CV.S</code>.
</p>
<p>The function estimates the value of smoothing parameter or the bandwidth
through the cross validation methods: <code>GCV.S</code> or
<code>CV.S</code>. It computes the distance between curves using the
<code>metric.lp</code>, although any other semimetric could be used (see
<code>semimetric.basis</code> or <code>semimetric.NPFDA</code> functions).
Different asymmetric kernels can be used, see
<code>Kernel.asymmetric</code>.<br></p>


<h3>Value</h3>

<p>Return:
</p>

<ul>
<li> <p><code>call</code> The matched call. 
</p>
</li>
<li> <p><code>residuals</code> <code>y</code> minus <code>fitted values</code>. 
</p>
</li>
<li> <p><code>fitted.values</code> Estimated scalar response. 
</p>
</li>
<li> <p><code>df.residual</code> The residual degrees of freedom. 
</p>
</li>
<li> <p><code>r2</code> Coefficient of determination. 
</p>
</li>
<li> <p><code>sr2</code> Residual variance. 
</p>
</li>
<li> <p><code>H</code> Hat matrix. 
</p>
</li>
<li> <p><code>y</code> Response. 
</p>
</li>
<li> <p><code>fdataobj</code> Functional explanatory data.
</p>
</li>
<li> <p><code>mdist</code> Distance matrix between <code>x</code> and <code>newx</code>. 
</p>
</li>
<li> <p><code>Ker</code> Asymmetric kernel used. 
</p>
</li>
<li> <p><code>gcv</code> CV or GCV values. 
</p>
</li>
<li> <p><code>h.opt</code> smoothing parameter or bandwidth that minimizes CV or GCV method. 
</p>
</li>
<li> <p><code>h</code> Vector of smoothing parameter or bandwidth. 
</p>
</li>
<li> <p><code>cv</code> List with the fitted values and residuals estimated by CV, without the same curve.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Manuel Febrero-Bande, Manuel Oviedo de la Fuente
<a href="mailto:manuel.oviedo@udc.es">manuel.oviedo@udc.es</a>
</p>


<h3>References</h3>

<p>Ferraty, F. and Vieu, P. (2006). <em>Nonparametric functional
data analysis.</em> Springer Series in Statistics, New York.
</p>
<p>Hardle, W. <em>Applied Nonparametric Regression</em>. Cambridge University
Press, 1994.
</p>
<p>Febrero-Bande, M., Oviedo de la Fuente, M. (2012).  <em>Statistical
Computing in Functional Data Analysis: The R Package fda.usc.</em> Journal of
Statistical Software, 51(4), 1-28. <a href="https://www.jstatsoft.org/v51/i04/">https://www.jstatsoft.org/v51/i04/</a>
</p>


<h3>See Also</h3>

<p>See Also as: <code>fregre.np</code>,
<code>summary.fregre.fd</code> and <code>predict.fregre.fd</code> .<br>
Alternative method: <code>fregre.basis.cv</code> and
<code>fregre.np.cv</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(tecator)
absorp=tecator$absorp.fdata
ind=1:129
x=absorp[ind,]
y=tecator$y$Fat[ind]
Ker=AKer.tri
res.np=fregre.np.cv(x,y,Ker=Ker)
summary(res.np)
res.np2=fregre.np.cv(x,y,type.CV=GCV.S,criteria="Shibata")
summary(res.np2)

## Example with other semimetrics (not run)
res.pca1=fregre.np.cv(x,y,Ker=Ker,metric=semimetric.pca,q=1)
summary(res.pca1)
res.deriv=fregre.np.cv(x,y,Ker=Ker,metric=semimetric.deriv)
summary(res.deriv)

x.d2=fdata.deriv(x,nderiv=1,method="fmm",class.out='fdata')
res.deriv2=fregre.np.cv(x.d2,y,Ker=Ker)
summary(res.deriv2)
x.d3=fdata.deriv(x,nderiv=1,method="bspline",class.out='fdata')
res.deriv3=fregre.np.cv(x.d3,y,Ker=Ker)
summary(res.deriv3)

## End(Not run)

</code></pre>


</div>