<div class="container">

<table style="width: 100%;"><tr>
<td>plot.fkf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting fkf objects</h2>

<h3>Description</h3>

<p>Plotting method for objects of class <code>fkf</code>. This function
provides tools for graphical analysis of the Kalman filter output:
Visualization of the state vector, QQ-plot of the individual
residuals, QQ-plot of the Mahalanobis distance, auto- as well as
crosscorrelation function of the residuals.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'fkf'
plot(
  x,
  type = c("state", "resid.qq", "qqchisq", "acf"),
  CI = 0.95,
  at.idx = 1:nrow(x$at),
  att.idx = 1:nrow(x$att),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The output of <code>fkf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>A string stating what shall be plotted (see <b>Details</b>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>CI</code></td>
<td>
<p>The confidence interval in case <code>type == "state"</code>. Set
<code>CI</code> to <code>NA</code> if no confidence interval shall be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>at.idx</code></td>
<td>
<p>An vector giving the indexes of the predicted state variables
which shall be plotted if <code>type == "state"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>att.idx</code></td>
<td>
<p>An vector giving the indexes of the filtered state variables
which shall be plotted if <code>type == "state"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to either <code>plot</code>,
<code>qqnorm</code>, <code>qqplot</code> or <code>acf</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The argument <code>type</code> states what shall be plotted. <code>type</code>
must partially match one of the following:
</p>

<dl>
<dt><code>state</code></dt>
<dd>
<p>The state variables are plotted. By the
arguments <code>at.idx</code> and <code>att.idx</code>, the user can specify
which of the predicted (<code class="reqn">a_{t}</code>) and filtered
(<code class="reqn">a_{t|t}</code>) state variables will be drawn.</p>
</dd>
<dt><code>resid.qq</code></dt>
<dd>
<p>Draws a QQ-plot for each residual-series in<code>vt</code>.</p>
</dd>
<dt><code>qqchisq</code></dt>
<dd>
<p>A Chi-Squared QQ-plot will be drawn to graphically
test for multivariate normality of the residuals based on the
Mahalanobis distance.</p>
</dd>
<dt><code>acf</code></dt>
<dd>
<p>Creates a pairs plot with the autocorrelation
function (<code>acf</code>) on the diagonal panels and the
crosscorrelation function (<code>ccf</code>) of the residuals on the
off-diagnoal panels.</p>
</dd>
</dl>
<h3>Value</h3>

<p>Invisibly returns an list with components:
</p>

<table>
<tr>
<td style="text-align: right;">
  <code>distance</code> </td>
<td style="text-align: left;"> The Mahalanobis distance of the residuals as a
  vector of length <code class="reqn">n</code>. </td>
</tr>
<tr>
<td style="text-align: right;">
  <code>std.resid</code> </td>
<td style="text-align: left;"> The standardized residuals as an <code class="reqn">d \times
    n</code>-matrix. It should hold that <code class="reqn">std.resid_{ij} \; iid \sim N_d(0, I)</code>,
</td>
</tr>
</table>
<p>where <code class="reqn">d</code> denotes the dimension of the data and <code class="reqn">n</code> the number
of observations.
</p>


<h3>usage</h3>

<p><code>plot(x, type = c("state", "resid.qq", "qqchisq", "acf"),
CI = 0.95, at.idx = 1:nrow(x$at), att.idx = 1:nrow(x$att), ...)</code>
</p>


<h3>See Also</h3>

<p><code>fkf</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## &lt;---------------------------------------------------------------------------&gt;
## Example: Local level model for the treering data
## &lt;---------------------------------------------------------------------------&gt;
## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)          
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

y &lt;- treering
y[c(3, 10)] &lt;- NA  # NA values can be handled

## Set constant parameters:
dt &lt;- ct &lt;- matrix(0)
Zt &lt;- Tt &lt;- array(1,c(1,1,1))
a0 &lt;- y[1]            # Estimation of the first width
P0 &lt;- matrix(100)     # Variance of 'a0'

## Estimate parameters:
fit.fkf &lt;- optim(c(HHt = var(y, na.rm = TRUE) * .5,
                   GGt = var(y, na.rm = TRUE) * .5),
                 fn = function(par, ...)
                 -fkf(HHt = array(par[1],c(1,1,1)), GGt = array(par[2],c(1,1,1)), ...)$logLik,
                 yt = rbind(y), a0 = a0, P0 = P0, dt = dt, ct = ct,
                 Zt = Zt, Tt = Tt)

## Filter tree ring data with estimated parameters:
fkf.obj &lt;- fkf(a0, P0, dt, ct, Tt, Zt, HHt = array(fit.fkf$par[1],c(1,1,1)),
               GGt = array(fit.fkf$par[2],c(1,1,1)), yt = rbind(y))

## Plot the width together with fitted local levels:
plot(y, main = "Treering data")
lines(ts(fkf.obj$att[1, ], start = start(y), frequency = frequency(y)), col = "blue")
legend("top", c("Treering data", "Local level"), col = c("black", "blue"), lty = 1)

## Check the residuals for normality:
plot(fkf.obj, type = "resid.qq")

## Test for autocorrelation:
plot(fkf.obj, type = "acf", na.action = na.pass)

</code></pre>


</div>