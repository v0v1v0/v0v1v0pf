<div class="container">

<table style="width: 100%;"><tr>
<td>Ops.freealg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Arithmetic Ops methods for the the free algebra</h2>

<h3>Description</h3>

<p>Arithmetic operators for manipulation of freealg objects
such as addition, multiplication, powers, etc
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'freealg'
Ops(e1, e2)
free_negative(S)
free_power_scalar(S,n)
free_eq_free(e1,e2)
free_plus_numeric(S,x)
free_plus_free(e1,e2)
lowlevel_simplify(words,coeffs)
lowlevel_free_prod(words1,coeffs1,words2,coeffs2)
lowlevel_free_sum(words1,coeffs1,words2,coeffs2)
lowlevel_free_power(words,coeffs,n)
lowlevel_diffn(words,coeffs,r)
lowlevel_subs(words1, coeffs1, words2, coeffs2, r)
inv(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>S,e1,e2</code></td>
<td>
<p>Objects of class <code>freealg</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Integer, possibly non-positive</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Integer vector indicating variables to differentiate with
respect to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Scalar value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>words,words1,words2</code></td>
<td>
<p>A list of words, that is, a list of integer vectors
representing the variables in each term</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeffs,coeffs1,coeffs2</code></td>
<td>
<p>Numeric vector representing the
coefficients of each word</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function <code>Ops.freealg()</code> passes binary arithmetic operators
(“<code>+</code>”, “<code>-</code>”, “<code>*</code>”,
“<code>^</code>”, and “<code>==</code>”) to the appropriate
specialist function.
</p>
<p>The caret, as in <code>a^n</code>, denotes arithmetic exponentiation, as in
<code>x^3==x*x*x</code>.  As an experimental feature, this is (sort of)
vectorised: if <code>n</code> is a vector, then <code>a^n</code> returns the sum
of <code>a</code> raised to the power of each element of <code>n</code>.  For example,
<code>a^c(n1,n2,n3)</code> is <code>a^n1 + a^n2 + a^n3</code>.  Internally,
<code>n</code> is tabulated in the interests of efficiency, so
<code>a^c(0,2,5,5,5,) = 1 + a^2 + 3a^5</code> is evaluated with only a
single fifth power.  Similar functionality is implemented in the
<a href="https://CRAN.R-project.org/package=mvp"><span class="pkg">mvp</span></a> package.
</p>
<p>The only comparison operators are equality and inequality; <code>x==y</code>
is defined as <code>is.zero(x-y)</code>.
</p>
<p>Functions <code>lowlevel_foo()</code> are low-level functions that interface
directly with the <code>C</code> routines in the <code>src/</code> directory and
are not intended for the end-user.
</p>
<p>Function <code>inv()</code> is defined only for freealg objects with a
single term.  If <code>x</code> has a single term we have
<code>inv(x)*x=x*inv(x)=1</code>.  There is no corresponding division in the
package because <code>a/b</code> may be either <code>a*inv(b)</code> or
<code>inv(b)*a</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class="language-R">rfalg()
as.freealg("1+x+xy+yx")  # variables are non-commutative
as.freealg("x") * as.freealg("X") # upper-case letters are lower-case inverses

constant(as.freealg("x+y+X+Y")^6)  # OEIS sequence A035610

inv(as.freealg("2aaabAAAAx"))

as.freealg("a")^(1:7)


</code></pre>


</div>