<div class="container">

<table style="width: 100%;"><tr>
<td>density.fd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute a Probability Density Function
</h2>

<h3>Description</h3>

<p>Like the regular S-PLUS function <code>density</code>, this function
computes a probability density function for a sample of values of a
random variable.  However, in this case the density function is
defined by a functional parameter object <code>WfdParobj</code> along with a
normalizing constant <code>C</code>.
</p>
<p>The density function $p(x)$ has the form <code>p(x) = C exp[W(x)]</code>
where function $W(x)$ is defined by the functional data object
<code>WfdParobj</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'fd'
density(x, WfdParobj, conv=0.0001, iterlim=20,
           active=1:nbasis, dbglev=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a set observations, which may be one of two forms:
</p>

<ol>
<li>
<p> a vector of observations $x_i$
</p>
</li>
<li>
<p> a two-column matrix, with the observations $x_i$ in the
first column, and frequencies $f_i$ in the second.
</p>
</li>
</ol>
<p>The first option corresponds to all $f_i = 1$.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>WfdParobj</code></td>
<td>

<p>a functional parameter object specifying the initial
value, basis object, roughness penalty and smoothing
parameter defining function $W(t).$
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>

<p>a positive constant defining the convergence criterion.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterlim</code></td>
<td>

<p>the maximum number of iterations allowed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>active</code></td>
<td>

<p>a logical vector of length equal to the number of coefficients
defining <code>Wfdobj</code>. If an entry is TRUE, the corresponding
coefficient is estimated, and if FALSE, it is held at the value defining the
argument <code>Wfdobj</code>.  Normally the first coefficient is set to 0
and not estimated, since it is assumed that $W(0) = 0$.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out on
each iteration, with 0 implying no output, 1 intermediate output level,
and 2 full output.  If levels 1 and 2 are used, it is helpful to
turn off the output buffering option in S-PLUS.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to match the generic function 'density'</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The goal of the function is provide a smooth density function
estimate that approaches some target density by an amount that is
controlled by the linear differential operator <code>Lfdobj</code> and
the penalty parameter. For example, if the second derivative of
$W(t)$ is penalized heavily, this will force the function to
approach a straight line, which in turn will force the density function
itself to be nearly normal or Gaussian.  Similarly, to each textbook
density function there corresponds a $W(t)$, and to each of these
in turn their corresponds a linear differential operator that will, when
apply to $W(t)$, produce zero as a result.
To plot the density function or to evaluate it, evaluate <code>Wfdobj</code>,
exponentiate the resulting vector, and then divide by the normalizing
constant <code>C</code>.
</p>


<h3>Value</h3>

<p>a named list of length 4 containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the monotone function that it defines.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>

<p>the normalizing constant.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged solution:
(1)
<b>f</b>: the optimal function value being minimized,
(2)
<b>grad</b>: the gradient vector at the optimal solution,   and
(3)
<b>norm</b>: the norm of the gradient vector at the optimal solution.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iternum</code></td>
<td>

<p>the number of iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterhist</code></td>
<td>

<p>a <code>iternum+1</code> by 5 matrix containing the iteration
history.
</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>intensity.fd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#  set up range for density
rangeval &lt;- c(-3,3)
#  set up some standard normal data
x &lt;- rnorm(50)
#  make sure values within the range
x[x &lt; -3] &lt;- -2.99
x[x &gt;  3] &lt;-  2.99
#  set up basis for W(x)
basisobj &lt;- create.bspline.basis(rangeval, 11)
#  set up initial value for Wfdobj
Wfd0 &lt;- fd(matrix(0,11,1), basisobj)
WfdParobj &lt;- fdPar(Wfd0)
#  estimate density
denslist &lt;- density.fd(x, WfdParobj)
#  plot density
oldpar &lt;- par(no.readonly=TRUE)
xval &lt;- seq(-3,3,.2)
wval &lt;- eval.fd(xval, denslist$Wfdobj)
pval &lt;- exp(wval)/denslist$C
plot(xval, pval, type="l", ylim=c(0,0.4))
points(x,rep(0,50))
par(oldpar)
</code></pre>


</div>