<div class="container">

<table style="width: 100%;"><tr>
<td>FLOPART</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functional Labeled Optimal Partitioning</h2>

<h3>Description</h3>

<p>Main function for computing optimal segmentation model with
Poisson loss, up-down constraints, and label constraints.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FLOPART(coverage, label, penalty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>coverage</code></td>
<td>
<p>data frame of coverage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>data frame of labels</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>non-negative penalty constant</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list with named elements: coverage_dt is a data table with
columns chromStart, chromEnd, count, weight; label_dt is a data
table with columns chromStart, chromEnd, annotation, type,
firstRow, lastRow; cost_mat is a Nx2 numeric matrix of optimal
penalized Poisson loss values up to each data point and in each
state; intervals_mat is a Nx2 integer matrix of counts of
intervals used to store the optimal cost function, useful for
analyzing time/space complexity; segments_dt is a data table
with columns chromStart, chromEnd, status, mean.
</p>


<h3>Author(s)</h3>

<p>Toby Dylan Hocking
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.table)
data("Mono27ac.simple", package="FLOPART")
Mono27ac.simple
label.pen &lt;- 1400
fit &lt;- with(Mono27ac.simple, FLOPART::FLOPART(coverage, label, label.pen))
lapply(fit, head)

## Plot data and model.
ann.colors &lt;- c(
  noPeaks="orange",
  peakStart="#efafaf",
  peakEnd="#ff4c4c")
model.color &lt;- "blue"
(peaks.dt &lt;- fit[["segments_dt"]][status=="peak"][, peak.y := -2][])
if(require("ggplot2")){
  ggplot()+
    ggtitle("Model with label constraints (FLOPART)")+
    scale_fill_manual("label", values=ann.colors)+
    geom_rect(aes(
      xmin=chromStart, xmax=chromEnd,
      ymin=-Inf, ymax=Inf,
      fill=annotation),
      alpha=0.5,
      color="grey",
      data=Mono27ac.simple[["label"]])+
    geom_step(aes(
      chromStart, count),
      data=Mono27ac.simple[["coverage"]],
      color="grey50")+
    geom_step(aes(
      chromStart, mean),
      data=fit[["segments_dt"]],
      color=model.color)+
    geom_segment(aes(
      chromStart, peak.y,
      xend=chromEnd, yend=peak.y),
      color=model.color,
      size=1,
      data=peaks.dt)+
    geom_point(aes(
      chromEnd, peak.y),
      color=model.color,
      shape=21,
      fill="white",
      data=peaks.dt)+
    theme_bw()+
    theme(panel.spacing=grid::unit(0, "lines"))
}

## To analyze computational complexity, plot number of intervals
## stored in cost function, versus data point, for each cost status.
imat &lt;- fit[["intervals_mat"]]
interval.dt &lt;- data.table(
  intervals=as.integer(imat),
  status=c("peak", "background")[as.integer(col(imat))],
  data.i=as.integer(row(imat)))
if(require("ggplot2")){
  ggplot()+
    scale_fill_manual("label", values=ann.colors)+
    geom_rect(aes(
      xmin=firstRow-0.5, xmax=lastRow+0.5,
      ymin=-Inf, ymax=Inf,
      fill=annotation),
      alpha=0.5,
      color="grey",
      data=fit[["label_dt"]])+
    geom_line(aes(
      data.i, intervals, color=status),
      size=1,
      data=interval.dt)
}
</code></pre>


</div>