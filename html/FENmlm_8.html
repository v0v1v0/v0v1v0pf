<div class="container">

<table style="width: 100%;"><tr>
<td>femlm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fixed effects maximum likelihood models</h2>

<h3>Description</h3>

<p>This function estimates maximum likelihood models (e.g., Poisson or Logit) and is efficient to handle any number of fixed effects (i.e. cluster variables). It further allows for nonlinear in parameters right hand sides.
</p>


<h3>Usage</h3>

<pre><code class="language-R">femlm(fml, data, family = c("poisson", "negbin", "logit", "gaussian"),
  NL.fml, cluster, na.rm = FALSE, useAcc = TRUE, NL.start, lower,
  upper, env, NL.start.init, offset, nl.gradient, linear.start = 0,
  jacobian.method = c("simple", "Richardson"), useHessian = TRUE,
  opt.control = list(), cores = 1, verbose = 0, theta.init,
  precision.cluster, itermax.cluster = 10000, itermax.deriv = 5000,
  showWarning = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fml</code></td>
<td>
<p>A formula. This formula gives the linear formula to be estimated (it is similar to a <code>lm</code> formula), for example: <code>fml = z~x+y</code>. To include cluster variables, you can 1) either insert them in this formula using a pipe (e.g. <code>fml = z~x+y|cluster1+cluster2</code>), or 2) either use the argment <code>cluster</code>. To include a non-linear in parameters element, you must use the argment <code>NL.fml</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data.frame containing the necessary variables to run the model. The variables of the non-linear right hand side of the formula are identified with this <code>data.frame</code> names. Note that no <code>NA</code> is allowed in the variables to be used in the estimation. Can also be a matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>Character scalar. It should provide the family. The possible values are "poisson" (Poisson model with log-link, the default), "negbin" (Negative Binomial model with log-link), "logit" (LOGIT model with log-link), "gaussian" (Gaussian model).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.fml</code></td>
<td>
<p>A formula. If provided, this formula represents the non-linear part of the right hand side (RHS). Note that contrary to the <code>fml</code> argument, the coefficients must explicitely appear in this formula. For instance, it can be <code>~a*log(b*x + c*x^3)</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are the coefficients to be estimated. Note that only the RHS of the formula is to be provided, and NOT the left hand side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>Character vector. The name/s of a/some variable/s within the dataset to be used as clusters. These variables should contain the identifier of each observation (e.g., think of it as a panel identifier).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If the variables necessary for the estimation contain NAs and <code>na.rm = TRUE</code>, then all observations containing NA are removed prior to estimation and a warning message is raised detailing the number of observations removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useAcc</code></td>
<td>
<p>Default is <code>TRUE</code>. Whether an acceleration algorithm (Irons and Tuck iterations) should be used to otbain the cluster coefficients when there are two or more clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.start</code></td>
<td>
<p>(For NL models only) A list of starting values for the non-linear parameters. ALL the parameters are to be named and given a staring value. Example: <code>NL.start=list(a=1,b=5,c=0)</code>. Though, there is an exception: if all parameters are to be given the same starting value, you can use the argument <code>NL.start.init</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>(For NL models only) A list. The lower bound for each of the non-linear parameters that requires one. Example: <code>lower=list(b=0,c=0)</code>. Beware, if the estimated parameter is at his lower bound, then asymptotic theory cannot be applied and the standard-error of the parameter cannot be estimated because the gradient will not be null. In other words, when at its upper/lower bound, the parameter is considered as 'fixed'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>(For NL models only) A list. The upper bound for each of the non-linear parameters that requires one. Example: <code>upper=list(a=10,c=50)</code>. Beware, if the estimated parameter is at his upper bound, then asymptotic theory cannot be applied and the standard-error of the parameter cannot be estimated because the gradient will not be null. In other words, when at its upper/lower bound, the parameter is considered as 'fixed'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>env</code></td>
<td>
<p>(For NL models only) An environment. You can provide an environement in which the non-linear part will be evaluated. (May be useful for some particular non-linear functions.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.start.init</code></td>
<td>
<p>(For NL models only) Numeric scalar. If the argument <code>NL.start</code> is not provided, or only partially filled (i.e. there remain non-linear parameters with no starting value), then the starting value of all remaining non-linear parameters is set to <code>NL.start.init</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>A formula. An offset can be added to the estimation. It should be a formula of the form (for example) ~0.5*x**2. This offset is linearily added to the elements of the main formula 'fml'. Note that when using the argument 'NL.fml', you can directly add the offset there.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nl.gradient</code></td>
<td>
<p>(For NL models only) A formula. The user can prodide a function that computes the gradient of the non-linear part. The formula should be of the form <code>~f0(a1,x1,a2,a2)</code>. The important point is that it should be able to be evaluated by: <code>eval(nl.gradient[[2]], env)</code> where <code>env</code> is the working environment of the algorithm (which contains all variables and parameters). The function should return a list or a data.frame whose names are the non-linear parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear.start</code></td>
<td>
<p>Numeric named vector. The starting values of the linear part.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jacobian.method</code></td>
<td>
<p>Character scalar. Provides the method used to numerically compute the jacobian of the non-linear part. Can be either <code>"simple"</code> or <code>"Richardson"</code>. Default is <code>"simple"</code>. See the help of <code>jacobian</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useHessian</code></td>
<td>
<p>Logical. Should the Hessian be computed in the optimization stage? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt.control</code></td>
<td>
<p>List of elements to be passed to the optimization method <code>nlminb</code>. See the help page of <code>nlminb</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>Integer, default is 1. Number of threads to be used (accelerates the algorithm via the use of openMP routines). This is particularly efficient for the negative binomial and logit models, less so for the Gaussian and Poisson likelihoods (unless for very large datasets).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Integer, default is 0. It represents the level of information that should be reported during the optimisation process. If <code>verbose=0</code>: nothing is reported. If <code>verbose=1</code>: the value of the coefficients and the likelihood are reported. If <code>verbose=2</code>: <code>1</code> + information on the computing tiime of the null model, the cluster coefficients and the hessian are reported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta.init</code></td>
<td>
<p>Positive numeric scalar. The starting value of the dispersion parameter if <code>family="negbin"</code>. By default, the algorithm uses as a starting value the theta obtained from the model with only the intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>precision.cluster</code></td>
<td>
<p>Precision used to obtain the fixed-effects (ie cluster coefficients). Defaults to <code>1e-5</code>. It corresponds to the maximum absolute difference allowed between two iterations. Argument <code>precision.cluster</code> cannot be lower than <code>10000*.Machine$double.eps</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax.cluster</code></td>
<td>
<p>Maximum number of iterations in the step obtaining the fixed-effects (only in use for 2+ clusters). Default is 10000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>itermax.deriv</code></td>
<td>
<p>Maximum number of iterations in the step obtaining the derivative of the fixed-effects (only in use for 2+ clusters). Default is 5000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>showWarning</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. Whether warnings should be displayed (concerns warnings relating to: convergence state, collinearity issues and observation removal due to only 0/1 outcomes or presence of NA values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not currently used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function estimates maximum likelihood models where the conditional expectations are as follows:
</p>
<p>Gaussian likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=X\beta</code>
</p>

<p>Poisson and Negative Binomial likelihoods:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\exp(X\beta)</code>
</p>

<p>where in the Negative Binomial there is the parameter <code class="reqn">\theta</code> used to model the variance as <code class="reqn">\mu+\mu^2/\theta</code>, with <code class="reqn">\mu</code> the conditional expectation.
Logit likelihood:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X)=\frac{\exp(X\beta)}{1+\exp(X\beta)}</code>
</p>

<p>When there are one or more clusters, the conditional expectation can be written as:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X) = h(X\beta+\sum_{k}\sum_{m}\gamma_{m}^{k}\times C_{im}^{k}),</code>
</p>

<p>where <code class="reqn">h(.)</code> is the function corresponding to the likelihood function as shown before. <code class="reqn">C^k</code> is the matrix associated to cluster <code class="reqn">k</code> such that <code class="reqn">C^k_{im}</code> is equal to 1 if observation <code class="reqn">i</code> is of category <code class="reqn">m</code> in cluster <code class="reqn">k</code> and 0 otherwise.
</p>
<p>When there are non linear in parameters functions, we can schematically split the set of regressors in two:
</p>
<p style="text-align: center;"><code class="reqn">f(X,\beta)=X^1\beta^1 + g(X^2,\beta^2)</code>
</p>

<p>with first a linear term and then a non linear part expressed by the function g. That is, we add a non-linear term to the linear terms (which are <code class="reqn">X*beta</code> and the cluster coefficients). It is always better (more efficient) to put into the argument <code>NL.fml</code> only the non-linear in parameter terms, and add all linear terms in the <code>fml</code> argument.
</p>
<p>To estimate only a non-linear formula without even the intercept, you must exclude the intercept from the linear formula by using, e.g., <code>fml = z~0</code>.
</p>
<p>The over-dispersion parameter of the Negative Binomial family, theta, is capped at 10,000. If theta reaches this high value, it means that there is no overdispersion.
</p>


<h3>Value</h3>

<p>An <code>femlm</code> object.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>The named vector of coefficients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coeftable</code></td>
<td>
<p>The table of the coefficients with their standard errors, z-values and p-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>The loglikelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>Number of iterations of the algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nparams</code></td>
<td>
<p>The number of parameters of the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fml</code></td>
<td>
<p>The linear formula of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ll_null</code></td>
<td>
<p>Log-likelihood of the null model (i.e. with the intercept only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo_r2</code></td>
<td>
<p>The adjusted pseudo R2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>The convergence message from the optimization procedures.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sq.cor</code></td>
<td>
<p>Squared correlation between the dependent variable and the expected predictor (i.e. fitted.values) obtained by the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>The Hessian of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fitted.values</code></td>
<td>
<p>The fitted values are the expected value of the dependent variable for the fitted model: that is <code class="reqn">E(Y|X)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov.unscaled</code></td>
<td>
<p>The variance-covariance matrix of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>The standard-error of the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p>The matrix of the scores (first derivative for each observation).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>The ML family that was used for the estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>The difference between the dependent variable and the expected predictor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sumFE</code></td>
<td>
<p>The sum of the fixed-effects for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offset</code></td>
<td>
<p>The offset formula.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NL.fml</code></td>
<td>
<p>The nonlinear formula of the call.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bounds</code></td>
<td>
<p>Whether the coefficients were upper or lower bounded. – This can only be the case when a non-linear formula is included and the arguments 'lower' or 'upper' are provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>isBounded</code></td>
<td>
<p>The logical vector that gives for each coefficient whether it was bounded or not. This can only be the case when a non-linear formula is included and the arguments 'lower' or 'upper' are provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterNames</code></td>
<td>
<p>The names of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id_dummies</code></td>
<td>
<p>The list (of length the number of clusters) of the cluster identifiers for each observation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterSize</code></td>
<td>
<p>The size of each cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obsRemoved</code></td>
<td>
<p>In the case there were clusters and some observations were removed because of only 0/1 outcome within a cluster, it gives the row numbers of the observations that were removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterRemoved</code></td>
<td>
<p>In the case there were clusters and some observations were removed because of only 0/1 outcome within a cluster, it gives the list (for each cluster) of the clustr identifiers that were removed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>In the case of a negative binomial estimation: the overdispersion parameter.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Laurent Berge
</p>


<h3>References</h3>

<p>Berge, Laurent, 2018, "Efficient estimation of maximum likelihood models with multiple fixed-effects: the R package FENmlm." CREA Discussion Papers, 13 (<a href="https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf">https://github.com/lrberge/fixest/blob/master/_DOCS/FENmlm_paper.pdf</a>).
</p>
<p>For models with multiple fixed-effects:
</p>
<p>Gaure, Simen, 2013, "OLS with multiple high dimensional category variables", Computational Statistics &amp; Data Analysis 66 pp. 8–18
</p>
<p>On the unconditionnal Negative Binomial model:
</p>
<p>Allison, Paul D and Waterman, Richard P, 2002, "Fixed-Effects Negative Binomial Regression Models", Sociological Methodology 32(1) pp. 247–265
</p>


<h3>See Also</h3>

<p>See also <code>summary.femlm</code> to see the results with the appropriate standard-errors, <code>getFE</code> to extract the cluster coefficients, and the functions <code>res2table</code> and <code>res2tex</code> to visualize the results of multiple estimations.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#
# Linear examples
#

# Load trade data
data(trade)

# We estimate the effect of distance on trade =&gt; we account for 3 cluster effects
# 1) Poisson estimation
est_pois = femlm(Euros ~ log(dist_km)|Origin+Destination+Product, trade)
# alternative formulation giving the same results:
# est_pois = femlm(Euros ~ log(dist_km), trade, cluster = c("Origin", "Destination", "Product"))

# 2) Log-Log Gaussian estimation (with same clusters)
est_gaus = update(est_pois, log(Euros+1) ~ ., family="gaussian")

# 3) Negative Binomial estimation
est_nb = update(est_pois, family="negbin")

# Comparison of the results using the function res2table
res2table(est_pois, est_gaus, est_nb)
# Now using two way clustered standard-errors
res2table(est_pois, est_gaus, est_nb, se = "twoway")

# Comparing different types of standard errors
sum_white = summary(est_pois, se = "white")
sum_oneway = summary(est_pois, se = "cluster")
sum_twoway = summary(est_pois, se = "twoway")
sum_threeway = summary(est_pois, se = "threeway")

res2table(sum_white, sum_oneway, sum_twoway, sum_threeway)


#
# Example of Equivalences
#
## Not run: 
# equivalence with glm poisson
est_glm &lt;- glm(Euros ~ log(dist_km) + factor(Origin) +
            factor(Destination) + factor(Product), trade, family = poisson)

# coefficient estimates + Standard-error
summary(est_glm)$coefficients["log(dist_km)", ]
est_pois$coeftable

# equivalence with lm
est_lm &lt;- lm(log(Euros+1) ~ log(dist_km) + factor(Origin) +
            factor(Destination) + factor(Product), trade)

# coefficient estimates + Standard-error
summary(est_lm)$coefficients["log(dist_km)", ]
summary(est_gaus, dof_correction = TRUE)$coeftable

## End(Not run)


#
# Non-linear examples
#

# Generating data for a simple example
n = 100
x = rnorm(n, 1, 5)**2
y = rnorm(n, -1, 5)**2
z1 = rpois(n, x*y) + rpois(n, 2)
base = data.frame(x, y, z1)

# Estimating a 'linear' relation:
est1_L = femlm(z1 ~ log(x) + log(y), base)
# Estimating the same 'linear' relation using a 'non-linear' call
est1_NL = femlm(z1 ~ 1, base, NL.fml = ~a*log(x)+b*log(y), NL.start = list(a=0, b=0))
# we compare the estimates with the function res2table (they are identical)
res2table(est1_L, est1_NL)

# Now generating a non-linear relation (E(z2) = x + y + 1):
z2 = rpois(n, x + y) + rpois(n, 1)
base$z2 = z2

# Estimation using this non-linear form
est2_NL = femlm(z2~0, base, NL.fml = ~log(a*x + b*y),
               NL.start = list(a=1, b=2), lower = list(a=0, b=0))
# we can't estimate this relation linearily
# =&gt; closest we can do:
est2_L = femlm(z2~log(x)+log(y), base)

# Difference between the two models:
res2table(est2_L, est2_NL)

# Plotting the fits:
plot(x, z2, pch = 18)
points(x, fitted(est2_L), col = 2, pch = 1)
points(x, fitted(est2_NL), col = 4, pch = 2)


# Using a custom Jacobian for the function log(a*x + b*y)
myGrad = function(a,x,b,y){
	s = a*x+b*y
	data.frame(a = x/s, b = y/s)
}

est2_NL_grad = femlm(z2~0, base, NL.fml = ~log(a*x + b*y),
                     NL.start = list(a=1,b=2), nl.gradient = ~myGrad(a,x,b,y))


</code></pre>


</div>