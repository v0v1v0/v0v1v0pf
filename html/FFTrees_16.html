<div class="container">

<table style="width: 100%;"><tr>
<td>FFTrees</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Main function to create and apply fast-and-frugal trees (FFTs)</h2>

<h3>Description</h3>

<p><code>FFTrees</code> is the workhorse function of the <strong>FFTrees</strong> package for creating fast-and-frugal trees (FFTs).
</p>
<p>FFTs are decision algorithms for solving binary classification tasks, i.e., they predict the values of a binary criterion variable based on 1 or multiple predictor variables (cues).
</p>
<p>Using <code>FFTrees</code> on <code>data</code> usually generates a range of FFTs and corresponding summary statistics (as an <code>FFTrees</code> object)
that can then be printed, plotted, and examined further.
</p>
<p>The criterion and predictor variables are specified in <code>formula</code> notation.
Based on the settings of <code>data</code> and <code>data.test</code>, FFTs are trained on a (required) training dataset
(given the set of current <code>goal</code> values) and evaluated on (or predict) an (optional) test dataset.
</p>
<p>If an existing <code>FFTrees</code> object <code>object</code> or <code>tree.definitions</code> are provided as inputs,
no new FFTs are created.
When both arguments are provided, <code>tree.definitions</code> take priority over the FFTs in an existing <code>object</code>.
Specifically,
</p>

<ul>
<li>
<p>If <code>tree.definitions</code> are provided, these are assigned to the FFTs of <code>x</code>.
</p>
</li>
<li>
<p>If no <code>tree.definitions</code> are provided, but an existing <code>FFTrees</code> object <code>object</code> is provided,
the trees from <code>object</code> are assigned to the FFTs of <code>x</code>.
</p>
</li>
</ul>
<p>Create and evaluate fast-and-frugal trees (FFTs).
</p>


<h3>Usage</h3>

<pre><code class="language-R">FFTrees(
  formula = NULL,
  data = NULL,
  data.test = NULL,
  algorithm = "ifan",
  train.p = 1,
  goal = NULL,
  goal.chase = NULL,
  goal.threshold = NULL,
  max.levels = NULL,
  numthresh.method = "o",
  numthresh.n = 10,
  repeat.cues = TRUE,
  stopping.rule = "exemplars",
  stopping.par = 0.1,
  sens.w = 0.5,
  cost.outcomes = NULL,
  cost.cues = NULL,
  main = NULL,
  decision.labels = c("False", "True"),
  my.goal = NULL,
  my.goal.fun = NULL,
  my.tree = NULL,
  object = NULL,
  tree.definitions = NULL,
  do.comp = TRUE,
  do.cart = TRUE,
  do.lr = TRUE,
  do.rf = TRUE,
  do.svm = TRUE,
  quiet = list(ini = TRUE, fin = FALSE, mis = FALSE, set = TRUE),
  comp = NULL,
  force = NULL,
  rank.method = NULL,
  rounding = NULL,
  store.data = NULL,
  verbose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>A formula. A <code>formula</code> specifying a binary criterion variable (as logical) as a function of 1 or more predictor variables (cues).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame. A dataset used for training (fitting) FFTs and alternative algorithms.
<code>data</code> must contain the binary criterion variable specified in <code>formula</code> and potential predictors (which can be categorical or numeric variables).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.test</code></td>
<td>
<p>A data frame. An optional dataset used for model testing (prediction) with the same structure as data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>algorithm</code></td>
<td>
<p>A character string. The algorithm used to create FFTs. Can be <code>'ifan'</code>, <code>'dfan'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>train.p</code></td>
<td>
<p>numeric. What percentage of the data to use for training when <code>data.test</code> is not specified?
For example, <code>train.p = .50</code> will randomly split <code>data</code> into a 50% training set and a 50% test set.
Default: <code>train.p = 1</code> (i.e., using <em>all</em> data for training).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goal</code></td>
<td>
<p>A character string indicating the statistic to maximize when <em>selecting trees</em>:
<code>"acc"</code> = overall accuracy, <code>"bacc"</code> = balanced accuracy, <code>"wacc"</code> = weighted accuracy,
<code>"dprime"</code> = discriminability, <code>"cost"</code> = costs (based on <code>cost.outcomes</code> and <code>cost.cues</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goal.chase</code></td>
<td>
<p>A character string indicating the statistic to maximize when <em>constructing trees</em>:
<code>"acc"</code> = overall accuracy, <code>"bacc"</code> = balanced accuracy, <code>"wacc"</code> = weighted accuracy,
<code>"dprime"</code> = discriminability, <code>"cost"</code> = costs (based on <code>cost.outcomes</code> and <code>cost.cues</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>goal.threshold</code></td>
<td>
<p>A character string indicating the criterion to maximize when <em>optimizing cue thresholds</em>:
<code>"acc"</code> = overall accuracy, <code>"bacc"</code> = balanced accuracy, <code>"wacc"</code> = weighted accuracy,
<code>"dprime"</code> = discriminability, <code>"cost"</code> = costs (based only on <code>cost.outcomes</code>, as <code>cost.cues</code> are constant per cue).
All default goals are set in <code>fftrees_create</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.levels</code></td>
<td>
<p>integer. The maximum number of nodes (or levels) considered for an FFT.
As all combinations of possible exit structures are considered, larger values of <code>max.levels</code> will create larger sets of FFTs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numthresh.method</code></td>
<td>
<p>How should thresholds for numeric cues be determined (as character)?
<code>"o"</code> will optimize thresholds (for <code>goal.threshold</code>), while <code>"m"</code> will use the median.
Default: <code>numthresh.method = "o"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numthresh.n</code></td>
<td>
<p>The number of numeric thresholds to try (as integer).
Default: <code>numthresh.n = 10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repeat.cues</code></td>
<td>
<p>May cues occur multiple times within a tree (as logical)?
Default: <code>repeat.cues = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopping.rule</code></td>
<td>
<p>A character string indicating the method to stop growing trees.
Available options are:
</p>

<ul>
<li>
<p><code>"exemplars"</code>: A tree grows until only a small proportion of unclassified exemplars remain;
</p>
</li>
<li>
<p><code>"levels"</code>: A tree grows until a certain level is reached;
</p>
</li>
<li>
<p><code>"statdelta"</code>: A tree grows until the change in the criterion statistic <code>goal.chase</code> exceeds some threshold level.
(This setting is currently experimental and includes the first level beyond threshold.
As tree statistics can be non-monotonic, this option may yield inconsistent results.)
</p>
</li>
</ul>
<p>All stopping methods use <code>stopping.par</code> to set a numeric threshold value.
Default: <code>stopping.rule = "exemplars"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stopping.par</code></td>
<td>
<p>numeric. A numeric parameter indicating the criterion value for the current <code>stopping.rule</code>.
For stopping.rule <code>"levels"</code>, this is the number of desired levels (as an integer).
For stopping rule <code>"exemplars"</code>, this is the smallest proportion of exemplars allowed in the last level.
For stopping.rule <code>"statdelta"</code>, this is the minimum required change (in the <code>goal.chase</code> value) to include a level.
Default: <code>stopping.par = .10</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sens.w</code></td>
<td>
<p>A numeric value from <code>0</code> to <code>1</code> indicating how to weight
sensitivity relative to specificity when optimizing <em>weighted</em> accuracy (e.g., <code>goal = 'wacc'</code>).
Default: <code>sens.w = .50</code> (i.e., <code>wacc</code> corresponds to <code>bacc</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost.outcomes</code></td>
<td>
<p>A list of length 4 specifying the cost value for one of the 4 possible classification outcomes.
The list elements must be named <code>'hi'</code>, <code>'fa'</code>, <code>'mi'</code>, and <code>'cr'</code>
(for specifying the costs of a hit, false alarm, miss, and correct rejection, respectively) and provide a numeric cost value.
E.g.; <code>cost.outcomes = listc("hi" = 0, "fa" = 10, "mi" = 20, "cr" = 0)</code> imposes false alarm and miss costs of <code>10</code> and <code>20</code> units, respectively, while correct decisions have no costs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cost.cues</code></td>
<td>
<p>A list containing the cost of each cue (in some common unit).
Each list element must have a name corresponding to a cue (i.e., a variable in <code>data</code>), and should be a single (positive numeric) value.
Cues in <code>data</code> that are not present in <code>cost.cues</code> are assumed to have no costs (i.e., a cost value of <code>0</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>string. An optional label for the dataset. Passed on to other functions, like <code>plot.FFTrees</code>, and <code>print.FFTrees</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decision.labels</code></td>
<td>
<p>A vector of strings of length 2 for the text labels for negative and positive decision/prediction outcomes
(i.e., left vs. right, noise vs. signal, 0 vs. 1, respectively, as character).
E.g.; <code>decision.labels = c("Healthy", "Diseased")</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my.goal</code></td>
<td>
<p>The name of an optimization measure defined by <code>my.goal.fun</code> (as a character string).
Example: <code>my.goal = "my_acc"</code> (see <code>my.goal.fun</code> for corresponding function).
Default: <code>my.goal = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my.goal.fun</code></td>
<td>
<p>The definition of an outcome measure to optimize, defined as a function
of the frequency counts of the 4 basic classification outcomes <code>hi, fa, mi, cr</code>
(i.e., an R function with 4 arguments <code>hi, fa, mi, cr</code>).
Example: <code>my.goal.fun = function(hi, fa, mi, cr){(hi + cr)/(hi + fa + mi + cr)}</code> (i.e., accuracy).
Default: <code>my.goal.fun = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>my.tree</code></td>
<td>
<p>A verbal description of an FFT, i.e., an "FFT in words" (as character string).
For example, <code>my.tree = "If age &gt; 20, predict TRUE. If sex = {m}, predict FALSE. Otherwise, predict TRUE."</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An optional existing <code>FFTrees</code> object.
When specified, no new FFTs are fitted, but existing trees are applied to <code>data</code> and <code>data.test</code>.
When <code>formula</code>, <code>data</code> or <code>data.test</code> are not specified, the current values of <code>object</code> are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree.definitions</code></td>
<td>
<p>An optional <code>data.frame</code> of hard-coded FFT definitions (in the format of <code>x$trees$definitions</code> of an <code>FFTrees</code> object <code>x</code>).
If specified, no new FFTs are being fitted (i.e., <code>algorithm</code> and functions for evaluating cues and creating FFTs are skipped).
Instead, the tree definitions provided are used to re-evaluate the current <code>FFTrees</code> object on current data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do.comp, do.lr, do.cart, do.svm, do.rf</code></td>
<td>
<p>Should alternative algorithms be used for comparison (as logical)?
All options are set to <code>TRUE</code> by default. Available options correspond to:
</p>

<ul>
<li>
<p><code>do.lr</code>: Logistic regression (LR, using <code>glm</code> from <strong>stats</strong> with <code>family = "binomial"</code>);
</p>
</li>
<li>
<p><code>do.cart</code>: Classification and regression trees (CART, using <code>rpart</code> from <strong>rpart</strong>);
</p>
</li>
<li>
<p><code>do.svm</code>: Support vector machines (SVM, using <code>svm</code> from <strong>e1071</strong>);
</p>
</li>
<li>
<p><code>do.rf</code>: Random forests (RF, using <code>randomForest</code> from <strong>randomForest</strong>.
</p>
</li>
</ul>
<p>Specifying <code>do.comp = FALSE</code> sets all available options to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quiet</code></td>
<td>
<p>A list of 4 logical arguments: Should detailed progress reports be suppressed?
Setting list elements to <code>FALSE</code> is helpful when diagnosing errors.
Default: <code>quiet = list(ini = TRUE, fin = FALSE, mis = FALSE, set = TRUE)</code>,
for initial vs. final steps, missing cases, and parameter settings, respectively.
Providing a single logical value sets all elements to <code>TRUE</code> or <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>comp, force, rank.method, rounding, store.data, verbose</code></td>
<td>
<p>Deprecated arguments (unused or replaced, to be retired in future releases).</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>FFTrees</code> object with the following elements:
</p>

<dl>
<dt>criterion_name</dt>
<dd>
<p>The name of the binary criterion variable (as character).</p>
</dd>
<dt>cue_names</dt>
<dd>
<p>The names of all potential predictor variables (cues) in the data (as character).</p>
</dd>
<dt>formula</dt>
<dd>
<p>The <code>formula</code> specified when creating the FFTs.</p>
</dd>
<dt>trees</dt>
<dd>
<p>A list of FFTs created, with further details contained in <code>n</code>, <code>best</code>, <code>definitions</code>, <code>inwords</code>, <code>stats</code>, <code>level_stats</code>, and <code>decisions</code>.</p>
</dd>
<dt>data</dt>
<dd>
<p>The original training and test data (if available).</p>
</dd>
<dt>params</dt>
<dd>
<p>A list of defined control parameters (e.g.; <code>algorithm</code>, <code>goal</code>, <code>sens.w</code>, as well as various thresholds, stopping rule, and cost parameters).</p>
</dd>
<dt>competition</dt>
<dd>
<p>Models and classification statistics for competitive classification algorithms:
Logistic regression (<code>lr</code>), classification and regression trees (<code>cart</code>), random forests (<code>rf</code>), and support vector machines (<code>svm</code>).</p>
</dd>
<dt>cues</dt>
<dd>
<p>A list of cue information, with further details contained in <code>thresholds</code> and <code>stats</code>.</p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>print.FFTrees</code> for printing FFTs;
<code>plot.FFTrees</code> for plotting FFTs;
<code>summary.FFTrees</code> for summarizing FFTs;
<code>inwords</code> for obtaining a verbal description of FFTs;
<code>showcues</code> for plotting cue accuracies.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# 1. Create fast-and-frugal trees (FFTs) for heart disease:
heart.fft &lt;- FFTrees(formula = diagnosis ~ .,
                     data = heart.train,
                     data.test = heart.test,
                     main = "Heart Disease",
                     decision.labels = c("Healthy", "Diseased")
                     )

# 2. Print a summary of the result:
heart.fft  # same as:
# print(heart.fft, data = "train", tree = "best.train")

# 3. Plot an FFT applied to training data:
plot(heart.fft)  # same as:
# plot(heart.fft, what = "all", data = "train", tree = "best.train")

# 4. Apply FFT to (new) testing data:
plot(heart.fft, data = "test")            # predict for Tree 1
plot(heart.fft, data = "test", tree = 2)  # predict for Tree 2

# 5. Predict classes and probabilities for new data:
predict(heart.fft, newdata = heartdisease)
predict(heart.fft, newdata = heartdisease, type = "prob")

# 6. Create a custom tree (from verbal description) with my.tree:
custom.fft &lt;- FFTrees(
  formula = diagnosis ~ .,
  data = heartdisease,
  my.tree = "If age &lt; 50, predict False.
             If sex = 1, predict True.
             If chol &gt; 300, predict True, otherwise predict False.",
  main = "My custom FFT")

# Plot the (pretty bad) custom tree:
plot(custom.fft)

</code></pre>


</div>