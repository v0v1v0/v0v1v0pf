<div class="container">

<table style="width: 100%;"><tr>
<td>AME</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Almost Matching Exactly (AME) Algorithms for Discrete, Observational Data</h2>

<h3>Description</h3>

<p>Almost Matching Exactly (AME) Algorithms for Discrete, Observational Data
</p>


<h3>Usage</h3>

<pre><code class="language-R">FLAME(
  data,
  holdout = 0.1,
  C = 0.1,
  treated_column_name = "treated",
  outcome_column_name = "outcome",
  weights = NULL,
  PE_method = "ridge",
  user_PE_fit = NULL,
  user_PE_fit_params = NULL,
  user_PE_predict = NULL,
  user_PE_predict_params = NULL,
  replace = FALSE,
  estimate_CATEs = FALSE,
  verbose = 2,
  return_pe = FALSE,
  return_bf = FALSE,
  early_stop_iterations = Inf,
  early_stop_epsilon = 0.25,
  early_stop_control = 0,
  early_stop_treated = 0,
  early_stop_pe = Inf,
  early_stop_bf = 0,
  missing_data = c("none", "drop", "keep", "impute"),
  missing_holdout = c("none", "drop", "impute"),
  missing_data_imputations = 1,
  missing_holdout_imputations = 5,
  impute_with_treatment = TRUE,
  impute_with_outcome = FALSE
)

DAME(
  data,
  holdout = 0.1,
  treated_column_name = "treated",
  outcome_column_name = "outcome",
  weights = NULL,
  PE_method = "ridge",
  n_flame_iters = 0,
  user_PE_fit = NULL,
  user_PE_fit_params = NULL,
  user_PE_predict = NULL,
  user_PE_predict_params = NULL,
  replace = FALSE,
  estimate_CATEs = FALSE,
  verbose = 2,
  return_pe = FALSE,
  return_bf = FALSE,
  early_stop_iterations = Inf,
  early_stop_epsilon = 0.25,
  early_stop_control = 0,
  early_stop_treated = 0,
  early_stop_pe = Inf,
  early_stop_bf = 0,
  missing_data = c("none", "drop", "keep", "impute"),
  missing_holdout = c("none", "drop", "impute"),
  missing_data_imputations = 1,
  missing_holdout_imputations = 5,
  impute_with_treatment = TRUE,
  impute_with_outcome = FALSE
)

## S3 method for class 'ame'
print(x, digits = getOption("digits"), linewidth = 80, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data to be matched. Either a data frame or a path to a .csv file
to be read into a data frame. Treatment must be described by a logical or
binary numeric column with name <code>treated_column_name</code>. If supplied,
outcome must be described by a column with name <code>outcome_column_name</code>.
The outcome will be treated as continuous if numeric with more than two
values, as binary if a two-level factor or numeric with values 0 and 1
exclusively, and as multi-class if a factor with more than two levels. If
the outcome column is omitted, matching will be performed but treatment
effect estimation will not be possible. All columns not containing outcome
or treatment will be treated as covariates for matching. Covariates are
assumed to be categorical and will be coerced to factors, though they may
be passed as either factors or numeric; if the former, unused levels will
automatically be dropped. If you wish to use continuous covariates for
matching, they should be binned prior to matching.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>holdout</code></td>
<td>
<p>Holdout data to be used to compute predictive error, if
<code>weights</code> is not supplied. If a numeric scalar between 0 and 1, that
proportion of <code>data</code> will be made into a holdout set and only the
<em>remaining proportion</em> of <code>data</code> will be matched. Otherwise, a
data frame or a path to a .csv file. The holdout data must contain an
outcome column with name <code>outcome_column_name</code>; other restrictions on
column types are as for <code>data</code>. Covariate columns must have the same
column names and order as <code>data</code>. This data will <em>not</em> be
matched. Defaults to 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>A finite, positive scalar denoting the tradeoff between BF and PE in
the FLAME algorithm. Higher C prioritizes more matches and lower C
prioritizes not dropping important covariates. Defaults to 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treated_column_name</code></td>
<td>
<p>Name of the treatment column in <code>data</code> and
<code>holdout</code>. Defaults to 'treated'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outcome_column_name</code></td>
<td>
<p>Name of the outcome column in <code>holdout</code> and
also in <code>data</code>, if supplied in the latter. Defaults to 'outcome'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>A positive numeric vector representing covariate importances.
Supplying this argument prevents PE from being computed as it determines
dropping order by forcing covariate subsets with lower weights to be
dropped first. The weight of a covariate subset is defined to be the sum of
the weights of the constituent covariates. Ties are broken at random.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>PE_method</code></td>
<td>
<p>Denotes how predictive error (PE) is to be computed. Either
a string – one of "ridge" (default) or "xgb" – or a function. If "ridge",
ridge regression is used to fit a an outcome regression model via
<code>glmnet::cv.glmnet</code> with default parameters. If "xgb", gradient
boosting with a wide range of parameter values to cross-validate is used
via <code>xgboost::xgb.cv</code> and the best parameters with respect to RMSE
(for continuous outcomes) or misclassification rate (for binary/multi-class
outcomes) are chosen. In both cases, the default <code>predict</code> method is
used to generate in-sample predictions. If a function, denotes a
user-supplied function that should be used for computing PE. This function
must be passed a data frame of covariates as its first argument and a
vector of outcome values as its second argument. It must return a vector of
in-sample predictions, which, if the outcome is binary or multi-class, must
be maximum probability class labels. See below for examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_PE_fit</code></td>
<td>
<p>Deprecated; use argument 'PE_method' instead. An optional
function supplied by the user that can be used instead of those allowed for
by <code>PE_method</code> to fit a model for the outcome from the covariates.
This function will be passed a data frame of covariates
as its first argument and a vector of outcome values as its
second argument. See below for examples. Defaults to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_PE_fit_params</code></td>
<td>
<p>Deprecated; use argument 'PE_method' instead. A
named list of optional parameters to be used by <code>user_PE_fit</code>.
Defaults to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_PE_predict</code></td>
<td>
<p>Deprecated; use argument 'PE_method' instead. An
optional function supplied by the user that can be used to generate
predictions from the output of <code>user_PE_fit</code>. As its first argument,
must take an object of the type returned by <code>user_PE_fit</code> and as its
second, a matrix of values for which to generate predictions. When the
outcome is binary or multi-class, must return the maximum probability class
label. If not supplied, defaults to <code>predict</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>user_PE_predict_params</code></td>
<td>
<p>Deprecated; use argument 'PE_method' instead. A
named list of optional parameters to be used by <code>user_PE_predict</code>.
Defaults to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code>, allows the same unit to be
matched multiple times, on different sets of covariates. In this case, the
balancing factor for <code>FLAME</code> is computing by dividing by the total
number of treatment (control) units, instead of the number of unmatched
treatment (control) units. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimate_CATEs</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code>, CATEs for each unit
are estimated throughout the matching procedure, which will be much faster
than computing them after a call to <code>FLAME</code> or <code>DAME</code> for very
large inputs. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Controls how FLAME displays progress while running. If 0, no
output. If 1, only outputs the stopping condition. If 2, outputs the
iteration and number of unmatched units every 5 iterations, and the
stopping condition. If 3, outputs the iteration and number of unmatched
units every iteration, and the stopping condition. Defaults to 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_pe</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code>, the predictive error (PE)
at each iteration will be returned. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_bf</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code>, the balancing factor (BF)
at each iteration will be returned. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stop_iterations</code></td>
<td>
<p>A positive integer, denoting an upper bound
on the number of matching rounds to be performed. If 1, one round of
exact matching is performed before stopping. Defaults to <code>Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stop_epsilon</code></td>
<td>
<p>A nonnegative numeric. If fixed covariate weights
are passed via <code>weights</code>, then the algorithm will stop before matching
on a covariate set whose error is above <code>early_stop_epsilon</code>, where in
this case the error is defined as: <code class="reqn">1 - weight(covariate set matched
on) / weight(all covariates)</code>. Otherwise, if <code>weights</code> is <code>NULL</code>,
if FLAME or DAME attempts to drop a covariate set that would raise the PE
above (1 + <code>early_stop_epsilon</code>) times the baseline PE (the PE before
any covariates have been dropped), the algorithm will stop. Defaults to
0.25.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stop_control, early_stop_treated</code></td>
<td>
<p>If the proportion of control,
treated units, respectively, that are unmatched falls below this value, the
matching algorithm will stop. Default to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stop_pe</code></td>
<td>
<p>Deprecated. A positive numeric. If FLAME attempts to
drop a covariate that would lead to a PE above this value, FLAME stops.
Defaults to <code>Inf</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>early_stop_bf</code></td>
<td>
<p>Deprecated. A numeric value between 0 and 2. If FLAME
attempts to drop a covariate that would lead to a BF below this value,
FLAME stops. Defaults to 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_data</code></td>
<td>
<p>Specifies how to handle missingness in <code>data</code>. If
'none' (default), assumes no missing data. If 'drop', effectively drops units
with missingness from the data and does not match them (they will still
appear in the matched dataset that is returned, however). If 'keep', keeps
the missing values in the data; in this case, a unit can only match on sets
containing covariates it is not missing. If 'impute', imputes the missing
data via <code>mice::mice</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_holdout</code></td>
<td>
<p>Specifies how to handle missingness in <code>holdout</code>.
If 'none' (default), assumes no missing data; if 'drop', drops units with
missingness and does not use them to compute PE; and if 'impute', imputes
the missing data via <code>mice::mice</code>. In this last case, the PE at an
iteration will be given by the average PE across all imputations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_data_imputations</code></td>
<td>
<p>Defunct. If <code>missing_data</code> = 'impute',
one round of imputation will be performed on <code>data</code> via
<code>mice::mice</code>. To view results for multiple imputations, please wrap
calls to <code>FLAME</code> or <code>DAME</code> in a loop. This argument will be
removed in a future release.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing_holdout_imputations</code></td>
<td>
<p>If <code>missing_holdout</code> = 'impute',
performs this many imputations of the missing data in <code>holdout</code> via
<code>mice::mice</code>. Defaults to 5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>impute_with_treatment, impute_with_outcome</code></td>
<td>
<p>If <code>TRUE</code>, use
treatment, outcome, respectively, to impute covariates when either
<code>missing_data</code> or <code>missing_holdout</code> is equal to <code>'impute'</code>.
Default to <code>TRUE</code>, <code>FALSE</code>, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_flame_iters</code></td>
<td>
<p>Specifies that this many iterations of FLAME should be
run before switching to DAME. This can be used to speed up the matching
procedure as FLAME rapidly eliminates irrelevant covariates, after which
DAME will make higher quality matches on the remaining variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>ame</code>, returned by a call to
<code>FLAME</code> or <code>DAME</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>Number of significant digits for printing the average treatment
effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linewidth</code></td>
<td>
<p>Maximum number of characters on line; output will be wrapped
accordingly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to other methods.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of type <code>ame</code>, which by default is a list of 4
entries:
</p>

<dl>
<dt>data</dt>
<dd>
<p>The original data frame with several modifications:
</p>

<ol>
<li>
<p> An extra logical column, <code>data$matched</code>, that indicates
whether or not a unit was matched.
</p>
</li>
<li>
<p> An extra numeric column, <code>data$weight</code>, that denotes on how
many different sets of covariates a unit was matched. This will only be
greater than 1 when <code>replace = TRUE</code>.
</p>
</li>
<li>
<p> The columns denoting treatment and outcome will be moved after all
covariate columns.
</p>
</li>
<li>
<p> If <code>replace</code> is <code>FALSE</code>, a column containing a matched
group identifier for each unit.
</p>
</li>
<li>
<p> If, <code>estimate_CATEs = TRUE</code>, a column containing the CATE
estimate for each unit.
</p>
</li>
</ol>
</dd>
<dt>MGs</dt>
<dd>
<p>A list whose <code class="reqn">i</code>'th entry contains the indices of units in
the main matched group of the <code class="reqn">i</code>'th unit.</p>
</dd>
<dt>cov_sets</dt>
<dd>
<p>A list whose <code class="reqn">i</code>'th entry contains the covariates set
<strong>not</strong> matched on in the <code class="reqn">i</code>'th iteration.</p>
</dd>
<dt>info</dt>
<dd>
<p>A list containing miscellaneous information about the data and
matching specifications. Primarily for use by <code>*.ame</code> methods.</p>
</dd>
</dl>
<h3>Introduction</h3>

<p>FLAME and DAME are matching algorithms for
observational causal inference on data with discrete (categorical)
covariates. They match units that share identical values of certain
covariates, as follows. The algorithms first make any possible <em>exact</em>
matches; that is, they match units that share identical values of all
covariates (this is possible because covariates are discrete). They then
iteratively drop a set of covariates and make any possible matches on the
remaining covariates, until stopping. For each unit, DAME solves an
optimization problem that finds the highest quality set of covariates the
unit can be matched to others on, where quality is determined by how well
that set of covariates predicts the outcome. FLAME approximates the
solution to the problem solved by DAME; at each step, it drops the
covariate leading to the smallest drop in match quality <code class="reqn">MQ</code>, defined
as <code class="reqn">MQ = C · BF - PE</code>. Here, <code class="reqn">PE</code> denotes the predictive error,
which measures how important the dropped covariate is for predicting the
outcome. The balancing factor <code class="reqn">BF</code> measures the number of matches
formed by dropping that covariate. In this way, FLAME encourages matching
on covariates more important to the outcome and also making many matches.
The hyperparameter <code class="reqn">C</code> controls the balance between these two
objectives. In both cases, a machine learning algorithm trained on a
holdout dataset is responsible for learning the quality / importance of
covariates. For more details on the algorithms, please see the vignette,
the FLAME paper <a href="https://arxiv.org/pdf/1707.06315.pdf">here</a> and/or
the DAME paper <a href="https://arxiv.org/pdf/1806.06802.pdf">here</a>.
</p>


<h3>Stopping Rules</h3>

<p>By default, both <code>FLAME</code> and <code>DAME</code> stop
when 1. all covariates have been dropped or 2. all treatment or control
units have been matched. This behavior can be modified by the arguments
whose prefix is "early_stop". With the exception of
<code>early_stop_iterations</code>, all the rules come into play <em>before</em>
the offending covariate set is dropped. For example, if
<code>early_stop_control = 0.2</code> and at the current iteration, dropping the
covariate leading to highest match quality is associated with a unmatched
control proportion of 0.1, FLAME will stop <em>without</em> dropping this
covariate.
</p>


<h3>Missing Data</h3>

<p><code>FLAME</code> and <code>DAME</code> offer functionality for
handling missing data in the covariates, for both the <code>data</code> and
<code>holdout</code> sets. This functionality can be specified via the arguments
whose prefix is "missing" or "impute". It allows for ignoring missing data,
imputing it, or (for <code>data</code>) not matching on missing values. If
<code>data</code> is imputed, imputation will be done once and the matching
algorithm will be run on the imputed dataset. If <code>holdout</code> is imputed,
the predictive error at an iteration will be the average of predictive
errors across all imputed <code>holdout</code> datasets. Units with missingness
in the treatment or outcome will be dropped.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data &lt;- gen_data()
holdout &lt;- gen_data()
# FLAME with replacement, stopping after dropping a single covariate
FLAME_out &lt;- FLAME(data = data, holdout = holdout,
                   replace = TRUE, early_stop_iterations = 2)

# Use a linear model to compute predictive error. Call DAME without
# replacement, returning predictive error at each iteration.
my_PE &lt;- function(X, Y) {
  return(lm(Y ~ ., as.data.frame(cbind(X, Y = Y)))$fitted.values)
}
DAME_out &lt;- DAME(data = data, holdout = holdout,
                 PE_method = my_PE, return_PE = TRUE)

## End(Not run)
</code></pre>


</div>