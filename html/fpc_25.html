<div class="container">

<table style="width: 100%;"><tr>
<td>clusterbenchstats</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run and validate many clusterings</h2>

<h3>Description</h3>

<p>This runs the methodology explained in Hennig (2019), Akhanli and
Hennig (2020). It runs a
user-specified set of clustering methods (CBI-functions, see
<code>kmeansCBI</code>) with several numbers of clusters on a dataset,
and computes many cluster validation indexes. In order to explore the
variation of these indexes, random clusterings on the data are
generated, and validation indexes are standardised by use of the
random clusterings in order to make them comparable and differences
between values interpretable.
</p>
<p>The function <code>print.valstat</code> can be used to provide
weights for the cluster
validation statistics, and will then compute a weighted validation index
that can be used to compare all clusterings.
</p>
<p>See the examples for how to get the indexes A1 and A2 from
Akhanli and Hennig (2020).
</p>


<h3>Usage</h3>

<pre><code class="language-R">clusterbenchstats(data,G,diss = inherits(data, "dist"),
                                  scaling=TRUE, clustermethod,
                                  methodnames=clustermethod,
                              distmethod=rep(TRUE,length(clustermethod)),
                              ncinput=rep(TRUE,length(clustermethod)),
                              clustermethodpars,
                              npstats=FALSE,
                              useboot=FALSE,
                              bootclassif=NULL,
                              bootmethod="nselectboot",
                              bootruns=25,
                              trace=TRUE,
                              pamcrit=TRUE,snnk=2,
                              dnnk=2,
                              nnruns=100,kmruns=100,fnruns=100,avenruns=100,
                              multicore=FALSE,cores=detectCores()-1,
                              useallmethods=TRUE,
                              useallg=FALSE,...)

## S3 method for class 'clusterbenchstats'
print(x,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data matrix or <code>dist</code>-object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>vector of integers. Numbers of clusters to consider.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diss</code></td>
<td>
<p>logical. If <code>TRUE</code>, the data matrix is assumed to be
a distance/dissimilariy matrix, otherwise it's observations times
variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>either a logical or a numeric vector of length equal to
the number of columns of <code>data</code>. If <code>FALSE</code>, data won't be
scaled, otherwise <code>scaling</code> is passed on to <code>scale</code> as
argument<code>scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustermethod</code></td>
<td>
<p>vector of strings specifying names of
CBI-functions (see <code>kmeansCBI</code>). These are the
clustering methods to be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>methodnames</code></td>
<td>
<p>vector of strings with user-chosen names for
clustering methods, one for every method in
<code>clustermethod</code>. These can be used to distinguish different methods
run by the same CBI-function but with
different parameter values such as complete and average linkage for
<code>hclustCBI</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distmethod</code></td>
<td>
<p>vector of logicals, of the same length as
<code>clustermethod</code>. <code>TRUE</code> means that the clustering method
operates on distances. If <code>diss=TRUE</code>, all entries have to be
<code>TRUE</code>. Otherwise, if an entry is true, the corresponding
method will be applied on <code>dist(data)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncinput</code></td>
<td>
<p>vector of logicals, of the same length as
<code>clustermethod</code>. <code>TRUE</code> indicates that the corresponding
clustering method requires the number of clusters as input and will
not estimate the number of clusters itself. Only methods for which
this is <code>TRUE</code> can be used with <code>useboot=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clustermethodpars</code></td>
<td>
<p>list of the same length as
<code>clustermethod</code>. Specifies parameters for all involved
clustering methods. Its jth entry is passed to clustermethod number
k. Can be an empty entry in case all defaults are used for a
clustering method. However, the last entry is not allowed to be
empty (you may just set a parameter of the last clustering method to
its default value if you don't want to specify anything else)! The
number of clusters does not need to be
specified here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npstats</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>distrsimilarity</code>
is called and the two validity statistics computed there are
added. These require <code>diss=FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useboot</code></td>
<td>
<p>logical. If <code>TRUE</code>, a stability index (either
<code>nselectboot</code> or <code>prediction.strength</code>) will be involved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootclassif</code></td>
<td>
<p>If <code>useboot=TRUE</code>, a vector of strings
indicating the
classification methods to be used with the stability index for the
different methods indicated in <code>clustermethods</code>, see the
<code>classification</code> argument of <code>nselectboot</code> and
<code>prediction.strength</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootmethod</code></td>
<td>
<p>either <code>"nselectboot"</code> or
<code>"prediction.strength"</code>; stability index to be used if
<code>useboot=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bootruns</code></td>
<td>
<p>integer. Number of resampling runs. If
<code>useboot=TRUE</code>, passed on as <code>B</code> to
<code>nselectboot</code> or
<code>M</code> to <code>prediction.strength</code>. Note that these are
applied to all <code>kmruns+nnruns+avenruns+fnruns</code> random
clusterings on top of the regular ones, which may take a lot of time
if <code>bootruns</code> and these values are chosen large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>logical. If <code>TRUE</code>, some runtime information is
printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pamcrit</code></td>
<td>
<p>logical. If <code>TRUE</code>, the average distance of points
to their respective cluster centroids is computed (criterion of the
PAM clustering method, validation criterion <code>pamc</code>); centroids
are chosen so that they minimise
this criterion for the given clustering. Passed on to
<code>cqcluster.stats</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>snnk</code></td>
<td>
<p>integer. Number of neighbours used in coefficient of
variation of distance to nearest within cluster neighbour, the
<code>cvnnd</code>-statistic  (clusters
with <code>snnk</code> or fewer points are ignored for this). Passed on to
<code>cqcluster.stats</code> as argument <code>nnk</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dnnk</code></td>
<td>
<p>integer. Number of nearest neighbors to use for
dissimilarity to the uniform in case that <code>npstats=TRUE</code>;
<code>nnk</code>-argument  to be passed on to <code>distrsimilarity</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnruns</code></td>
<td>
<p>integer. Number of runs of <code>stupidknn</code>
(random clusterings). With <code>useboot=TRUE</code> one may want to
choose this lower than the default for reasons of computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kmruns</code></td>
<td>
<p>integer. Number of runs of
<code>stupidkcentroids</code> (random clusterings). With
<code>useboot=TRUE</code> one may want to
choose this lower than the default for reasons of computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fnruns</code></td>
<td>
<p>integer. Number of runs of <code>stupidkfn</code>
(random clusterings).  With <code>useboot=TRUE</code> one may want to
choose this lower than the default for reasons of computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avenruns</code></td>
<td>
<p>integer. Number of runs of <code>stupidkaven</code>
(random clusterings). With <code>useboot=TRUE</code> one may want to
choose this lower than the default for reasons of computation time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>multicore</code></td>
<td>
<p>logical. If <code>TRUE</code>, parallel computing is used
through the function <code>mclapply</code> from package
<code>parallel</code>; read warnings there if you intend to use this; it
won't work on Windows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>integer. Number of cores for parallelisation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useallmethods</code></td>
<td>
<p>logical, to be passed on to
<code>cgrestandard</code>. If <code>FALSE</code>, only random clustering
results are used for standardisation. If
<code>TRUE</code>, clustering results from all methods are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useallg</code></td>
<td>
<p>logical to be passed on to
<code>cgrestandard</code>. If <code>TRUE</code>, standardisation uses results
from all numbers of clusters in <code>G</code>. If <code>FALSE</code>,
standardisation of results for a specific number of cluster only
uses results from that number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed on to
<code>cqcluster.stats</code> through <code>clustatsum</code> (no
effect in <code>print.clusterbenchstats</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class <code>"clusterbenchstats"</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The output of <code>clusterbenchstats</code> is a
big list of lists comprising lists <code>cm, stat, sim, qstat,
    sstat</code>
</p>
<table><tr style="vertical-align: top;">
<td><code>cm</code></td>
<td>
<p>output object of <code>cluster.magazine</code>, see there
for details. Clustering of all methods and numbers of clusters on
the dataset <code>data</code>.</p>
</td>
</tr></table>
<p>. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>stat</code></td>
<td>
<p>object of class <code>"valstat"</code>, see
<code>valstat.object</code> for details. Unstandardised cluster
validation statistics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim</code></td>
<td>
<p>output object of <code>randomclustersim</code>, see there.
validity indexes from random clusterings used for standardisation of
validation statistics on <code>data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qstat</code></td>
<td>
<p>object of class <code>"valstat"</code>, see
<code>valstat.object</code> for details. Cluster validation
statistics standardised by random clusterings, output of
<code>cgrestandard</code> based on percentages, i.e., with
<code>percentage=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sstat</code></td>
<td>
<p>object of class <code>"valstat"</code>, see
<code>valstat.object</code> for details. Cluster validation
statistics standardised by random clusterings, output of
<code>cgrestandard</code> based on mean and standard deviation
(called Z-score standardisation in Akhanli and Hennig (2020),
i.e., with <code>percentage=FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>This may require a lot of computing time and also memory for datasets
that are not small, as most indexes require computation and storage of
distances. 
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Hennig, C. (2019) Cluster validation by measurement of clustering
characteristics relevant to the user. In C. H. Skiadas (ed.)
<em>Data Analysis and Applications 1: Clustering and Regression,
Modeling-estimating, Forecasting and Data Mining, Volume 2</em>, Wiley,
New York 1-24,
<a href="https://arxiv.org/abs/1703.09282">https://arxiv.org/abs/1703.09282</a>
</p>
<p>Akhanli, S. and Hennig, C. (2020) Calibrating and aggregating cluster
validity indexes for context-adapted comparison of clusterings.
<em>Statistics and Computing</em>, 30, 1523-1544,
<a href="https://link.springer.com/article/10.1007/s11222-020-09958-2">https://link.springer.com/article/10.1007/s11222-020-09958-2</a>, <a href="https://arxiv.org/abs/2002.01822">https://arxiv.org/abs/2002.01822</a>
</p>


<h3>See Also</h3>

<p><code>valstat.object</code>,
<code>cluster.magazine</code>, <code>kmeansCBI</code>,
<code>cqcluster.stats</code>, <code>clustatsum</code>,
<code>cgrestandard</code>  
</p>


<h3>Examples</h3>

<pre><code class="language-R">  
  set.seed(20000)
  options(digits=3)
  face &lt;- rFace(10,dMoNo=2,dNoEy=0,p=2)
  clustermethod=c("kmeansCBI","hclustCBI")
# A clustering method can be used more than once, with different
# parameters
  clustermethodpars &lt;- list()
  clustermethodpars[[2]] &lt;- list()
  clustermethodpars[[2]]$method &lt;- "average"
# Last element of clustermethodpars needs to have an entry!
  methodname &lt;- c("kmeans","average")
  cbs &lt;-  clusterbenchstats(face,G=2:3,clustermethod=clustermethod,
    methodname=methodname,distmethod=rep(FALSE,2),
    clustermethodpars=clustermethodpars,nnruns=1,kmruns=1,fnruns=1,avenruns=1)
  print(cbs)
  print(cbs$qstat,aggregate=TRUE,weights=c(1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1))
# The weights are weights for the validation statistics ordered as in
# cbs$qstat$statistics for computation of an aggregated index, see
# ?print.valstat.

# Now using bootstrap stability assessment as in Akhanli and Hennig (2020):
  bootclassif &lt;- c("centroid","averagedist")
  cbsboot &lt;- clusterbenchstats(face,G=2:3,clustermethod=clustermethod,
    methodname=methodname,distmethod=rep(FALSE,2),
    clustermethodpars=clustermethodpars,
    useboot=TRUE,bootclassif=bootclassif,bootmethod="nselectboot",
    bootruns=2,nnruns=1,kmruns=1,fnruns=1,avenruns=1,useallg=TRUE)
  print(cbsboot)
## Not run: 
# Index A1 in Akhanli and Hennig (2020) (need these weights choices):
  print(cbsboot$sstat,aggregate=TRUE,weights=c(1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0))
# Index A2 in Akhanli and Hennig (2020) (need these weights choices):
  print(cbsboot$sstat,aggregate=TRUE,weights=c(0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0))

## End(Not run)

# Results from nselectboot:
  plot(cbsboot$stat,cbsboot$sim,statistic="boot")
</code></pre>


</div>