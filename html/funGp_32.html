<div class="container">

<table style="width: 100%;"><tr>
<td>simulate,fgpm-method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Random sampling from a <code>fgpm</code> model</h2>

<h3>Description</h3>

<p>This method enables simulation of Gaussian process values at any given set of points
based on a pre-built <code>fgpm</code> model. Check <code>fgpm</code> for information on how to create funGp models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'fgpm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  sIn.sm = NULL,
  fIn.sm = NULL,
  nugget.sm = 0,
  detail = c("light", "full"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An object of class fgpm corresponding to the funGp model from which
simulations must be performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nsim</code></td>
<td>
<p>An optional integer indicating the number of samples to produce. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An optional value interpreted as an integer, that will be used as argument of
<code>set.seed</code> just before simulating the response values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sIn.sm</code></td>
<td>
<p>An optional matrix of scalar input coordinates at which the output values should be
simulated. Each column is interpreted as a scalar input variable and each row as a coordinate.
Either scalar input coordinates (sIn.sm), functional input coordinates (fIn.sm), or both must be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fIn.sm</code></td>
<td>
<p>An optional list of functional input coordinates at which the output values should be
simulated. Each element of the list is interpreted as a functional input variable. Every functional input
variable should be provided as a matrix with one curve per row. Either scalar input coordinates (sIn.sm),
functional input coordinates (fIn.sm), or both must be provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nugget.sm</code></td>
<td>
<p>An optional number corresponding to a numerical nugget effect. If provided, this number
is added to the main diagonal of the simulation covariance matrix in order to prevent numerical
instabilities during Cholesky decomposition. A small number in the order of 1e-8 is often enough.
Default is 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detail</code></td>
<td>
<p>An optional character specifying the extent of information that should be delivered
by the method, to be chosen between <code>"light"</code> (default)  and <code>"full"</code>.
<em>Light</em> simulations produce a matrix of
simulated output values, with as many rows as requested random samples. <em>Full</em> simulations produce a
list with the matrix of simulated output values, along with the predicted mean, standard deviation and
limits of the 95% confidence intervals at the simulation points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object containing the data structures linked to simulations. For <em>light</em> simulations, the
output will be a matrix of simulated output values, with as many rows as requested random samples.
For <em>full</em> simulations, the output will be a list with the matrix of simulated output values,
along with the predicted mean, standard deviation and limits of the 95% confidence intervals at the
simulation points.
</p>


<h3>Author(s)</h3>

<p>José Betancourt, François Bachoc, Thierry Klein and Jérémy Rohmer
</p>


<h3>See Also</h3>

<p><strong>*</strong> plot.simulate.fgpm for the simulation plot of a <code>fgpm</code> model;
</p>
<p><strong>*</strong> predict,fgpm-method for predictions based on a <code>fgpm</code> model;
</p>
<p><strong>*</strong> plot.predict.fgpm for the prediction plot of a <code>fgpm</code> model.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># light simulations _______________________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# generating input data for simulation
n.sm &lt;- 100
sIn.sm &lt;- as.matrix(expand.grid(x1 = seq(0,1,length = sqrt(n.sm)),
                                x2 = seq(0,1,length = sqrt(n.sm))))
fIn.sm &lt;- list(f1 = matrix(runif(n.sm*10), ncol = 10), matrix(runif(n.sm*22), ncol = 22))

# making light simulations
m1.sims_l &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm)

# plotting light simulations
plot(m1.sims_l)


# full simulations ________________________________________________________________________
# building the model
set.seed(100)
n.tr &lt;- 25
sIn &lt;- expand.grid(x1 = seq(0,1,length = sqrt(n.tr)), x2 = seq(0,1,length = sqrt(n.tr)))
fIn &lt;- list(f1 = matrix(runif(n.tr*10), ncol = 10), f2 = matrix(runif(n.tr*22), ncol = 22))
sOut &lt;- fgp_BB3(sIn, fIn, n.tr)
m1 &lt;- fgpm(sIn = sIn, fIn = fIn, sOut = sOut)

# making full simulations
m1.sims_f &lt;- simulate(m1, nsim = 10, sIn.sm = sIn.sm, fIn.sm = fIn.sm, detail = "full")

# checking content of the list
summary(m1.sims_f)

# ~R output:~
#         Length Class  Mode
# sims    1000   -none- numeric
# mean     100   -none- numeric
# sd       100   -none- numeric
# lower95  100   -none- numeric
# upper95  100   -none- numeric

# plotting full simulations in full mode
plot(m1.sims_f)

# plotting full simulations in light mode
plot(m1.sims_f, detail = "light")

</code></pre>


</div>