<div class="container">

<table style="width: 100%;"><tr>
<td>rotateA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Rotate Conic Section Equation Parameters Or A Dataset, With Respect To X-Y Axes.
</h2>

<h3>Description</h3>


<p><code>rotateA</code> Takes as input "parA," the 6 values of the general quadratic Ax^2 + Bxy + Cy^2 +Dx + Ey +F = 0 , and applies a rotation angle to the coefficient set. 
<code>derotateA</code> calculates the rotation angle required to change the conic section defined by 'parA' into one that is orthogonal to the cartesian axes. 
<code>xyrot</code> is a simple function to rotate the coordinate system by theta. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">rotateA(parA, theta)
derotateA(parA, ACmin = 1e-05)
xyrot(x, y = NULL, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>parA</code></td>
<td>


<p>the 6 values of the general quadratic Ax^2 + Bxy + Cy^2 +Dx + Ey +F = 0 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>


<p>the angle, in radians, to rotate the conic section. 
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ACmin</code></td>
<td>

<p>A tolerance parameter for deciding that the product of 
parameters A and C is actually zero (in which case the 
type of conic section is more likely a parabola or a degenerate case)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Either a vector of x-coordinates or a Nx2 array of x and 
y coordinates, in which case the y-input is ignored
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>

<p>A vector of y-coordinates.
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p><code>derotateA</code> uses the following standard formula to calculate the angle.
Derotate means to remove the xy term, i.e. force B = 0 . Some algebra shows that  cot(2theta) = (A-C)/B  and thus tan(2theta) = B/(A-C)
</p>
<p>For <code>xyrot</code>, the internal <code>xy.coords</code> is used. If you enter only a vector for x and nothing for y, this will feed the new vectors 1:N for x and x-input for y to the rotator, which is probably not useful. 
</p>


<h3>Value</h3>

<p>For <code>derotateA</code>, 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>parA</code></td>
<td>
<p>the new 6-parameter set defining the derotated conic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>the derived angle by which the parameter set was rotated</p>
</td>
</tr>
</table>
<p>For <code>rotateA</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>parA</code></td>
<td>
<p>the new 6-parameter set defining the rotated conic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>the angle by which the parameter set was rotated</p>
</td>
</tr>
</table>
<p>For <code>xyrot</code> a Nx2 array of the x,y coordinates of the rotated data set. 
</p>


<h3>Author(s)</h3>

<p>Carl Witthoft,  <a href="mailto:carl@witthoft.com">carl@witthoft.com</a>
</p>


<h3>See Also</h3>

<p><code>createConic</code>

</p>


<h3>Examples</h3>

<pre><code class="language-R"># make an ellipse and derotate it
parGr &lt;- c(-2.3,4.2,5,3,pi/4)
xe &lt;-seq(-8,9,by=.05)
elipGr &lt;- createConic(xe,  parGr, 'e')
plot(elipGr, t= 'l',  asp = TRUE)
# convert to ABCDEF form
parAr &lt;- GtoA(parGr,'e')
elipAr &lt;- createConic(xe,parAr$parA) 
points(elipAr,pch='.',col='red')
# remove rotation angle
 parAd &lt;- derotateA(parAr$parA)
 # returns theta = pi/4, how much the ellipse had been rotated by
 elipAd &lt;-createConic(xe,parAd$parA)
lines(elipAd)
# rotate back
parAdr &lt;- rotateA(parAd$parA, parAd$theta)
elipAdr &lt;-createConic(xe,parAdr$parA)
lines(elipAdr,lty=3, lwd = 3, col='green')


</code></pre>


</div>