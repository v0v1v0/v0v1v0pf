<div class="container">

<table style="width: 100%;"><tr>
<td>summon_familiar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Perform end-to-end machine learning and data analysis</h2>

<h3>Description</h3>

<p>Perform end-to-end machine learning and data analysis
</p>


<h3>Usage</h3>

<pre><code class="language-R">summon_familiar(
  formula = NULL,
  data = NULL,
  experiment_data = NULL,
  cl = NULL,
  config = NULL,
  config_id = 1L,
  verbose = TRUE,
  .stop_after = "evaluation",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>An R formula. The formula can only contain feature names and
dot (<code>.</code>). The <code>*</code> and <code>+1</code> operators are not supported as these refer to
columns that are not present in the data set.
</p>
<p>Use of the formula interface is optional.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>data.table</code> object, a <code>data.frame</code> object, list containing
multiple <code>data.table</code> or <code>data.frame</code> objects, or paths to data files.
</p>
<p><code>data</code> should be provided if no file paths are provided to the <code>data_files</code>
argument. If both are provided, only <code>data</code> will be used.
</p>
<p>All data is expected to be in wide format, and ideally has a sample
identifier (see <code>sample_id_column</code>), batch identifier (see <code>cohort_column</code>)
and outcome columns (see <code>outcome_column</code>).
</p>
<p>In case paths are provided, the data should be stored as <code>csv</code>, <code>rds</code> or
<code>RData</code> files. See documentation for the <code>data_files</code> argument for more
information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>experiment_data</code></td>
<td>
<p>Experimental data may provided in the form of</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl</code></td>
<td>
<p>Cluster created using the <code>parallel</code> package. This cluster is then
used to speed up computation through parallelisation. When a cluster is not
provided, parallelisation is performed by setting up a cluster on the local
machine.
</p>
<p>This parameter has no effect if the <code>parallel</code> argument is set to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>config</code></td>
<td>
<p>List containing configuration parameters, or path to an <code>xml</code>
file containing these parameters. An empty configuration file can obtained
using the <code>get_xml_config</code> function.
</p>
<p>All parameters can also be set programmatically. These supersede any
arguments derived from the configuration list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>config_id</code></td>
<td>
<p>Identifier for the configuration in case the list or <code>xml</code>
table indicated by <code>config</code> contains more than one set of configurations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Indicates verbosity of the results. Default is TRUE, and all
messages and warnings are returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.stop_after</code></td>
<td>
<p>Variable for internal use.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>.parse_file_paths</code>, <code>.parse_experiment_settings</code>, <code>.parse_setup_settings</code>, <code>.parse_preprocessing_settings</code>, <code>.parse_feature_selection_settings</code>, <code>.parse_model_development_settings</code>, <code>.parse_hyperparameter_optimisation_settings</code>, <code>.parse_evaluation_settings</code>
</p>

<dl>
<dt><code>project_dir</code></dt>
<dd>
<p>(<em>optional</em>) Path to the project directory. <code>familiar</code>
checks if the directory indicated by <code>experiment_dir</code> and data files in
<code>data_file</code> are relative to the <code>project_dir</code>.</p>
</dd>
<dt><code>experiment_dir</code></dt>
<dd>
<p>(<strong>recommended</strong>) Path to the directory where all
intermediate and final results produced by <code>familiar</code> are written to.
</p>
<p>The <code>experiment_dir</code> can be a path relative to <code>project_dir</code> or an absolute
path.
</p>
<p>In case no project directory is provided and the experiment directory is
not on an absolute path, a directory will be created in the temporary R
directory indicated by <code>tempdir()</code>. This directory is deleted after closing
the R session or once data analysis has finished. All information will be
lost afterwards. Hence, it is recommended to provide either
<code>experiment_dir</code> as an absolute path, or provide both <code>project_dir</code> and
<code>experiment_dir</code>.</p>
</dd>
<dt><code>data_file</code></dt>
<dd>
<p>(<em>optional</em>) Path to files containing data that should be
analysed. The paths can be relative to <code>project_dir</code> or absolute paths. An
error will be raised if the file cannot be found.
</p>
<p>The following types of data are supported.
</p>

<ul>
<li> <p><code>csv</code> files containing column headers on the first row, and samples per
row. <code>csv</code> files are read using <code>data.table::fread</code>.
</p>
</li>
<li> <p><code>rds</code> files that contain a <code>data.table</code> or <code>data.frame</code> object. <code>rds</code>
files are imported using <code>base::readRDS</code>.
</p>
</li>
<li> <p><code>RData</code> files that contain a single <code>data.table</code> or <code>data.frame</code> object.
<code>RData</code> files are imported using <code>base::load</code>.
</p>
</li>
</ul>
<p>All data are expected in wide format, with sample information organised
row-wise.
</p>
<p>More than one data file can be provided. <code>familiar</code> will try to combine
data files based on column names and identifier columns.
</p>
<p>Alternatively, data can be provided using the <code>data</code> argument. These data
are expected to be <code>data.frame</code> or <code>data.table</code> objects or paths to data
files. The latter are handled in the same way as file paths provided to
<code>data_file</code>.</p>
</dd>
<dt><code>batch_id_column</code></dt>
<dd>
<p>(<strong>recommended</strong>) Name of the column containing batch
or cohort identifiers. This parameter is required if more than one dataset
is provided, or if external validation is performed.
</p>
<p>In familiar any row of data is organised by four identifiers:
</p>

<ul>
<li>
<p> The batch identifier <code>batch_id_column</code>: This denotes the group to which a
set of samples belongs, e.g. patients from a single study, samples measured
in a batch, etc. The batch identifier is used for batch normalisation, as
well as selection of development and validation datasets.
</p>
</li>
<li>
<p> The sample identifier <code>sample_id_column</code>: This denotes the sample level,
e.g. data from a single individual. Subsets of data, e.g. bootstraps or
cross-validation folds, are created at this level.
</p>
</li>
<li>
<p> The series identifier <code>series_id_column</code>: Indicates measurements on a
single sample that may not share the same outcome value, e.g. a time
series, or the number of cells in a view.
</p>
</li>
<li>
<p> The repetition identifier: Indicates repeated measurements in a single
series where any feature values may differ, but the outcome does not.
Repetition identifiers are always implicitly set when multiple entries for
the same series of the same sample in the same batch that share the same
outcome are encountered.
</p>
</li>
</ul>
</dd>
<dt><code>sample_id_column</code></dt>
<dd>
<p>(<strong>recommended</strong>) Name of the column containing
sample or subject identifiers. See <code>batch_id_column</code> above for more
details.
</p>
<p>If unset, every row will be identified as a single sample.</p>
</dd>
<dt><code>series_id_column</code></dt>
<dd>
<p>(<strong>optional</strong>) Name of the column containing series
identifiers, which distinguish between measurements that are part of a
series for a single sample. See <code>batch_id_column</code> above for more details.
</p>
<p>If unset, rows which share the same batch and sample identifiers but have a
different outcome are assigned unique series identifiers.</p>
</dd>
<dt><code>development_batch_id</code></dt>
<dd>
<p>(<em>optional</em>) One or more batch or cohort
identifiers to constitute data sets for development. Defaults to all, or
all minus the identifiers in <code>validation_batch_id</code> for external validation.
Required if external validation is performed and <code>validation_batch_id</code> is
not provided.</p>
</dd>
<dt><code>validation_batch_id</code></dt>
<dd>
<p>(<em>optional</em>) One or more batch or cohort
identifiers to constitute data sets for external validation. Defaults to
all data sets except those in <code>development_batch_id</code> for external
validation, or none if not. Required if <code>development_batch_id</code> is not
provided.</p>
</dd>
<dt><code>outcome_name</code></dt>
<dd>
<p>(<em>optional</em>) Name of the modelled outcome. This name will
be used in figures created by <code>familiar</code>.
</p>
<p>If not set, the column name in <code>outcome_column</code> will be used for
<code>binomial</code>, <code>multinomial</code>, <code>count</code> and <code>continuous</code> outcomes. For other
outcomes (<code>survival</code> and <code>competing_risk</code>) no default is used.</p>
</dd>
<dt><code>outcome_column</code></dt>
<dd>
<p>(<strong>recommended</strong>) Name of the column containing the
outcome of interest. May be identified from a formula, if a formula is
provided as an argument. Otherwise an error is raised. Note that <code>survival</code>
and <code>competing_risk</code> outcome type outcomes require two columns that
indicate the time-to-event or the time of last follow-up and the event
status.</p>
</dd>
<dt><code>outcome_type</code></dt>
<dd>
<p>(<strong>recommended</strong>) Type of outcome found in the outcome
column. The outcome type determines many aspects of the overall process,
e.g. the available feature selection methods and learners, but also the
type of assessments that can be conducted to evaluate the resulting models.
Implemented outcome types are:
</p>

<ul>
<li> <p><code>binomial</code>: categorical outcome with 2 levels.
</p>
</li>
<li> <p><code>multinomial</code>: categorical outcome with 2 or more levels.
</p>
</li>
<li> <p><code>count</code>: Poisson-distributed numeric outcomes.
</p>
</li>
<li> <p><code>continuous</code>: general continuous numeric outcomes.
</p>
</li>
<li> <p><code>survival</code>: survival outcome for time-to-event data.
</p>
</li>
</ul>
<p>If not provided, the algorithm will attempt to obtain outcome_type from
contents of the outcome column. This may lead to unexpected results, and we
therefore advise to provide this information manually.
</p>
<p>Note that <code>competing_risk</code> survival analysis are not fully supported, and
is currently not a valid choice for <code>outcome_type</code>.</p>
</dd>
<dt><code>class_levels</code></dt>
<dd>
<p>(<em>optional</em>) Class levels for <code>binomial</code> or <code>multinomial</code>
outcomes. This argument can be used to specify the ordering of levels for
categorical outcomes. These class levels must exactly match the levels
present in the outcome column.</p>
</dd>
<dt><code>event_indicator</code></dt>
<dd>
<p>(<strong>recommended</strong>) Indicator for events in <code>survival</code>
and <code>competing_risk</code> analyses. <code>familiar</code> will automatically recognise <code>1</code>,
<code>true</code>, <code>t</code>, <code>y</code> and <code>yes</code> as event indicators, including different
capitalisations. If this parameter is set, it replaces the default values.</p>
</dd>
<dt><code>censoring_indicator</code></dt>
<dd>
<p>(<strong>recommended</strong>) Indicator for right-censoring in
<code>survival</code> and <code>competing_risk</code> analyses. <code>familiar</code> will automatically
recognise <code>0</code>, <code>false</code>, <code>f</code>, <code>n</code>, <code>no</code> as censoring indicators, including
different capitalisations. If this parameter is set, it replaces the
default values.</p>
</dd>
<dt><code>competing_risk_indicator</code></dt>
<dd>
<p>(<strong>recommended</strong>) Indicator for competing
risks in <code>competing_risk</code> analyses. There are no default values, and if
unset, all values other than those specified by the <code>event_indicator</code> and
<code>censoring_indicator</code> parameters are considered to indicate competing
risks.</p>
</dd>
<dt><code>signature</code></dt>
<dd>
<p>(<em>optional</em>) One or more names of feature columns that are
considered part of a specific signature. Features specified here will
always be used for modelling. Ranking from feature selection has no effect
for these features.</p>
</dd>
<dt><code>novelty_features</code></dt>
<dd>
<p>(<em>optional</em>) One or more names of feature columns
that should be included for the purpose of novelty detection.</p>
</dd>
<dt><code>exclude_features</code></dt>
<dd>
<p>(<em>optional</em>) Feature columns that will be removed
from the data set. Cannot overlap with features in <code>signature</code>,
<code>novelty_features</code> or <code>include_features</code>.</p>
</dd>
<dt><code>include_features</code></dt>
<dd>
<p>(<em>optional</em>) Feature columns that are specifically
included in the data set. By default all features are included. Cannot
overlap with <code>exclude_features</code>, but may overlap <code>signature</code>. Features in
<code>signature</code> and <code>novelty_features</code> are always included. If both
<code>exclude_features</code> and <code>include_features</code> are provided, <code>include_features</code>
takes precedence, provided that there is no overlap between the two.</p>
</dd>
<dt><code>reference_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used to set reference levels for
categorical features. There are several options:
</p>

<ul>
<li> <p><code>auto</code> (default): Categorical features that are not explicitly set by the
user, i.e. columns containing boolean values or characters, use the most
frequent level as reference. Categorical features that are explicitly set,
i.e. as factors, are used as is.
</p>
</li>
<li> <p><code>always</code>: Both automatically detected and user-specified categorical
features have the reference level set to the most frequent level. Ordinal
features are not altered, but are used as is.
</p>
</li>
<li> <p><code>never</code>: User-specified categorical features are used as is.
Automatically detected categorical features are simply sorted, and the
first level is then used as the reference level. This was the behaviour
prior to familiar version 1.3.0.
</p>
</li>
</ul>
</dd>
<dt><code>experimental_design</code></dt>
<dd>
<p>(<strong>required</strong>) Defines what the experiment looks
like, e.g. <code>cv(bt(fs,20)+mb,3,2)+ev</code> for 2 times repeated 3-fold
cross-validation with nested feature selection on 20 bootstraps and
model-building, and external validation. The basic workflow components are:
</p>

<ul>
<li> <p><code>fs</code>: (required) feature selection step.
</p>
</li>
<li> <p><code>mb</code>: (required) model building step.
</p>
</li>
<li> <p><code>ev</code>: (optional) external validation. Note that internal validation due
to subsampling will always be conducted if the subsampling methods create
any validation data sets.
</p>
</li>
</ul>
<p>The different components are linked using <code>+</code>.
</p>
<p>Different subsampling methods can be used in conjunction with the basic
workflow components:
</p>

<ul>
<li> <p><code>bs(x,n)</code>: (stratified) .632 bootstrap, with <code>n</code> the number of
bootstraps. In contrast to <code>bt</code>, feature pre-processing parameters and
hyperparameter optimisation are conducted on individual bootstraps.
</p>
</li>
<li> <p><code>bt(x,n)</code>: (stratified) .632 bootstrap, with <code>n</code> the number of
bootstraps. Unlike <code>bs</code> and other subsampling methods, no separate
pre-processing parameters or optimised hyperparameters will be determined
for each bootstrap.
</p>
</li>
<li> <p><code>cv(x,n,p)</code>: (stratified) <code>n</code>-fold cross-validation, repeated <code>p</code> times.
Pre-processing parameters are determined for each iteration.
</p>
</li>
<li> <p><code>lv(x)</code>: leave-one-out-cross-validation. Pre-processing parameters are
determined for each iteration.
</p>
</li>
<li> <p><code>ip(x)</code>: imbalance partitioning for addressing class imbalances on the
data set. Pre-processing parameters are determined for each partition. The
number of partitions generated depends on the imbalance correction method
(see the <code>imbalance_correction_method</code> parameter). Imbalance partitioning
does not generate validation sets.
</p>
</li>
</ul>
<p>As shown in the example above, sampling algorithms can be nested.
</p>
<p>The simplest valid experimental design is <code>fs+mb</code>, which corresponds to a
TRIPOD type 1a analysis. Type 1b analyses are only possible using
bootstraps, e.g. <code>bt(fs+mb,100)</code>. Type 2a analyses can be conducted using
cross-validation, e.g. <code>cv(bt(fs,100)+mb,10,1)</code>. Depending on the origin of
the external validation data, designs such as <code>fs+mb+ev</code> or
<code>cv(bt(fs,100)+mb,10,1)+ev</code> constitute type 2b or type 3 analyses. Type 4
analyses can be done by obtaining one or more <code>familiarModel</code> objects from
others and applying them to your own data set.
</p>
<p>Alternatively, the <code>experimental_design</code> parameter may be used to provide a
path to a file containing iterations, which is named <code style="white-space: pre;">⁠####_iterations.RDS⁠</code>
by convention. This path can be relative to the directory of the current
experiment (<code>experiment_dir</code>), or an absolute path. The absolute path may
thus also point to a file from a different experiment.</p>
</dd>
<dt><code>imbalance_correction_method</code></dt>
<dd>
<p>(<em>optional</em>) Type of method used to
address class imbalances. Available options are:
</p>

<ul>
<li> <p><code>full_undersampling</code> (default): All data will be used in an ensemble
fashion. The full minority class will appear in each partition, but
majority classes are undersampled until all data have been used.
</p>
</li>
<li> <p><code>random_undersampling</code>: Randomly undersamples majority classes. This is
useful in cases where full undersampling would lead to the formation of
many models due major overrepresentation of the largest class.
</p>
</li>
</ul>
<p>This parameter is only used in combination with imbalance partitioning in
the experimental design, and <code>ip</code> should therefore appear in the string
that defines the design.</p>
</dd>
<dt><code>imbalance_n_partitions</code></dt>
<dd>
<p>(<em>optional</em>) Number of times random
undersampling should be repeated. 10 undersampled subsets with balanced
classes are formed by default.</p>
</dd>
<dt><code>parallel</code></dt>
<dd>
<p>(<em>optional</em>) Enable parallel processing. Defaults to <code>TRUE</code>.
When set to <code>FALSE</code>, this disables all parallel processing, regardless of
specific parameters such as <code>parallel_preprocessing</code>. However, when
<code>parallel</code> is <code>TRUE</code>, parallel processing of different parts of the
workflow can be disabled by setting respective flags to <code>FALSE</code>.</p>
</dd>
<dt><code>parallel_nr_cores</code></dt>
<dd>
<p>(<em>optional</em>) Number of cores available for
parallelisation. Defaults to 2. This setting does nothing if
parallelisation is disabled.</p>
</dd>
<dt><code>restart_cluster</code></dt>
<dd>
<p>(<em>optional</em>) Restart nodes used for parallel computing
to free up memory prior to starting a parallel process. Note that it does
take time to set up the clusters. Therefore setting this argument to <code>TRUE</code>
may impact processing speed. This argument is ignored if <code>parallel</code> is
<code>FALSE</code> or the cluster was initialised outside of familiar. Default is
<code>FALSE</code>, which causes the clusters to be initialised only once.</p>
</dd>
<dt><code>cluster_type</code></dt>
<dd>
<p>(<em>optional</em>) Selection of the cluster type for parallel
processing. Available types are the ones supported by the parallel package
that is part of the base R distribution: <code>psock</code> (default), <code>fork</code>, <code>mpi</code>,
<code>nws</code>, <code>sock</code>. In addition, <code>none</code> is available, which also disables
parallel processing.</p>
</dd>
<dt><code>backend_type</code></dt>
<dd>
<p>(<em>optional</em>) Selection of the backend for distributing
copies of the data. This backend ensures that only a single master copy is
kept in memory. This limits memory usage during parallel processing.
</p>
<p>Several backend options are available, notably <code>socket_server</code>, and <code>none</code>
(default). <code>socket_server</code> is based on the callr package and R sockets,
comes with <code>familiar</code> and is available for any OS. <code>none</code> uses the package
environment of familiar to store data, and is available for any OS.
However, <code>none</code> requires copying of data to any parallel process, and has a
larger memory footprint.</p>
</dd>
<dt><code>server_port</code></dt>
<dd>
<p>(<em>optional</em>) Integer indicating the port on which the
socket server or RServe process should communicate. Defaults to port 6311.
Note that ports 0 to 1024 and 49152 to 65535 cannot be used.</p>
</dd>
<dt><code>feature_max_fraction_missing</code></dt>
<dd>
<p>(<em>optional</em>) Numeric value between <code>0.0</code>
and <code>0.95</code> that determines the meximum fraction of missing values that
still allows a feature to be included in the data set. All features with a
missing value fraction over this threshold are not processed further. The
default value is <code>0.30</code>.</p>
</dd>
<dt><code>sample_max_fraction_missing</code></dt>
<dd>
<p>(<em>optional</em>) Numeric value between <code>0.0</code>
and <code>0.95</code> that determines the maximum fraction of missing values that
still allows a sample to be included in the data set. All samples with a
missing value fraction over this threshold are excluded and not processed
further. The default value is <code>0.30</code>.</p>
</dd>
<dt><code>filter_method</code></dt>
<dd>
<p>(<em>optional</em>) One or methods used to reduce
dimensionality of the data set by removing irrelevant or poorly
reproducible features.
</p>
<p>Several method are available:
</p>

<ul>
<li> <p><code>none</code> (default): None of the features will be filtered.
</p>
</li>
<li> <p><code>low_variance</code>: Features with a variance below the
<code>low_var_minimum_variance_threshold</code> are filtered. This can be useful to
filter, for example, genes that are not differentially expressed.
</p>
</li>
<li> <p><code>univariate_test</code>: Features undergo a univariate regression using an
outcome-appropriate regression model. The p-value of the model coefficient
is collected. Features with coefficient p or q-value above the
<code>univariate_test_threshold</code> are subsequently filtered.
</p>
</li>
<li> <p><code>robustness</code>: Features that are not sufficiently robust according to the
intraclass correlation coefficient are filtered. Use of this method
requires that repeated measurements are present in the data set, i.e. there
should be entries for which the sample and cohort identifiers are the same.
</p>
</li>
</ul>
<p>More than one method can be used simultaneously. Features with singular
values are always filtered, as these do not contain information.</p>
</dd>
<dt><code>univariate_test_threshold</code></dt>
<dd>
<p>(<em>optional</em>) Numeric value between <code>1.0</code> and
<code>0.0</code> that determines which features are irrelevant and will be filtered by
the <code>univariate_test</code>. The p or q-values are compared to this threshold.
All features with values above the threshold are filtered. The default
value is <code>0.20</code>.</p>
</dd>
<dt><code>univariate_test_threshold_metric</code></dt>
<dd>
<p>(<em>optional</em>) Metric used with the to
compare the <code>univariate_test_threshold</code> against. The following metrics can
be chosen:
</p>

<ul>
<li> <p><code>p_value</code> (default): The unadjusted p-value of each feature is used for
to filter features.
</p>
</li>
<li> <p><code>q_value</code>: The q-value (Story, 2002), is used to filter features. Some
data sets may have insufficient samples to compute the q-value. The
<code>qvalue</code> package must be installed from Bioconductor to use this method.
</p>
</li>
</ul>
</dd>
<dt><code>univariate_test_max_feature_set_size</code></dt>
<dd>
<p>(<em>optional</em>) Maximum size of the
feature set after the univariate test. P or q values of features are
compared against the threshold, but if the resulting data set would be
larger than this setting, only the most relevant features up to the desired
feature set size are selected.
</p>
<p>The default value is <code>NULL</code>, which causes features to be filtered based on
their relevance only.</p>
</dd>
<dt><code>low_var_minimum_variance_threshold</code></dt>
<dd>
<p>(required, if used) Numeric value
that determines which features will be filtered by the <code>low_variance</code>
method. The variance of each feature is computed and compared to the
threshold. If it is below the threshold, the feature is removed.
</p>
<p>This parameter has no default value and should be set if <code>low_variance</code> is
used.</p>
</dd>
<dt><code>low_var_max_feature_set_size</code></dt>
<dd>
<p>(<em>optional</em>) Maximum size of the feature
set after filtering features with a low variance. All features are first
compared against <code>low_var_minimum_variance_threshold</code>. If the resulting
feature set would be larger than specified, only the most strongly varying
features will be selected, up to the desired size of the feature set.
</p>
<p>The default value is <code>NULL</code>, which causes features to be filtered based on
their variance only.</p>
</dd>
<dt><code>robustness_icc_type</code></dt>
<dd>
<p>(<em>optional</em>) String indicating the type of
intraclass correlation coefficient (<code>1</code>, <code>2</code> or <code>3</code>) that should be used to
compute robustness for features in repeated measurements. These types
correspond to the types in Shrout and Fleiss (1979). The default value is
<code>1</code>.</p>
</dd>
<dt><code>robustness_threshold_metric</code></dt>
<dd>
<p>(<em>optional</em>) String indicating which
specific intraclass correlation coefficient (ICC) metric should be used to
filter features. This should be one of:
</p>

<ul>
<li> <p><code>icc</code>: The estimated ICC value itself.
</p>
</li>
<li> <p><code>icc_low</code> (default): The estimated lower limit of the 95% confidence
interval of the ICC, as suggested by Koo and Li (2016).
</p>
</li>
<li> <p><code>icc_panel</code>: The estimated ICC value over the panel average, i.e. the ICC
that would be obtained if all repeated measurements were averaged.
</p>
</li>
<li> <p><code>icc_panel_low</code>: The estimated lower limit of the 95% confidence interval
of the panel ICC.
</p>
</li>
</ul>
</dd>
<dt><code>robustness_threshold_value</code></dt>
<dd>
<p>(<em>optional</em>) The intraclass correlation
coefficient value that is as threshold. The default value is <code>0.70</code>.</p>
</dd>
<dt><code>transformation_method</code></dt>
<dd>
<p>(<em>optional</em>) The transformation method used to
change the distribution of the data to be more normal-like. The following
methods are available:
</p>

<ul>
<li> <p><code>none</code>: This disables transformation of features.
</p>
</li>
<li> <p><code>yeo_johnson</code>: Transformation using the location and scale invariant
version of the Yeo-Johnson transformation (Yeo and Johnson, 2000;
Zwanenburg and Löck, 2023).
</p>
</li>
<li> <p><code>yeo_johnson_robust</code> (default): A robust version of <code>yeo_johnson</code>.
This method is less sensitive to outliers.
</p>
</li>
<li> <p><code>yeo_johnson_conventional</code>: As <code>yeo_johnson</code>, but without optimisation of
location and scale parameters. This method is equivalent to the original
transformation proposed by Yeo and Johnson (2001).
</p>
</li>
<li> <p><code>box_cox</code>: Transformation using the location and scale invariant version
of the Box-Cox transformation (Box and Cox, 1964; Zwanenburg and Löck,
2023).
</p>
</li>
<li> <p><code>box_cox_robust</code>: A robust version of <code>yeo_johnson</code>. This method is less
sensitive to outliers.
</p>
</li>
<li> <p><code>box_cox_conventional</code>: As <code>box_cox</code>, but without optimisation of
location and scale parameters. This method is equivalent to the original
transformation proposed by Box and Cox (1964). This method requires
strictly positive feature values.
</p>
</li>
</ul>
<p>Transformation requires the <code>power.transform</code> package. Only features that
contain numerical data are transformed. Transformation parameters obtained
in development data are stored within <code>featureInfo</code> objects for later use
with validation data sets.</p>
</dd>
<dt><code>transformation_optimisation_criterion</code></dt>
<dd>
<p>(<em>optional</em>) Transformation
parameters are optimised using a criterion, conventionally
maximum-likelihood-estimation. <code>power.transform</code> implements multiple
optimisation criteria, of which the following are available:
</p>

<ul>
<li> <p><code>mle</code> (default): Optimisation using maximum likelihood estimation.
</p>
</li>
<li> <p><code>cramer_von_mises</code>: Optimisation using the Cramér-von Mises
criterion. Zwanenburg and Löck (2023) found that this criterion was
relatively robust against outliers.
</p>
</li>
</ul>
</dd>
<dt><code>transformation_gof_test_p_value</code></dt>
<dd>
<p>(<em>optional</em>) Not all transformations
will lead to features that are roughly normally distributed. Zwanenburg and
Löck (2023) established a empirical goodness-of-fit test for central
normality. This parameter sets the significance for rejecting the
null-hypothesis that a feature distribution is centrally normal. When the
null-hypothesis is rejected, no transformation is performed. The default
value is <code>NULL</code>, which disables the test.</p>
</dd>
<dt><code>normalisation_method</code></dt>
<dd>
<p>(<em>optional</em>) The normalisation method used to
improve the comparability between numerical features that may have very
different scales. The following normalisation methods can be chosen:
</p>

<ul>
<li> <p><code>none</code>: This disables feature normalisation.
</p>
</li>
<li> <p><code>standardisation</code>: Features are normalised by subtraction of their mean
values and division by their standard deviations. This causes every feature
to be have a center value of 0.0 and standard deviation of 1.0.
</p>
</li>
<li> <p><code>standardisation_trim</code>: As <code>standardisation</code>, but based on the set of
feature values where the 5% lowest and 5% highest values are discarded.
This reduces the effect of outliers.
</p>
</li>
<li> <p><code>standardisation_winsor</code>: As <code>standardisation</code>, but based on the set of
feature values where the 5% lowest and 5% highest values are winsorised.
This reduces the effect of outliers.
</p>
</li>
<li> <p><code>standardisation_robust</code> (default): A robust version of <code>standardisation</code>
that relies on computing Huber's M-estimators for location and scale.
</p>
</li>
<li> <p><code>normalisation</code>: Features are normalised by subtraction of their minimum
values and division by their ranges. This maps all feature values to a
<code class="reqn">[0, 1]</code> interval.
</p>
</li>
<li> <p><code>normalisation_trim</code>: As <code>normalisation</code>, but based on the set of feature
values where the 5% lowest and 5% highest values are discarded. This
reduces the effect of outliers.
</p>
</li>
<li> <p><code>normalisation_winsor</code>: As <code>normalisation</code>, but based on the set of
feature values where the 5% lowest and 5% highest values are winsorised.
This reduces the effect of outliers.
</p>
</li>
<li> <p><code>quantile</code>: Features are normalised by subtraction of their median values
and division by their interquartile range.
</p>
</li>
<li> <p><code>mean_centering</code>: Features are centered by substracting the mean, but do
not undergo rescaling.
</p>
</li>
</ul>
<p>Only features that contain numerical data are normalised. Normalisation
parameters obtained in development data are stored within <code>featureInfo</code>
objects for later use with validation data sets.</p>
</dd>
<dt><code>batch_normalisation_method</code></dt>
<dd>
<p>(<em>optional</em>) The method used for batch
normalisation. Available methods are:
</p>

<ul>
<li> <p><code>none</code> (default): This disables batch normalisation of features.
</p>
</li>
<li> <p><code>standardisation</code>: Features within each batch are normalised by
subtraction of the mean value and division by the standard deviation in
each batch.
</p>
</li>
<li> <p><code>standardisation_trim</code>: As <code>standardisation</code>, but based on the set of
feature values where the 5% lowest and 5% highest values are discarded.
This reduces the effect of outliers.
</p>
</li>
<li> <p><code>standardisation_winsor</code>: As <code>standardisation</code>, but based on the set of
feature values where the 5% lowest and 5% highest values are winsorised.
This reduces the effect of outliers.
</p>
</li>
<li> <p><code>standardisation_robust</code>: A robust version of <code>standardisation</code> that
relies on computing Huber's M-estimators for location and scale within each
batch.
</p>
</li>
<li> <p><code>normalisation</code>: Features within each batch are normalised by subtraction
of their minimum values and division by their range in each batch. This
maps all feature values in each batch to a <code class="reqn">[0, 1]</code> interval.
</p>
</li>
<li> <p><code>normalisation_trim</code>: As <code>normalisation</code>, but based on the set of feature
values where the 5% lowest and 5% highest values are discarded. This
reduces the effect of outliers.
</p>
</li>
<li> <p><code>normalisation_winsor</code>: As <code>normalisation</code>, but based on the set of
feature values where the 5% lowest and 5% highest values are winsorised.
This reduces the effect of outliers.
</p>
</li>
<li> <p><code>quantile</code>: Features in each batch are normalised by subtraction of the
median value and division by the interquartile range of each batch.
</p>
</li>
<li> <p><code>mean_centering</code>: Features in each batch are centered on 0.0 by
substracting the mean value in each batch, but are not rescaled.
</p>
</li>
<li> <p><code>combat_parametric</code>: Batch adjustments using parametric empirical Bayes
(Johnson et al, 2007). <code>combat_p</code> leads to the same method.
</p>
</li>
<li> <p><code>combat_non_parametric</code>: Batch adjustments using non-parametric empirical
Bayes (Johnson et al, 2007). <code>combat_np</code> and <code>combat</code> lead to the same
method. Note that we reduced complexity from O(<code class="reqn">n^2</code>) to O(<code class="reqn">n</code>) by
only computing batch adjustment parameters for each feature on a subset of
50 randomly selected features, instead of all features.
</p>
</li>
</ul>
<p>Only features that contain numerical data are normalised using batch
normalisation. Batch normalisation parameters obtained in development data
are stored within <code>featureInfo</code> objects for later use with validation data
sets, in case the validation data is from the same batch.
</p>
<p>If validation data contains data from unknown batches, normalisation
parameters are separately determined for these batches.
</p>
<p>Note that for both empirical Bayes methods, the batch effect is assumed to
produce results across the features. This is often true for things such as
gene expressions, but the assumption may not hold generally.
</p>
<p>When performing batch normalisation, it is moreover important to check that
differences between batches or cohorts are not related to the studied
endpoint.</p>
</dd>
<dt><code>imputation_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used for imputing missing
feature values. Two methods are implemented:
</p>

<ul>
<li> <p><code>simple</code>: Simple replacement of a missing value by the median value (for
numeric features) or the modal value (for categorical features).
</p>
</li>
<li> <p><code>lasso</code>: Imputation of missing value by lasso regression (using <code>glmnet</code>)
based on information contained in other features.
</p>
</li>
</ul>
<p><code>simple</code> imputation precedes <code>lasso</code> imputation to ensure that any missing
values in predictors required for <code>lasso</code> regression are resolved. The
<code>lasso</code> estimate is then used to replace the missing value.
</p>
<p>The default value depends on the number of features in the dataset. If the
number is lower than 100, <code>lasso</code> is used by default, and <code>simple</code>
otherwise.
</p>
<p>Only single imputation is performed. Imputation models and parameters are
stored within <code>featureInfo</code> objects for later use with validation data
sets.</p>
</dd>
<dt><code>cluster_method</code></dt>
<dd>
<p>(<em>optional</em>) Clustering is performed to identify and
replace redundant features, for example those that are highly correlated.
Such features do not carry much additional information and may be removed
or replaced instead (Park et al., 2007; Tolosi and Lengauer, 2011).
</p>
<p>The cluster method determines the algorithm used to form the clusters. The
following cluster methods are implemented:
</p>

<ul>
<li> <p><code>none</code>: No clustering is performed.
</p>
</li>
<li> <p><code>hclust</code> (default): Hierarchical agglomerative clustering. If the
<code>fastcluster</code> package is installed, <code>fastcluster::hclust</code> is used (Muellner
2013), otherwise <code>stats::hclust</code> is used.
</p>
</li>
<li> <p><code>agnes</code>: Hierarchical clustering using agglomerative nesting (Kaufman and
Rousseeuw, 1990). This algorithm is similar to <code>hclust</code>, but uses the
<code>cluster::agnes</code> implementation.
</p>
</li>
<li> <p><code>diana</code>: Divisive analysis hierarchical clustering. This method uses
divisive instead of agglomerative clustering (Kaufman and Rousseeuw, 1990).
<code>cluster::diana</code> is used.
</p>
</li>
<li> <p><code>pam</code>: Partioning around medioids. This partitions the data into $k$
clusters around medioids (Kaufman and Rousseeuw, 1990). $k$ is selected
using the <code>silhouette</code> metric. <code>pam</code> is implemented using the
<code>cluster::pam</code> function.
</p>
</li>
</ul>
<p>Clusters and cluster information is stored within <code>featureInfo</code> objects for
later use with validation data sets. This enables reproduction of the same
clusters as formed in the development data set.</p>
</dd>
<dt><code>cluster_linkage_method</code></dt>
<dd>
<p>(<em>optional</em>) Linkage method used for
agglomerative clustering in <code>hclust</code> and <code>agnes</code>. The following linkage
methods can be used:
</p>

<ul>
<li> <p><code>average</code> (default): Average linkage.
</p>
</li>
<li> <p><code>single</code>: Single linkage.
</p>
</li>
<li> <p><code>complete</code>: Complete linkage.
</p>
</li>
<li> <p><code>weighted</code>: Weighted linkage, also known as McQuitty linkage.
</p>
</li>
<li> <p><code>ward</code>: Linkage using Ward's minimum variance method.
</p>
</li>
</ul>
<p><code>diana</code> and <code>pam</code> do not require a linkage method.</p>
</dd>
<dt><code>cluster_cut_method</code></dt>
<dd>
<p>(<em>optional</em>) The method used to define the actual
clusters. The following methods can be used:
</p>

<ul>
<li> <p><code>silhouette</code>: Clusters are formed based on the silhouette score
(Rousseeuw, 1987). The average silhouette score is computed from 2 to
<code class="reqn">n</code> clusters, with <code class="reqn">n</code> the number of features. Clusters are only
formed if the average silhouette exceeds 0.50, which indicates reasonable
evidence for structure. This procedure may be slow if the number of
features is large (&gt;100s).
</p>
</li>
<li> <p><code>fixed_cut</code>: Clusters are formed by cutting the hierarchical tree at the
point indicated by the <code>cluster_similarity_threshold</code>, e.g. where features
in a cluster have an average Spearman correlation of 0.90. <code>fixed_cut</code> is
only available for <code>agnes</code>, <code>diana</code> and <code>hclust</code>.
</p>
</li>
<li> <p><code>dynamic_cut</code>: Dynamic cluster formation using the cutting algorithm in
the <code>dynamicTreeCut</code> package. This package should be installed to select
this option. <code>dynamic_cut</code> can only be used with <code>agnes</code> and <code>hclust</code>.
</p>
</li>
</ul>
<p>The default options are <code>silhouette</code> for partioning around medioids (<code>pam</code>)
and <code>fixed_cut</code> otherwise.</p>
</dd>
<dt><code>cluster_similarity_metric</code></dt>
<dd>
<p>(<em>optional</em>) Clusters are formed based on
feature similarity. All features are compared in a pair-wise fashion to
compute similarity, for example correlation. The resulting similarity grid
is converted into a distance matrix that is subsequently used for
clustering. The following metrics are supported to compute pairwise
similarities:
</p>

<ul>
<li> <p><code>mutual_information</code> (default): normalised mutual information.
</p>
</li>
<li> <p><code>mcfadden_r2</code>: McFadden's pseudo R-squared (McFadden, 1974).
</p>
</li>
<li> <p><code>cox_snell_r2</code>: Cox and Snell's pseudo R-squared (Cox and Snell, 1989).
</p>
</li>
<li> <p><code>nagelkerke_r2</code>: Nagelkerke's pseudo R-squared (Nagelkerke, 1991).
</p>
</li>
<li> <p><code>spearman</code>: Spearman's rank order correlation.
</p>
</li>
<li> <p><code>kendall</code>: Kendall rank correlation.
</p>
</li>
<li> <p><code>pearson</code>: Pearson product-moment correlation.
</p>
</li>
</ul>
<p>The pseudo R-squared metrics can be used to assess similarity between mixed
pairs of numeric and categorical features, as these are based on the
log-likelihood of regression models. In <code>familiar</code>, the more informative
feature is used as the predictor and the other feature as the reponse
variable. In numeric-categorical pairs, the numeric feature is considered
to be more informative and is thus used as the predictor. In
categorical-categorical pairs, the feature with most levels is used as the
predictor.
</p>
<p>In case any of the classical correlation coefficients (<code>pearson</code>,
<code>spearman</code> and <code>kendall</code>) are used with (mixed) categorical features, the
categorical features are one-hot encoded and the mean correlation over all
resulting pairs is used as similarity.</p>
</dd>
<dt><code>cluster_similarity_threshold</code></dt>
<dd>
<p>(<em>optional</em>) The threshold level for
pair-wise similarity that is required to form clusters using <code>fixed_cut</code>.
This should be a numerical value between 0.0 and 1.0. Note however, that a
reasonable threshold value depends strongly on the similarity metric. The
following are the default values used:
</p>

<ul>
<li> <p><code>mcfadden_r2</code> and <code>mutual_information</code>: <code>0.30</code>
</p>
</li>
<li> <p><code>cox_snell_r2</code> and <code>nagelkerke_r2</code>: <code>0.75</code>
</p>
</li>
<li> <p><code>spearman</code>, <code>kendall</code> and <code>pearson</code>: <code>0.90</code>
</p>
</li>
</ul>
<p>Alternatively, if the <code style="white-space: pre;">⁠fixed cut⁠</code> method is not used, this value determines
whether any clustering should be performed, because the data may not
contain highly similar features. The default values in this situation are:
</p>

<ul>
<li> <p><code>mcfadden_r2</code>  and <code>mutual_information</code>: <code>0.25</code>
</p>
</li>
<li> <p><code>cox_snell_r2</code> and <code>nagelkerke_r2</code>: <code>0.40</code>
</p>
</li>
<li> <p><code>spearman</code>, <code>kendall</code> and <code>pearson</code>: <code>0.70</code>
</p>
</li>
</ul>
<p>The threshold value is converted to a distance (1-similarity) prior to
cutting hierarchical trees.</p>
</dd>
<dt><code>cluster_representation_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used to determine
how the information of co-clustered features is summarised and used to
represent the cluster. The following methods can be selected:
</p>

<ul>
<li> <p><code>best_predictor</code> (default): The feature with the highest importance
according to univariate regression with the outcome is used to represent
the cluster.
</p>
</li>
<li> <p><code>medioid</code>: The feature closest to the cluster center, i.e. the feature
that is most similar to the remaining features in the cluster, is used to
represent the feature.
</p>
</li>
<li> <p><code>mean</code>: A meta-feature is generated by averaging the feature values for
all features in a cluster. This method aligns all features so that all
features will be positively correlated prior to averaging. Should a cluster
contain one or more categorical features, the <code>medioid</code> method will be used
instead, as averaging is not possible. Note that if this method is chosen,
the <code>normalisation_method</code> parameter should be one of <code>standardisation</code>,
<code>standardisation_trim</code>, <code>standardisation_winsor</code> or <code>quantile</code>.'
</p>
</li>
</ul>
<p>If the <code>pam</code> cluster method is selected, only the <code>medioid</code> method can be
used. In that case 1 medioid is used by default.</p>
</dd>
<dt><code>parallel_preprocessing</code></dt>
<dd>
<p>(<em>optional</em>) Enable parallel processing for the
preprocessing workflow. Defaults to <code>TRUE</code>. When set to <code>FALSE</code>, this will
disable the use of parallel processing while preprocessing, regardless of
the settings of the <code>parallel</code> parameter. <code>parallel_preprocessing</code> is
ignored if <code>parallel=FALSE</code>.</p>
</dd>
<dt><code>fs_method</code></dt>
<dd>
<p>(<strong>required</strong>) Feature selection method to be used for
determining variable importance. <code>familiar</code> implements various feature
selection methods. Please refer to the vignette on feature selection
methods for more details.
</p>
<p>More than one feature selection method can be chosen. The experiment will
then repeated for each feature selection method.
</p>
<p>Feature selection methods determines the ranking of features. Actual
selection of features is done by optimising the signature size model
hyperparameter during the hyperparameter optimisation step.</p>
</dd>
<dt><code>fs_method_parameter</code></dt>
<dd>
<p>(<em>optional</em>) List of lists containing parameters
for feature selection methods. Each sublist should have the name of the
feature selection method it corresponds to.
</p>
<p>Most feature selection methods do not have parameters that can be set.
Please refer to the vignette on feature selection methods for more details.
Note that if the feature selection method is based on a learner (e.g. lasso
regression), hyperparameter optimisation may be performed prior to
assessing variable importance.</p>
</dd>
<dt><code>vimp_aggregation_method</code></dt>
<dd>
<p>(<em>optional</em>) The method used to aggregate
variable importances over different data subsets, e.g. bootstraps. The
following methods can be selected:
</p>

<ul>
<li> <p><code>none</code>: Don't aggregate ranks, but rather aggregate the variable
importance scores themselves.
</p>
</li>
<li> <p><code>mean</code>: Use the mean rank of a feature over the subsets to
determine the aggregated feature rank.
</p>
</li>
<li> <p><code>median</code>: Use the median rank of a feature over the subsets to determine
the aggregated feature rank.
</p>
</li>
<li> <p><code>best</code>: Use the best rank the feature obtained in any subset to determine
the aggregated feature rank.
</p>
</li>
<li> <p><code>worst</code>: Use the worst rank the feature obtained in any subset to
determine the aggregated feature rank.
</p>
</li>
<li> <p><code>stability</code>: Use the frequency of the feature being in the subset of
highly ranked features as measure for the aggregated feature rank
(Meinshausen and Buehlmann, 2010).
</p>
</li>
<li> <p><code>exponential</code>: Use a rank-weighted frequence of occurrence in the subset
of highly ranked features as measure for the aggregated feature rank (Haury
et al., 2011).
</p>
</li>
<li> <p><code>borda</code> (default): Use the borda count as measure for the aggregated
feature rank (Wald et al., 2012).
</p>
</li>
<li> <p><code>enhanced_borda</code>: Use an occurrence frequency-weighted borda count as
measure for the aggregated feature rank (Wald et al., 2012).
</p>
</li>
<li> <p><code>truncated_borda</code>: Use borda count computed only on features within the
subset of highly ranked features.
</p>
</li>
<li> <p><code>enhanced_truncated_borda</code>: Apply both the enhanced borda method and the
truncated borda method and use the resulting borda count as the aggregated
feature rank.
</p>
</li>
</ul>
<p>The <em>feature selection methods</em> vignette provides additional information.</p>
</dd>
<dt><code>vimp_aggregation_rank_threshold</code></dt>
<dd>
<p>(<em>optional</em>) The threshold used to
define the subset of highly important features. If not set, this threshold
is determined by maximising the variance in the occurrence value over all
features over the subset size.
</p>
<p>This parameter is only relevant for <code>stability</code>, <code>exponential</code>,
<code>enhanced_borda</code>, <code>truncated_borda</code> and <code>enhanced_truncated_borda</code> methods.</p>
</dd>
<dt><code>parallel_feature_selection</code></dt>
<dd>
<p>(<em>optional</em>) Enable parallel processing for
the feature selection workflow. Defaults to <code>TRUE</code>. When set to <code>FALSE</code>,
this will disable the use of parallel processing while performing feature
selection, regardless of the settings of the <code>parallel</code> parameter.
<code>parallel_feature_selection</code> is ignored if <code>parallel=FALSE</code>.</p>
</dd>
<dt><code>learner</code></dt>
<dd>
<p>(<strong>required</strong>) One or more algorithms used for model
development. A sizeable number learners is supported in <code>familiar</code>. Please
see the vignette on learners for more information concerning the available
learners.</p>
</dd>
<dt><code>hyperparameter</code></dt>
<dd>
<p>(<em>optional</em>) List of lists containing hyperparameters
for learners. Each sublist should have the name of the learner method it
corresponds to, with list elements being named after the intended
hyperparameter, e.g. <code>"glm_logistic"=list("sign_size"=3)</code>
</p>
<p>All learners have hyperparameters. Please refer to the vignette on learners
for more details. If no parameters are provided, sequential model-based
optimisation is used to determine optimal hyperparameters.
</p>
<p>Hyperparameters provided by the user are never optimised. However, if more
than one value is provided for a single hyperparameter, optimisation will
be conducted using these values.</p>
</dd>
<dt><code>novelty_detector</code></dt>
<dd>
<p>(<em>optional</em>) Specify the algorithm used for training
a novelty detector. This detector can be used to identify
out-of-distribution data prospectively.</p>
</dd>
<dt><code>detector_parameters</code></dt>
<dd>
<p>(<em>optional</em>) List lists containing hyperparameters
for novelty detectors. Currently not used.</p>
</dd>
<dt><code>parallel_model_development</code></dt>
<dd>
<p>(<em>optional</em>) Enable parallel processing for
the model development workflow. Defaults to <code>TRUE</code>. When set to <code>FALSE</code>,
this will disable the use of parallel processing while developing models,
regardless of the settings of the <code>parallel</code> parameter.
<code>parallel_model_development</code> is ignored if <code>parallel=FALSE</code>.</p>
</dd>
<dt><code>optimisation_bootstraps</code></dt>
<dd>
<p>(<em>optional</em>) Number of bootstraps that should
be generated from the development data set. During the optimisation
procedure one or more of these bootstraps (indicated by
<code>smbo_step_bootstraps</code>) are used for model development using different
combinations of hyperparameters. The effect of the hyperparameters is then
assessed by comparing in-bag and out-of-bag model performance.
</p>
<p>The default number of bootstraps is <code>50</code>. Hyperparameter optimisation may
finish before exhausting the set of bootstraps.</p>
</dd>
<dt><code>optimisation_determine_vimp</code></dt>
<dd>
<p>(<em>optional</em>) Logical value that indicates
whether variable importance is determined separately for each of the
bootstraps created during the optimisation process (<code>TRUE</code>) or the
applicable results from the feature selection step are used (<code>FALSE</code>).
</p>
<p>Determining variable importance increases the initial computational
overhead. However, it prevents positive biases for the out-of-bag data due
to overlap of these data with the development data set used for the feature
selection step. In this case, any hyperparameters of the variable
importance method are not determined separately for each bootstrap, but
those obtained during the feature selection step are used instead. In case
multiple of such hyperparameter sets could be applicable, the set that will
be used is randomly selected for each bootstrap.
</p>
<p>This parameter only affects hyperparameter optimisation of learners. The
default is <code>TRUE</code>.</p>
</dd>
<dt><code>smbo_random_initialisation</code></dt>
<dd>
<p>(<em>optional</em>) String indicating the
initialisation method for the hyperparameter space. Can be one of
<code>fixed_subsample</code> (default), <code>fixed</code>, or <code>random</code>. <code>fixed</code> and
<code>fixed_subsample</code> first create hyperparameter sets from a range of default
values set by familiar. <code>fixed_subsample</code> then randomly draws up to
<code>smbo_n_random_sets</code> from the grid. <code>random</code> does not rely upon a fixed
grid, and randomly draws up to <code>smbo_n_random_sets</code> hyperparameter sets
from the hyperparameter space.</p>
</dd>
<dt><code>smbo_n_random_sets</code></dt>
<dd>
<p>(<em>optional</em>) Number of random or subsampled
hyperparameters drawn during the initialisation process. Default: <code>100</code>.
Cannot be smaller than <code>10</code>. The parameter is not used when
<code>smbo_random_initialisation</code> is <code>fixed</code>, as the entire pre-defined grid
will be explored.</p>
</dd>
<dt><code>max_smbo_iterations</code></dt>
<dd>
<p>(<em>optional</em>) Maximum number of intensify
iterations of the SMBO algorithm. During an intensify iteration a run-off
occurs between the current <em>best</em> hyperparameter combination and either 10
challenger combination with the highest expected improvement or a set of 20
random combinations.
</p>
<p>Run-off with random combinations is used to force exploration of the
hyperparameter space, and is performed every second intensify iteration, or
if there is no expected improvement for any challenger combination.
</p>
<p>If a combination of hyperparameters leads to better performance on the same
data than the incumbent <em>best</em> set of hyperparameters, it replaces the
incumbent set at the end of the intensify iteration.
</p>
<p>The default number of intensify iteration is <code>20</code>. Iterations may be
stopped early if the incumbent set of hyperparameters remains the same for
<code>smbo_stop_convergent_iterations</code> iterations, or performance improvement is
minimal. This behaviour is suppressed during the first 4 iterations to
enable the algorithm to explore the hyperparameter space.</p>
</dd>
<dt><code>smbo_stop_convergent_iterations</code></dt>
<dd>
<p>(<em>optional</em>) The number of subsequent
convergent SMBO iterations required to stop hyperparameter optimisation
early. An iteration is convergent if the <em>best</em> parameter set has not
changed or the optimisation score over the 4 most recent iterations has not
changed beyond the tolerance level in <code>smbo_stop_tolerance</code>.
</p>
<p>The default value is <code>3</code>.</p>
</dd>
<dt><code>smbo_stop_tolerance</code></dt>
<dd>
<p>(<em>optional</em>) Tolerance for early stopping due to
convergent optimisation score.
</p>
<p>The default value depends on the square root of the number of samples (at
the series level), and is <code>0.01</code> for 100 samples. This value is computed as
<code>0.1 * 1 / sqrt(n_samples)</code>. The upper limit is <code>0.0001</code> for 1M or more
samples.</p>
</dd>
<dt><code>smbo_time_limit</code></dt>
<dd>
<p>(<em>optional</em>) Time limit (in minutes) for the
optimisation process. Optimisation is stopped after this limit is exceeded.
Time taken to determine variable importance for the optimisation process
(see the <code>optimisation_determine_vimp</code> parameter) does not count.
</p>
<p>The default is <code>NULL</code>, indicating that there is no time limit for the
optimisation process. The time limit cannot be less than 1 minute.</p>
</dd>
<dt><code>smbo_initial_bootstraps</code></dt>
<dd>
<p>(<em>optional</em>) The number of bootstraps taken
from the set of <code>optimisation_bootstraps</code> as the bootstraps assessed
initially.
</p>
<p>The default value is <code>1</code>. The value cannot be larger than
<code>optimisation_bootstraps</code>.</p>
</dd>
<dt><code>smbo_step_bootstraps</code></dt>
<dd>
<p>(<em>optional</em>) The number of bootstraps taken from
the set of <code>optimisation_bootstraps</code> bootstraps as the bootstraps assessed
during the steps of each intensify iteration.
</p>
<p>The default value is <code>3</code>. The value cannot be larger than
<code>optimisation_bootstraps</code>.</p>
</dd>
<dt><code>smbo_intensify_steps</code></dt>
<dd>
<p>(<em>optional</em>) The number of steps in each SMBO
intensify iteration. Each step a new set of <code>smbo_step_bootstraps</code>
bootstraps is drawn and used in the run-off between the incumbent <em>best</em>
hyperparameter combination and its challengers.
</p>
<p>The default value is <code>5</code>. Higher numbers allow for a more detailed
comparison, but this comes with added computational cost.</p>
</dd>
<dt><code>optimisation_metric</code></dt>
<dd>
<p>(<em>optional</em>) One or more metrics used to compute
performance scores. See the vignette on performance metrics for the
available metrics.
</p>
<p>If unset, the following metrics are used by default:
</p>

<ul>
<li> <p><code>auc_roc</code>: For <code>binomial</code> and <code>multinomial</code> models.
</p>
</li>
<li> <p><code>mse</code>: Mean squared error for <code>continuous</code> models.
</p>
</li>
<li> <p><code>msle</code>: Mean squared logarithmic error for <code>count</code> models.
</p>
</li>
<li> <p><code>concordance_index</code>: For <code>survival</code> models.
</p>
</li>
</ul>
<p>Multiple optimisation metrics can be specified. Actual metric values are
converted to an objective value by comparison with a baseline metric value
that derives from a trivial model, i.e. majority class for binomial and
multinomial outcomes, the median outcome for count and continuous outcomes
and a fixed risk or time for survival outcomes.</p>
</dd>
<dt><code>optimisation_function</code></dt>
<dd>
<p>(<em>optional</em>) Type of optimisation function used
to quantify the performance of a hyperparameter set. Model performance is
assessed using the metric(s) specified by <code>optimisation_metric</code> on the
in-bag (IB) and out-of-bag (OOB) samples of a bootstrap. These values are
converted to objective scores with a standardised interval of
<code class="reqn">[-1.0, 1.0]</code>. Each pair of objective is subsequently used to compute an
optimisation score. The optimisation score across different bootstraps is
than aggregated to a summary score. This summary score is used to rank
hyperparameter sets, and select the optimal set.
</p>
<p>The combination of optimisation score and summary score is determined by
the optimisation function indicated by this parameter:
</p>

<ul>
<li> <p><code>validation</code> or <code>max_validation</code> (default): seeks to maximise OOB score.
</p>
</li>
<li> <p><code>balanced</code>: seeks to balance IB and OOB score.
</p>
</li>
<li> <p><code>stronger_balance</code>: similar to <code>balanced</code>, but with stronger penalty for
differences between IB and OOB scores.
</p>
</li>
<li> <p><code>validation_minus_sd</code>: seeks to optimise the average OOB score minus its
standard deviation.
</p>
</li>
<li> <p><code>validation_25th_percentile</code>: seeks to optimise the 25th percentile of
OOB scores, and is conceptually similar to <code>validation_minus_sd</code>.
</p>
</li>
<li> <p><code>model_estimate</code>: seeks to maximise the OOB score estimate predicted by
the hyperparameter learner (not available for random search).
</p>
</li>
<li> <p><code>model_estimate_minus_sd</code>: seeks to maximise the OOB score estimate minus
its estimated standard deviation, as predicted by the hyperparameter
learner (not available for random search).
</p>
</li>
<li> <p><code>model_balanced_estimate</code>: seeks to maximise the estimate of the balanced
IB and OOB score. This is similar to the <code>balanced</code> score, and in fact uses
a hyperparameter learner to predict said score (not available for random
search).
</p>
</li>
<li> <p><code>model_balanced_estimate_minus_sd</code>: seeks to maximise the estimate of the
balanced IB and OOB score, minus its estimated standard deviation. This is
similar to the <code>balanced</code> score, but takes into account its estimated
spread.
</p>
</li>
</ul>
<p>Additional detail are provided in the <em>Learning algorithms and
hyperparameter optimisation</em> vignette.</p>
</dd>
<dt><code>hyperparameter_learner</code></dt>
<dd>
<p>(<em>optional</em>) Any point in the hyperparameter
space has a single, scalar, optimisation score value that is <em>a priori</em>
unknown. During the optimisation process, the algorithm samples from the
hyperparameter space by selecting hyperparameter sets and computing the
optimisation score value for one or more bootstraps. For each
hyperparameter set the resulting values are distributed around the actual
value. The learner indicated by <code>hyperparameter_learner</code> is then used to
infer optimisation score estimates for unsampled parts of the
hyperparameter space.
</p>
<p>The following models are available:
</p>

<ul>
<li> <p><code>bayesian_additive_regression_trees</code> or <code>bart</code>: Uses Bayesian Additive
Regression Trees (Sparapani et al., 2021) for inference. Unlike standard
random forests, BART allows for estimating posterior distributions directly
and can extrapolate.
</p>
</li>
<li> <p><code>gaussian_process</code> (default): Creates a localised approximate Gaussian
process for inference (Gramacy, 2016). This allows for better scaling than
deterministic Gaussian Processes.
</p>
</li>
<li> <p><code>random_forest</code>: Creates a random forest for inference. Originally
suggested by Hutter et al. (2011). A weakness of random forests is their
lack of extrapolation beyond observed values, which limits their usefulness
in exploiting promising areas of hyperparameter space.
</p>
</li>
<li> <p><code>random</code> or <code>random_search</code>: Forgoes the use of models to steer
optimisation. Instead, a random search is performed.
</p>
</li>
</ul>
</dd>
<dt><code>acquisition_function</code></dt>
<dd>
<p>(<em>optional</em>) The acquisition function influences
how new hyperparameter sets are selected. The algorithm uses the model
learned by the learner indicated by <code>hyperparameter_learner</code> to search the
hyperparameter space for hyperparameter sets that are either likely better
than the best known set (<em>exploitation</em>) or where there is considerable
uncertainty (<em>exploration</em>). The acquisition function quantifies this
(Shahriari et al., 2016).
</p>
<p>The following acquisition functions are available, and are described in
more detail in the <em>learner algorithms</em> vignette:
</p>

<ul>
<li> <p><code>improvement_probability</code>: The probability of improvement quantifies the
probability that the expected optimisation score for a set is better than
the best observed optimisation score
</p>
</li>
<li> <p><code>improvement_empirical_probability</code>: Similar to
<code>improvement_probability</code>, but based directly on optimisation scores
predicted by the individual decision trees.
</p>
</li>
<li> <p><code>expected_improvement</code> (default): Computes expected improvement.
</p>
</li>
<li> <p><code>upper_confidence_bound</code>: This acquisition function is based on the upper
confidence bound of the distribution (Srinivas et al., 2012).
</p>
</li>
<li> <p><code>bayes_upper_confidence_bound</code>: This acquisition function is based on the
upper confidence bound of the distribution (Kaufmann et al., 2012).
</p>
</li>
</ul>
</dd>
<dt><code>exploration_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used to steer exploration in
post-initialisation intensive searching steps. As stated earlier, each SMBO
iteration step compares suggested alternative parameter sets with an
incumbent <strong>best</strong> set in a series of steps. The exploration method
controls how the set of alternative parameter sets is pruned after each
step in an iteration. Can be one of the following:
</p>

<ul>
<li> <p><code>single_shot</code> (default): The set of alternative parameter sets is not
pruned, and each intensification iteration contains only a single
intensification step that only uses a single bootstrap. This is the fastest
exploration method, but only superficially tests each parameter set.
</p>
</li>
<li> <p><code>successive_halving</code>: The set of alternative parameter sets is
pruned by removing the worst performing half of the sets after each step
(Jamieson and Talwalkar, 2016).
</p>
</li>
<li> <p><code>stochastic_reject</code>: The set of alternative parameter sets is pruned by
comparing the performance of each parameter set with that of the incumbent
<strong>best</strong> parameter set using a paired Wilcoxon test based on shared
bootstraps. Parameter sets that perform significantly worse, at an alpha
level indicated by <code>smbo_stochastic_reject_p_value</code>, are pruned.
</p>
</li>
<li> <p><code>none</code>: The set of alternative parameter sets is not pruned.
</p>
</li>
</ul>
</dd>
<dt><code>smbo_stochastic_reject_p_value</code></dt>
<dd>
<p>(<em>optional</em>) The p-value threshold used
for the <code>stochastic_reject</code> exploration method.
</p>
<p>The default value is <code>0.05</code>.</p>
</dd>
<dt><code>parallel_hyperparameter_optimisation</code></dt>
<dd>
<p>(<em>optional</em>) Enable parallel
processing for hyperparameter optimisation. Defaults to <code>TRUE</code>. When set to
<code>FALSE</code>, this will disable the use of parallel processing while performing
optimisation, regardless of the settings of the <code>parallel</code> parameter. The
parameter moreover specifies whether parallelisation takes place within the
optimisation algorithm (<code>inner</code>, default), or in an outer loop ( <code>outer</code>)
over learners, data subsamples, etc.
</p>
<p><code>parallel_hyperparameter_optimisation</code> is ignored if <code>parallel=FALSE</code>.</p>
</dd>
<dt><code>evaluate_top_level_only</code></dt>
<dd>
<p>(<em>optional</em>) Flag that signals that only
evaluation at the most global experiment level is required. Consider a
cross-validation experiment with additional external validation. The global
experiment level consists of data that are used for development, internal
validation and external validation. The next lower experiment level are the
individual cross-validation iterations.
</p>
<p>When the flag is <code>true</code>, evaluations take place on the global level only,
and no results are generated for the next lower experiment levels. In our
example, this means that results from individual cross-validation iterations
are not computed and shown. When the flag is <code>false</code>, results are computed
from both the global layer and the next lower level.
</p>
<p>Setting the flag to <code>true</code> saves computation time.</p>
</dd>
<dt><code>skip_evaluation_elements</code></dt>
<dd>
<p>(<em>optional</em>) Specifies which evaluation steps,
if any, should be skipped as part of the evaluation process. Defaults to
<code>none</code>, which means that all relevant evaluation steps are performed. It can
have one or more of the following values:
</p>

<ul>
<li> <p><code>none</code>, <code>false</code>: no steps are skipped.
</p>
</li>
<li> <p><code>all</code>, <code>true</code>: all steps are skipped.
</p>
</li>
<li> <p><code>auc_data</code>: data for assessing and plotting the area under the receiver
operating characteristic curve are not computed.
</p>
</li>
<li> <p><code>calibration_data</code>: data for assessing and plotting model calibration are
not computed.
</p>
</li>
<li> <p><code>calibration_info</code>: data required to assess calibration, such as baseline
survival curves, are not collected. These data will still be present in the
models.
</p>
</li>
<li> <p><code>confusion_matrix</code>: data for assessing and plotting a confusion matrix are
not collected.
</p>
</li>
<li> <p><code>decision_curve_analyis</code>: data for performing a decision curve analysis
are not computed.
</p>
</li>
<li> <p><code>feature_expressions</code>: data for assessing and plotting sample clustering
are not computed.
</p>
</li>
<li> <p><code>feature_similarity</code>: data for assessing and plotting feature clusters are
not computed.
</p>
</li>
<li> <p><code>fs_vimp</code>: data for assessing and plotting feature selection-based
variable importance are not collected.
</p>
</li>
<li> <p><code>hyperparameters</code>: data for assessing model hyperparameters are not
collected. These data will still be present in the models.
</p>
</li>
<li> <p><code>ice_data</code>: data for individual conditional expectation and partial
dependence plots are not created.
</p>
</li>
<li> <p><code>model_performance</code>: data for assessing and visualising model performance
are not created.
</p>
</li>
<li> <p><code>model_vimp</code>: data for assessing and plotting model-based variable
importance are not collected.
</p>
</li>
<li> <p><code>permutation_vimp</code>: data for assessing and plotting model-agnostic
permutation variable importance are not computed.
</p>
</li>
<li> <p><code>prediction_data</code>: predictions for each sample are not made and exported.
</p>
</li>
<li> <p><code>risk_stratification_data</code>: data for assessing and plotting Kaplan-Meier
survival curves are not collected.
</p>
</li>
<li> <p><code>risk_stratification_info</code>: data for assessing stratification into risk
groups are not computed.
</p>
</li>
<li> <p><code>univariate_analysis</code>: data for assessing and plotting univariate feature
importance are not computed.
</p>
</li>
</ul>
</dd>
<dt><code>ensemble_method</code></dt>
<dd>
<p>(<em>optional</em>) Method for ensembling predictions from
models for the same sample. Available methods are:
</p>

<ul>
<li> <p><code>median</code> (default): Use the median of the predicted values as the ensemble
value for a sample.
</p>
</li>
<li> <p><code>mean</code>: Use the mean of the predicted values as the ensemble value for a
sample.
</p>
</li>
</ul>
<p>This parameter is only used if <code>detail_level</code> is <code>ensemble</code>.</p>
</dd>
<dt><code>evaluation_metric</code></dt>
<dd>
<p>(<em>optional</em>) One or more metrics for assessing model
performance. See the vignette on performance metrics for the available
metrics.
</p>
<p>Confidence intervals (or rather credibility intervals) are computed for each
metric during evaluation. This is done using bootstraps, the number of which
depends on the value of <code>confidence_level</code> (Davison and Hinkley, 1997).
</p>
<p>If unset, the metric in the <code>optimisation_metric</code> variable is used.</p>
</dd>
<dt><code>sample_limit</code></dt>
<dd>
<p>(<em>optional</em>) Set the upper limit of the number of samples
that are used during evaluation steps. Cannot be less than 20.
</p>
<p>This setting can be specified per data element by providing a parameter
value in a named list with data elements, e.g.
<code>list("sample_similarity"=100, "permutation_vimp"=1000)</code>.
</p>
<p>This parameter can be set for the following data elements:
<code>sample_similarity</code> and <code>ice_data</code>.</p>
</dd>
<dt><code>detail_level</code></dt>
<dd>
<p>(<em>optional</em>) Sets the level at which results are computed
and aggregated.
</p>

<ul>
<li> <p><code>ensemble</code>: Results are computed at the ensemble level, i.e. over all
models in the ensemble. This means that, for example, bias-corrected
estimates of model performance are assessed by creating (at least) 20
bootstraps and computing the model performance of the ensemble model for
each bootstrap.
</p>
</li>
<li> <p><code>hybrid</code> (default): Results are computed at the level of models in an
ensemble. This means that, for example, bias-corrected estimates of model
performance are directly computed using the models in the ensemble. If there
are at least 20 trained models in the ensemble, performance is computed for
each model, in contrast to <code>ensemble</code> where performance is computed for the
ensemble of models. If there are less than 20 trained models in the
ensemble, bootstraps are created so that at least 20 point estimates can be
made.
</p>
</li>
<li> <p><code>model</code>: Results are computed at the model level. This means that, for
example, bias-corrected estimates of model performance are assessed by
creating (at least) 20 bootstraps and computing the performance of the model
for each bootstrap.
</p>
</li>
</ul>
<p>Note that each level of detail has a different interpretation for bootstrap
confidence intervals. For <code>ensemble</code> and <code>model</code> these are the confidence
intervals for the ensemble and an individual model, respectively. That is,
the confidence interval describes the range where an estimate produced by a
respective ensemble or model trained on a repeat of the experiment may be
found with the probability of the confidence level. For <code>hybrid</code>, it
represents the range where any single model trained on a repeat of the
experiment may be found with the probability of the confidence level. By
definition, confidence intervals obtained using <code>hybrid</code> are at least as
wide as those for <code>ensemble</code>. <code>hybrid</code> offers the correct interpretation if
the goal of the analysis is to assess the result of a single, unspecified,
model.
</p>
<p><code>hybrid</code> is generally computationally less expensive then <code>ensemble</code>, which
in turn is somewhat less expensive than <code>model</code>.
</p>
<p>A non-default <code>detail_level</code> parameter can be specified for separate
evaluation steps by providing a parameter value in a named list with data
elements, e.g. <code>list("auc_data"="ensemble", "model_performance"="hybrid")</code>.
This parameter can be set for the following data elements: <code>auc_data</code>,
<code>decision_curve_analyis</code>, <code>model_performance</code>, <code>permutation_vimp</code>,
<code>ice_data</code>, <code>prediction_data</code> and <code>confusion_matrix</code>.</p>
</dd>
<dt><code>estimation_type</code></dt>
<dd>
<p>(<em>optional</em>) Sets the type of estimation that should be
possible. This has the following options:
</p>

<ul>
<li> <p><code>point</code>: Point estimates.
</p>
</li>
<li> <p><code>bias_correction</code> or <code>bc</code>: Bias-corrected estimates. A bias-corrected
estimate is computed from (at least) 20 point estimates, and <code>familiar</code> may
bootstrap the data to create them.
</p>
</li>
<li> <p><code>bootstrap_confidence_interval</code> or <code>bci</code> (default): Bias-corrected
estimates with bootstrap confidence intervals (Efron and Hastie, 2016). The
number of point estimates required depends on the <code>confidence_level</code>
parameter, and <code>familiar</code> may bootstrap the data to create them.
</p>
</li>
</ul>
<p>As with <code>detail_level</code>, a non-default <code>estimation_type</code> parameter can be
specified for separate evaluation steps by providing a parameter value in a
named list with data elements, e.g. <code>list("auc_data"="bci", "model_performance"="point")</code>. This parameter can be set for the following
data elements: <code>auc_data</code>, <code>decision_curve_analyis</code>, <code>model_performance</code>,
<code>permutation_vimp</code>, <code>ice_data</code>, and <code>prediction_data</code>.</p>
</dd>
<dt><code>aggregate_results</code></dt>
<dd>
<p>(<em>optional</em>) Flag that signifies whether results
should be aggregated during evaluation. If <code>estimation_type</code> is
<code>bias_correction</code> or <code>bc</code>, aggregation leads to a single bias-corrected
estimate. If <code>estimation_type</code> is <code>bootstrap_confidence_interval</code> or <code>bci</code>,
aggregation leads to a single bias-corrected estimate with lower and upper
boundaries of the confidence interval. This has no effect if
<code>estimation_type</code> is <code>point</code>.
</p>
<p>The default value is equal to <code>TRUE</code> except when assessing metrics to assess
model performance, as the default violin plot requires underlying data.
</p>
<p>As with <code>detail_level</code> and <code>estimation_type</code>, a non-default
<code>aggregate_results</code> parameter can be specified for separate evaluation steps
by providing a parameter value in a named list with data elements, e.g.
<code>list("auc_data"=TRUE, , "model_performance"=FALSE)</code>. This parameter exists
for the same elements as <code>estimation_type</code>.</p>
</dd>
<dt><code>confidence_level</code></dt>
<dd>
<p>(<em>optional</em>) Numeric value for the level at which
confidence intervals are determined. In the case bootstraps are used to
determine the confidence intervals bootstrap estimation, <code>familiar</code> uses the
rule of thumb <code class="reqn">n = 20 / ci.level</code> to determine the number of required
bootstraps.
</p>
<p>The default value is <code>0.95</code>.</p>
</dd>
<dt><code>bootstrap_ci_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used to determine bootstrap
confidence intervals (Efron and Hastie, 2016). The following methods are
implemented:
</p>

<ul>
<li> <p><code>percentile</code> (default): Confidence intervals obtained using the percentile
method.
</p>
</li>
<li> <p><code>bc</code>: Bias-corrected confidence intervals.
</p>
</li>
</ul>
<p>Note that the standard method is not implemented because this method is
often not suitable due to non-normal distributions. The bias-corrected and
accelerated (BCa) method is not implemented yet.</p>
</dd>
<dt><code>feature_cluster_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used to perform clustering
of features. The same methods as for the <code>cluster_method</code> configuration
parameter are available: <code>none</code>, <code>hclust</code>, <code>agnes</code>, <code>diana</code> and <code>pam</code>.
</p>
<p>The value for the <code>cluster_method</code> configuration parameter is used by
default. When generating clusters for the purpose of determining mutual
correlation and ordering feature expressions, <code>none</code> is ignored and <code>hclust</code>
is used instead.</p>
</dd>
<dt><code>feature_linkage_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used for agglomerative
clustering with <code>hclust</code> and <code>agnes</code>. Linkage determines how features are
sequentially combined into clusters based on distance. The methods are
shared with the <code>cluster_linkage_method</code> configuration parameter: <code>average</code>,
<code>single</code>, <code>complete</code>, <code>weighted</code>, and <code>ward</code>.
</p>
<p>The value for the <code>cluster_linkage_method</code> configuration parameters is used
by default.</p>
</dd>
<dt><code>feature_cluster_cut_method</code></dt>
<dd>
<p>(<em>optional</em>) Method used to divide features
into separate clusters. The available methods are the same as for the
<code>cluster_cut_method</code> configuration parameter: <code>silhouette</code>, <code>fixed_cut</code> and
<code>dynamic_cut</code>.
</p>
<p><code>silhouette</code> is available for all cluster methods, but <code>fixed_cut</code> only
applies to methods that create hierarchical trees (<code>hclust</code>, <code>agnes</code> and
<code>diana</code>). <code>dynamic_cut</code> requires the <code>dynamicTreeCut</code> package and can only
be used with <code>agnes</code> and <code>hclust</code>.
</p>
<p>The value for the <code>cluster_cut_method</code> configuration parameter is used by
default.</p>
</dd>
<dt><code>feature_similarity_metric</code></dt>
<dd>
<p>(<em>optional</em>) Metric to determine pairwise
similarity between features. Similarity is computed in the same manner as
for clustering, and <code>feature_similarity_metric</code> therefore has the same
options as <code>cluster_similarity_metric</code>: <code>mcfadden_r2</code>, <code>cox_snell_r2</code>,
<code>nagelkerke_r2</code>, <code>mutual_information</code>, <code>spearman</code>, <code>kendall</code> and <code>pearson</code>.
</p>
<p>The value used for the <code>cluster_similarity_metric</code> configuration parameter
is used by default.</p>
</dd>
<dt><code>feature_similarity_threshold</code></dt>
<dd>
<p>(<em>optional</em>) The threshold level for
pair-wise similarity that is required to form feature clusters with the
<code>fixed_cut</code> method. This threshold functions in the same manner as the one
defined using the <code>cluster_similarity_threshold</code> parameter.
</p>
<p>By default, the value for the <code>cluster_similarity_threshold</code> configuration
parameter is used.
</p>
<p>Unlike for <code>cluster_similarity_threshold</code>, more than one value can be
supplied here.</p>
</dd>
<dt><code>sample_cluster_method</code></dt>
<dd>
<p>(<em>optional</em>) The method used to perform
clustering based on distance between samples. These are the same methods as
for the <code>cluster_method</code> configuration parameter: <code>hclust</code>, <code>agnes</code>, <code>diana</code>
and <code>pam</code>.
</p>
<p>The value for the <code>cluster_method</code> configuration parameter is used by
default. When generating clusters for the purpose of ordering samples in
feature expressions, <code>none</code> is ignored and <code>hclust</code> is used instead.</p>
</dd>
<dt><code>sample_linkage_method</code></dt>
<dd>
<p>(<em>optional</em>) The method used for agglomerative
clustering in <code>hclust</code> and <code>agnes</code>. These are the same methods as for the
<code>cluster_linkage_method</code> configuration parameter: <code>average</code>, <code>single</code>,
<code>complete</code>, <code>weighted</code>, and <code>ward</code>.
</p>
<p>The value for the <code>cluster_linkage_method</code> configuration parameters is used
by default.</p>
</dd>
<dt><code>sample_similarity_metric</code></dt>
<dd>
<p>(<em>optional</em>) Metric to determine pairwise
similarity between samples. Similarity is computed in the same manner as for
clustering, but <code>sample_similarity_metric</code> has different options that are
better suited to computing distance between samples instead of between
features. The following metrics are available.
</p>

<ul>
<li> <p><code>gower</code> (default): compute Gower's distance between samples. By default,
Gower's distance is computed based on winsorised data to reduce the effect
of outliers (see below).
</p>
</li>
<li> <p><code>euclidean</code>: compute the Euclidean distance between samples.
</p>
</li>
</ul>
<p>The underlying feature data for numerical features is scaled to the
<code class="reqn">[0,1]</code> range using the feature values across the samples. The
normalisation parameters required can optionally be computed from feature
data with the outer 5% (on both sides) of feature values trimmed or
winsorised. To do so append <code style="white-space: pre;">⁠_trim⁠</code> (trimming) or <code style="white-space: pre;">⁠_winsor⁠</code> (winsorising) to
the metric name. This reduces the effect of outliers somewhat.
</p>
<p>Regardless of metric, all categorical features are handled as for the
Gower's distance: distance is 0 if the values in a pair of samples match,
and 1 if they do not.</p>
</dd>
<dt><code>eval_aggregation_method</code></dt>
<dd>
<p>(<em>optional</em>) Method for aggregating variable
importances for the purpose of evaluation. Variable importances are
determined during feature selection steps and after training the model. Both
types are evaluated, but feature selection variable importance is only
evaluated at run-time.
</p>
<p>See the documentation for the <code>vimp_aggregation_method</code> argument for
information concerning the different methods available.</p>
</dd>
<dt><code>eval_aggregation_rank_threshold</code></dt>
<dd>
<p>(<em>optional</em>) The threshold used to
define the subset of highly important features during evaluation.
</p>
<p>See the documentation for the <code>vimp_aggregation_rank_threshold</code> argument for
more information.</p>
</dd>
<dt><code>eval_icc_type</code></dt>
<dd>
<p>(<em>optional</em>) String indicating the type of intraclass
correlation coefficient (<code>1</code>, <code>2</code> or <code>3</code>) that should be used to compute
robustness for features in repeated measurements during the evaluation of
univariate importance. These types correspond to the types in Shrout and
Fleiss (1979). The default value is <code>1</code>.</p>
</dd>
<dt><code>stratification_method</code></dt>
<dd>
<p>(<em>optional</em>) Method for determining the
stratification threshold for creating survival groups. The actual,
model-dependent, threshold value is obtained from the development data, and
can afterwards be used to perform stratification on validation data.
</p>
<p>The following stratification methods are available:
</p>

<ul>
<li> <p><code>median</code> (default): The median predicted value in the development cohort
is used to stratify the samples into two risk groups. For predicted outcome
values that build a continuous spectrum, the two risk groups in the
development cohort will be roughly equal in size.
</p>
</li>
<li> <p><code>mean</code>: The mean predicted value in the development cohort is used to
stratify the samples into two risk groups.
</p>
</li>
<li> <p><code>mean_trim</code>: As <code>mean</code>, but based on the set of predicted values
where the 5% lowest and 5% highest values are discarded. This reduces the
effect of outliers.
</p>
</li>
<li> <p><code>mean_winsor</code>: As <code>mean</code>, but based on the set of predicted values where
the 5% lowest and 5% highest values are winsorised. This reduces the effect
of outliers.
</p>
</li>
<li> <p><code>fixed</code>: Samples are stratified based on the sample quantiles of the
predicted values. These quantiles are defined using the
<code>stratification_threshold</code> parameter.
</p>
</li>
<li> <p><code>optimised</code>: Use maximally selected rank statistics to determine the
optimal threshold (Lausen and Schumacher, 1992; Hothorn et al., 2003) to
stratify samples into two optimally separated risk groups.
</p>
</li>
</ul>
<p>One or more stratification methods can be selected simultaneously.
</p>
<p>This parameter is only relevant for <code>survival</code> outcomes.</p>
</dd>
<dt><code>stratification_threshold</code></dt>
<dd>
<p>(<em>optional</em>) Numeric value(s) signifying the
sample quantiles for stratification using the <code>fixed</code> method. The number of
risk groups will be the number of values +1.
</p>
<p>The default value is <code>c(1/3, 2/3)</code>, which will yield two thresholds that
divide samples into three equally sized groups. If <code>fixed</code> is not among the
selected stratification methods, this parameter is ignored.
</p>
<p>This parameter is only relevant for <code>survival</code> outcomes.</p>
</dd>
<dt><code>time_max</code></dt>
<dd>
<p>(<em>optional</em>) Time point which is used as the benchmark for
e.g. cumulative risks generated by random forest, or the cutoff for Uno's
concordance index.
</p>
<p>If <code>time_max</code> is not provided, but <code>evaluation_times</code> is, the largest value
of <code>evaluation_times</code> is used. If both are not provided, <code>time_max</code> is set
to the 98th percentile of the distribution of survival times for samples
with an event in the development data set.
</p>
<p>This parameter is only relevant for <code>survival</code> outcomes.</p>
</dd>
<dt><code>evaluation_times</code></dt>
<dd>
<p>(<em>optional</em>) One or more time points that are used for
assessing calibration in survival problems. This is done as expected and
observed survival probabilities depend on time.
</p>
<p>If unset, <code>evaluation_times</code> will be equal to <code>time_max</code>.
</p>
<p>This parameter is only relevant for <code>survival</code> outcomes.</p>
</dd>
<dt><code>dynamic_model_loading</code></dt>
<dd>
<p>(<em>optional</em>) Enables dynamic loading of models
during the evaluation process, if <code>TRUE</code>. Defaults to <code>FALSE</code>. Dynamic
loading of models may reduce the overall memory footprint, at the cost of
increased disk or network IO. Models can only be dynamically loaded if they
are found at an accessible disk or network location. Setting this parameter
to <code>TRUE</code> may help if parallel processing causes out-of-memory issues during
evaluation.</p>
</dd>
<dt><code>parallel_evaluation</code></dt>
<dd>
<p>(<em>optional</em>) Enable parallel processing for
hyperparameter optimisation. Defaults to <code>TRUE</code>. When set to <code>FALSE</code>, this
will disable the use of parallel processing while performing optimisation,
regardless of the settings of the <code>parallel</code> parameter. The parameter
moreover specifies whether parallelisation takes place within the evaluation
process steps (<code>inner</code>, default), or in an outer loop ( <code>outer</code>) over
learners, data subsamples, etc.
</p>
<p><code>parallel_evaluation</code> is ignored if <code>parallel=FALSE</code>.</p>
</dd>
</dl>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Nothing. All output is written to the experiment directory. If the
experiment directory is in a temporary location, a list with all
familiarModel, familiarEnsemble, familiarData and familiarCollection
objects will be returned.
</p>


<h3>References</h3>


<ol>
<li>
<p> Storey, J. D. A direct approach to false discovery rates. J.
R. Stat. Soc. Series B Stat. Methodol. 64, 479–498 (2002).
</p>
</li>
<li>
<p> Shrout, P. E. &amp; Fleiss, J. L. Intraclass correlations: uses in assessing
rater reliability. Psychol. Bull. 86, 420–428 (1979).
</p>
</li>
<li>
<p> Koo, T. K. &amp; Li, M. Y. A guideline of selecting and reporting intraclass
correlation coefficients for reliability research. J. Chiropr. Med. 15,
155–163 (2016).
</p>
</li>
<li>
<p> Yeo, I. &amp; Johnson, R. A. A new family of power transformations to
improve normality or symmetry. Biometrika 87, 954–959 (2000).
</p>
</li>
<li>
<p> Box, G. E. P. &amp; Cox, D. R. An analysis of transformations. J. R. Stat.
Soc. Series B Stat. Methodol. 26, 211–252 (1964).
</p>
</li>
<li>
<p> Raymaekers, J., Rousseeuw,  P. J. Transforming variables to central
normality. Mach Learn. (2021).
</p>
</li>
<li>
<p> Park, M. Y., Hastie, T. &amp; Tibshirani, R. Averaged gene expressions for
regression. Biostatistics 8, 212–227 (2007).
</p>
</li>
<li>
<p> Tolosi, L. &amp; Lengauer, T. Classification with correlated features:
unreliability of feature ranking and solutions. Bioinformatics 27,
1986–1994 (2011).
</p>
</li>
<li>
<p> Johnson, W. E., Li, C. &amp; Rabinovic, A. Adjusting batch effects in
microarray expression data using empirical Bayes methods. Biostatistics 8,
118–127 (2007)
</p>
</li>
<li>
<p> Kaufman, L. &amp; Rousseeuw, P. J. Finding groups in data: an introduction
to cluster analysis. (John Wiley &amp; Sons, 2009).
</p>
</li>
<li>
<p> Muellner, D. fastcluster: fast hierarchical, agglomerative clustering
routines for R and Python. J. Stat. Softw. 53, 1–18 (2013).
</p>
</li>
<li>
<p> Rousseeuw, P. J. Silhouettes: A graphical aid to the interpretation and
validation of cluster analysis. J. Comput. Appl. Math. 20, 53–65 (1987).
</p>
</li>
<li>
<p> Langfelder, P., Zhang, B. &amp; Horvath, S. Defining clusters from a
hierarchical cluster tree: the Dynamic Tree Cut package for R.
Bioinformatics 24, 719–720 (2008).
</p>
</li>
<li>
<p> McFadden, D. Conditional logit analysis of qualitative choice behavior.
in Frontiers in Econometrics (ed. Zarembka, P.) 105–142 (Academic Press,
1974).
</p>
</li>
<li>
<p> Cox, D. R. &amp; Snell, E. J. Analysis of binary data. (Chapman and Hall,
1989).
</p>
</li>
<li>
<p> Nagelkerke, N. J. D. A note on a general definition of the coefficient
of determination. Biometrika 78, 691–692 (1991).
</p>
</li>
<li>
<p> Meinshausen, N. &amp; Buehlmann, P. Stability selection. J. R. Stat. Soc.
Series B Stat. Methodol. 72, 417–473 (2010).
</p>
</li>
<li>
<p> Haury, A.-C., Gestraud, P. &amp; Vert, J.-P. The influence of feature
selection methods on accuracy, stability and interpretability of molecular
signatures. PLoS One 6, e28210 (2011).
</p>
</li>
<li>
<p> Wald, R., Khoshgoftaar, T. M., Dittman, D., Awada, W. &amp; Napolitano,A. An
extensive comparison of feature ranking aggregation techniques in
bioinformatics. in 2012 IEEE 13th International Conference on Information
Reuse Integration (IRI) 377–384 (2012).
</p>
</li>
<li>
<p> Hutter, F., Hoos, H. H. &amp; Leyton-Brown, K. Sequential model-based
optimization for general algorithm configuration. in Learning and
Intelligent Optimization (ed. Coello, C. A. C.) 6683, 507–523 (Springer
Berlin Heidelberg, 2011).
</p>
</li>
<li>
<p> Shahriari, B., Swersky, K., Wang, Z., Adams, R. P. &amp; de Freitas, N.
Taking the Human Out of the Loop: A Review of Bayesian Optimization. Proc.
IEEE 104, 148–175 (2016)
</p>
</li>
<li>
<p> Srinivas, N., Krause, A., Kakade, S. M. &amp; Seeger, M. W.
Information-Theoretic Regret Bounds for Gaussian Process Optimization in
the Bandit Setting. IEEE Trans. Inf. Theory 58, 3250–3265 (2012)
</p>
</li>
<li>
<p> Kaufmann, E., Cappé, O. &amp; Garivier, A. On Bayesian upper confidence
bounds for bandit problems. in Artificial intelligence and statistics
592–600 (2012).
</p>
</li>
<li>
<p> Jamieson, K. &amp; Talwalkar, A. Non-stochastic Best Arm Identification and
Hyperparameter Optimization. in Proceedings of the 19th International
Conference on Artificial Intelligence and Statistics (eds. Gretton, A. &amp;
Robert, C. C.) vol. 51 240–248 (PMLR, 2016).
</p>
</li>
<li>
<p> Gramacy, R. B. laGP: Large-Scale Spatial Modeling via Local Approximate
Gaussian Processes in R. Journal of Statistical Software 72, 1–46 (2016)
</p>
</li>
<li>
<p> Sparapani, R., Spanbauer, C. &amp; McCulloch, R. Nonparametric Machine
Learning and Efficient Computation with Bayesian Additive Regression Trees:
The BART R Package. Journal of Statistical Software 97, 1–66 (2021)
</p>
</li>
<li>
<p> Davison, A. C. &amp; Hinkley, D. V. Bootstrap methods and their application.
(Cambridge University Press, 1997).
</p>
</li>
<li>
<p> Efron, B. &amp; Hastie, T. Computer Age Statistical Inference. (Cambridge
University Press, 2016).
</p>
</li>
<li>
<p> Lausen, B. &amp; Schumacher, M. Maximally Selected Rank Statistics.
Biometrics 48, 73 (1992).
</p>
</li>
<li>
<p> Hothorn, T. &amp; Lausen, B. On the exact distribution of maximally selected
rank statistics. Comput. Stat. Data Anal. 43, 121–137 (2003).
</p>
</li>
</ol>
</div>