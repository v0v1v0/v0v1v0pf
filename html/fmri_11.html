<div class="container">

<table style="width: 100%;"><tr>
<td>fmri.metaPar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Linear Mixed-effects Meta-Analysis model for fMRI data </h2>

<h3>Description</h3>

<p>Group maps are estimated from BOLD effect estimates and their variances previously determined for each subject. The function <code>rma.uni</code> from R package <span class="pkg">metafor</span> is used to fit mixed-effects meta-analytic models at group level. Voxel-wise regression analysis is accelerated by optional parallel processing using R package <span class="pkg">parallel</span>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fmri.metaPar(Cbold, Vbold, XG = NULL, model = NULL, method = "REML",
             weighted = TRUE, knha = FALSE, mask = NULL, cluster = 2,
             wghts = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Cbold</code></td>
<td>
<p> a 4D-Array with the aggregated individual BOLD contrast estimates in standard space, e.g. all <code>cbeta</code> maps obtained from single-session analysis with <code>fmri.lm</code> may put together. Dimensions 1 to 3 define the voxel space, dimension 4 indicates a subject. If not the whole brain but a region is analyzed, vectors with region-indices can be preserved by adding as attributes (e.g. <code>attr(Cbold, "xind") &lt;- xind</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Vbold</code></td>
<td>
<p> a 4D-Array with the aggregated variance estimates for the contrast parameters in <code>Cbold</code>, e.g. all <code>var</code> maps obtained from single-session analysis with <code>fmri.lm</code> may put together. Dimensions 1 to 3 define the voxel space, dimension 4 indicates a subject.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XG</code></td>
<td>
<p> optionally, a group-level design matrix of class <code>"data.frame"</code> to include one or more moderators in the model. By default, an intercept is added to the model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p> optionally, a one-sided formula of the form: <code>model &lt;- ~ mod1 + mod2 + mod3</code> describing a model with moderator variables. Adding <code>"-1"</code> removes the intercept term.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p> a character string specifying whether a fixed- (method = "FE") or a random/mixed-effects model (method = "REML", default) should be fitted. Further estimators for random/mixed-effects models are available, see documentation of <code>rma.uni</code> function for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p> logical indicating whether weighted (<code>weighted = TRUE</code>, default) or unweighted estimation should be used to fit the model.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knha</code></td>
<td>
<p> logical specifying whether the method by Knapp and Hartung (2003) should be used for adjusting standard errors of the estimated coefficients (default is FALSE). The Knapp and Hartung adjustment is only meant to be used in the context of random- or mixed-effects models.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
<p> if available, a logical 3D-Array of dimensionality of the data (without 4th subject component) describing a brain mask. The computation is restricted to the selected voxels.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p> number of threads for parallel processing, which is limited to available multi-core CPUs. If you do not know your CPUs, try: <code>detectCores()</code> from <span class="pkg">parallel</span> package. Presets are 2 threads. <code>cluster = 1</code> does not use <span class="pkg">parallel</span> package.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wghts</code></td>
<td>
<p> a vector of length 3 specifying ratio of voxel dimensions. Isotropic voxels (e.g. MNI-space) are set as default.
</p>
</td>
</tr>
</table>
<h3>Details</h3>


<p><code>fmri.metaPar()</code> fits the configured linear mixed-effects meta-analytic (MEMA) model separately at each voxel and extracts the first regression coefficient (usually the overall group mean), corresponding squared standard errors and degrees of freedom as well as the residuals from resulting <code>rma.uni</code> objects, to obtain a statistical parametric map (SPM) for the group. Voxel-by-voxel analysis is performed by either the function <code>apply</code> or <code>parApply</code> from <span class="pkg">parallel</span> package, which walks through the <code>Cbold</code> array.
</p>
<p>This two-stage approach reduces the computational burden of fitting a full linear mixed-effects (LME) model, <code>fmri.lmePar</code> would do. It assumes first level design is same across subjects and normally distributed not necessarily homogeneous within-subject errors. Warping to standard space has been done before first-stage analyses are carried out. Either no masking or a uniform brain mask should be applied at individual subject analysis level, to avoid loss of information at group level along the edges.
</p>
<p>At the second stage, observed individual BOLD effects from each study are combined in a meta-analytic model. There is the opportunity of weighting the fMRI studies by the precision of their respective effect estimate to take account of first level residual heterogeneity (<code>weighted = TRUE</code>). This is how to deal with intra-subject variability. The REML estimate of cross-subject variability (tau-squared) assumes that each of these observations is drawn independently from the same Gaussian distribution. Since correlation structures cannot be modeled, multi-subject fMRI studies with repeated measures cannot be analyzed in this way.
</p>
<p>Spatial correlation among voxels, e.g. through the activation of nearby voxels, is ignored at this stage, but corrects for it, when random field theory define a threshold for significant activation at inference stage.
</p>
<p>It is recommended to check your model syntax and residuals choosing some distinct voxels before running the model in loop (see Example). Error handling default is to stop if one of the threads produces an error. When this occurs, the output will be lost from any voxel, where the model has fitted successfully.
</p>


<h3>Value</h3>

<p>An object of class <code>"fmrispm"</code> and <code>"fmridata"</code>, basically a list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>estimated regression coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>estimated standard errors of the coefficients</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cbeta</code></td>
<td>
<p>estimated BOLD contrast parameters for the group. Always the first regression coefficient is taken.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>estimated variance of the BOLD contrast parameters</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mask</code></td>
<td>
<p>brain mask</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>raw (integer size 2) vector containing residuals of the estimated linear mixed-effects meta-analytic model up to scale factor <code>resscale</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resscale</code></td>
<td>
<p><code>resscale*extractData(object,"residuals")</code> are the residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau2</code></td>
<td>
<p>estimated amount of (residual) heterogeneity. Always 0 when <code>method = "FE"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rxyz</code></td>
<td>
<p>array of smoothness from estimated correlation for each voxel in resel space (for analysis without smoothing).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scorr</code></td>
<td>
<p>array of spatial correlations with maximal lags 5, 5, 3 in x, y and z-direction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>vector of bandwidths (in FWHM) corresponding to the spatial correlation within the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>ratio of voxel dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>dimension of the data cube and residuals</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>degrees of freedom for t-statistics, df = (n-p-1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sessions</code></td>
<td>
<p>number of observations entering the meta-analytic model, n</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coef</code></td>
<td>
<p>number of coefficients in the meta-analytic model (including the intercept, p+1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>estimator used to fit the meta-analytic model. In case of "FE", it is weighted or unweighted least squares.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>estimation with inverse-variance weights</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>knha</code></td>
<td>
<p>Knapp and Hartung adjustment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>meta-analytic regression model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster</code></td>
<td>
<p>number of threads running in parallel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr(*,"design")</code></td>
<td>
<p>group-level design matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>attr(*,"approach")</code></td>
<td>
<p>two-stage estimation method</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Meta analyses tend to be less powerful for neuroimaging studies, because they only have as many degrees of freedom as number of subjects. If the number of subjects is very small, then it may be impossible to estimate the between-subject variance (tau-squared) with any precision. In this case the fixed effect model may be the only viable option. However, there is also the possibility of using a one-stage model, that includes the full time series data from all subjects and simultaneously estimates subject and group levels parameters (see <code>fmri.lmePar</code>). Although this approach is much more computer intensive, it has the advantage of higher degrees of freedom (&gt; 100) at the end.
</p>
<p>Current Limitations<br>
The function cannot handle:
</p>
<ul>
<li>
<p>experimental designs with a within-subject (repeated measures) factor
</p>
</li>
<li>
<p>paired samples with varying tasks, unless the contrast of the two conditions is used as input
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p> Sibylle Dames </p>


<h3>References</h3>

<p>Chen G., Saad Z.S., Nath A.R., Beauchamp M.S., Cox R.W. (2012). FMRI group analysis combining effect estimates and their variances. NeuroImage, 60: 747-765.
</p>
<p>Knapp G. and Hartung J. (2003). Improved tests for a random effects meta-regression with a single covariate. Statistics in Medicine, 22: 2693-2710.
</p>
<p>Viechtbauer W. (2005). Bias and efficiency of meta-analytic variance estimators in the random-effects model. Journal of Educational and Behavioral Statistics, 30: 261-293.
</p>
<p>Viechtbauer W. (2010). Conducting meta-analyses in R with the metafor package. Journal of Statistical Software, 36(3): 1-48
</p>
<p>Viechtbauer W. (2015). <em>metafor: Meta-Analysis Package for R</em> R package version 1.9-7.
</p>


<h3>See Also</h3>

<p><code>rma.uni</code>, <code>fmri.lm</code>, <code>fmri.lmePar</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: ## Generate some fMRI data sets: noise + stimulus
dx &lt;- dy &lt;- dz &lt;- 32
dt &lt;- 107
hrf &lt;- fmri.stimulus(dt, c(18, 48, 78), 15, 2)
stim &lt;- matrix(hrf, nrow= dx*dy*dz, ncol=dt, byrow=TRUE)
mask &lt;- array(FALSE, c(dx, dy, dz))
mask[12:22,12:22,12:22] &lt;- TRUE

ds1 &lt;- list(ttt=writeBin(1.0*rnorm(dx*dy*dz*dt) + as.vector(5*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
ds2 &lt;- list(ttt=writeBin(1.7*rnorm(dx*dy*dz*dt) + as.vector(3*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
ds3 &lt;- list(ttt=writeBin(0.8*rnorm(dx*dy*dz*dt) + as.vector(1*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
ds4 &lt;- list(ttt=writeBin(1.2*rnorm(dx*dy*dz*dt) + as.vector(2*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
class(ds1) &lt;- class(ds2) &lt;- class(ds3) &lt;- class(ds4) &lt;- "fmridata"

## Stage 1: single-session regression analysis
x &lt;- fmri.design(hrf, order=2)
spm.sub01 &lt;- fmri.lm(ds1, x, mask, actype = "smooth", verbose = TRUE)
spm.sub02 &lt;- fmri.lm(ds2, x, mask, actype = "smooth", verbose = TRUE)
spm.sub03 &lt;- fmri.lm(ds3, x, mask, actype = "smooth", verbose = TRUE)
spm.sub04 &lt;- fmri.lm(ds4, x, mask, actype = "smooth", verbose = TRUE)

## Store observed individual BOLD effects and their variance estimates
subj &lt;- 4
Cbold &lt;- array(0, dim = c(dx, dy, dz, subj))
Cbold[,,,1] &lt;- spm.sub01$cbeta
Cbold[,,,2] &lt;- spm.sub02$cbeta
Cbold[,,,3] &lt;- spm.sub03$cbeta
Cbold[,,,4] &lt;- spm.sub04$cbeta

Vbold &lt;- array(0, dim = c(dx, dy, dz, subj))
Vbold[,,,1] &lt;- spm.sub01$var
Vbold[,,,2] &lt;- spm.sub02$var
Vbold[,,,3] &lt;- spm.sub03$var
Vbold[,,,4] &lt;- spm.sub04$var

## Stage 2: Random-effects meta-regression analysis
## a) Check your model
library(metafor)
M1.1 &lt;- rma.uni(Cbold[16,16,16, ],
                Vbold[16,16,16, ],
                method = "REML",
                weighted = TRUE,
                knha = TRUE,
                verbose = TRUE,
                control = list(stepadj=0.5, maxiter=2000, threshold=0.001))

# Control list contains convergence parameters later used
# at whole data cube. Values were adjusted to fMRI data.

summary(M1.1)
forest(M1.1)
qqnorm(M1.1)

## b) Estimate a group map
## without parallelizing
spm.group1a &lt;- fmri.metaPar(Cbold, Vbold, knha = TRUE,
                            mask = mask, cluster = 1)
## same with 4 parallel threads
spm.group1b &lt;- fmri.metaPar(Cbold, Vbold, knha = TRUE,
                            mask = mask, cluster = 4)
## End(Not run)
</code></pre>


</div>