<div class="container">

<table style="width: 100%;"><tr>
<td>future_Map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply a Function to Multiple List or Vector Arguments</h2>

<h3>Description</h3>

<p><code>future_mapply()</code> implements <code>base::mapply()</code> using futures with perfect
replication of results, regardless of future backend used.
Analogously to <code>mapply()</code>, <code>future_mapply()</code> is a multivariate version of
<code>future_sapply()</code>.
It applies <code>FUN</code> to the first elements of each <code style="white-space: pre;">⁠\ldots⁠</code> argument,
the second elements, the third elements, and so on.
Arguments are recycled if necessary.
</p>


<h3>Usage</h3>

<pre><code class="language-R">future_Map(
  f,
  ...,
  future.envir = parent.frame(),
  future.label = "future_Map-%d"
)

future_mapply(
  FUN,
  ...,
  MoreArgs = NULL,
  SIMPLIFY = TRUE,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.stdout = TRUE,
  future.conditions = "condition",
  future.globals = TRUE,
  future.packages = NULL,
  future.seed = FALSE,
  future.scheduling = 1,
  future.chunk.size = NULL,
  future.label = "future_mapply-%d"
)

future_.mapply(FUN, dots, MoreArgs, ..., future.label = "future_.mapply-%d")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>A function of the arity <code class="reqn">k</code> if <code>future_Map()</code> is called with
<code class="reqn">k</code> arguments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.envir</code></td>
<td>
<p>An environment passed as argument <code>envir</code> to
<code>future::future()</code> as-is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.label</code></td>
<td>
<p>If a character string, then each future is assigned
a label <code>sprintf(future.label, chunk_idx)</code>.  If TRUE, then the
same as <code>future.label = "future_lapply-%d"</code>.  If FALSE, no labels
are assigned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUN</code></td>
<td>
<p>A function to apply, found via <code>base::match.fun()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MoreArgs</code></td>
<td>
<p>A list of other arguments to <code>FUN</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SIMPLIFY</code></td>
<td>
<p>A logical or character string; attempt to reduce the
result to a vector, matrix or higher dimensional array; see the simplify
argument of <code>base::sapply()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>USE.NAMES</code></td>
<td>
<p>A logical; use names if the first <code style="white-space: pre;">⁠\ldots⁠</code> argument has
names, or if it is a character vector, use that character vector as the
names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.stdout</code></td>
<td>
<p>If <code>TRUE</code> (default), then the standard output of the
underlying futures is captured, and re-outputted as soon as possible.
If <code>FALSE</code>, any output is silenced (by sinking it to the null device
as it is outputted).
If <code>NA</code> (not recommended), output is <em>not</em> intercepted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.conditions</code></td>
<td>
<p>A character string of conditions classes to be
captured and relayed.  The default is the same as the <code>condition</code>
argument of <code>future::Future()</code>.
To not intercept conditions, use <code>conditions = character(0L)</code>.
Errors are always relayed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.globals</code></td>
<td>
<p>A logical, a character vector, or a named list for
controlling how globals are handled.
For details, see <code>future_lapply()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the R environment evaluating the future.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven), or
a list of <code>max(lengths(list(...)))</code> with pre-generated random seeds.
For details, see <code>future_lapply()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.scheduling</code></td>
<td>
<p>Average number of futures ("chunks") per worker.
If <code>0.0</code>, then a single future is used to process all elements
of <code>X</code>.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures
(if there are enough elements in <code>X</code>).
If <code>Inf</code> or <code>FALSE</code>, then one future per element of
<code>X</code> is used.
Only used if <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>future.chunk.size</code></td>
<td>
<p>The average number of elements per future ("chunk").
If <code>Inf</code>, then all elements are processed in a single future.
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dots</code></td>
<td>
<p>A list of arguments to vectorize over (vectors or lists of
strictly positive length, or all of zero length).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to vectorize over, will be recycled to common
length, or zero if one of them is of length zero.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Note that <code>base::.mapply()</code>, which <code>future_.mapply()</code> is modeled after
is listed as an "internal" function in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> despite being exported.
</p>


<h3>Value</h3>

<p><code>future_Map()</code> is a simple wrapper to <code>future_mapply()</code> which does not
attempt to simplify the result.
See <code>base::Map()</code> for details.
</p>
<p><code>future_mapply()</code> returns a list, or for <code>SIMPLIFY = TRUE</code>, a vector,
array or list.  See <code>base::mapply()</code> for details.
</p>
<p><code>future_.mapply()</code> returns a list. See <code>base::.mapply()</code> for details.
</p>


<h3>Author(s)</h3>

<p>The implementations of <code>future_Map()</code> is adopted from the source code
of the corresponding base <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> function <code>Map()</code>, which is licensed under
GPL (&gt;= 2) with 'The R Core Team' as the copyright holder.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## ---------------------------------------------------------
## mapply()
## ---------------------------------------------------------
y0 &lt;- mapply(rep, 1:4, 4:1)
y1 &lt;- future_mapply(rep, 1:4, 4:1)
stopifnot(identical(y1, y0))

y0 &lt;- mapply(rep, times = 1:4, x = 4:1)
y1 &lt;- future_mapply(rep, times = 1:4, x = 4:1)
stopifnot(identical(y1, y0))

y0 &lt;- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
y1 &lt;- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
stopifnot(identical(y1, y0))

y0 &lt;- mapply(function(x, y) seq_len(x) + y,
             c(a =  1, b = 2, c = 3),  # names from first
             c(A = 10, B = 0, C = -10))
y1 &lt;- future_mapply(function(x, y) seq_len(x) + y,
                    c(a =  1, b = 2, c = 3),  # names from first
                    c(A = 10, B = 0, C = -10))
stopifnot(identical(y1, y0))

word &lt;- function(C, k) paste(rep.int(C, k), collapse = "")
y0 &lt;- mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
y1 &lt;- future_mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
stopifnot(identical(y1, y0))


## ---------------------------------------------------------
## Parallel Random Number Generation
## ---------------------------------------------------------

## Regardless of the future plan, the number of workers, and
## where they are, the random numbers produced are identical

plan(multisession)
set.seed(0xBEEF)
y1 &lt;- future_mapply(stats::runif, n = 1:4, max = 2:5,
                    MoreArgs = list(min = 1), future.seed = TRUE)
print(y1)

plan(sequential)
set.seed(0xBEEF)
y2 &lt;- future_mapply(stats::runif, n = 1:4, max = 2:5,
                    MoreArgs = list(min = 1), future.seed = TRUE)
print(y2)

stopifnot(all.equal(y1, y2))



</code></pre>


</div>