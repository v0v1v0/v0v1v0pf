<div class="container">

<table style="width: 100%;"><tr>
<td>fm_rcdt_2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Refined Constrained Delaunay Triangulation</h2>

<h3>Description</h3>

<p>Computes a refined constrained Delaunay triangulation on R2 or S2.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fm_rcdt_2d(...)

fm_rcdt_2d_inla(
  loc = NULL,
  tv = NULL,
  boundary = NULL,
  interior = NULL,
  extend = (missing(tv) || is.null(tv)),
  refine = FALSE,
  lattice = NULL,
  globe = NULL,
  cutoff = 1e-12,
  quality.spec = NULL,
  crs = NULL,
  ...
)

fm_delaunay_2d(loc, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Currently passed on to <code>fm_mesh_2d_inla</code> or converted to
<code>fmesher_rcdt()</code> options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>Input coordinates that should be part of the mesh. Can be a matrix, <code>sf</code>, <code>sfc</code>, <code>SpatialPoints</code>,
or other object supported by <code>fm_unify_coords()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tv</code></td>
<td>
<p>Initial triangulation, as a N-by-3 index vector into <code>loc</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boundary, interior</code></td>
<td>
<p>Objects supported by <code>fm_as_segm()</code>.
If <code>boundary</code> is <code>numeric</code>, <code>fm_nonconvex_hull(loc, convex = boundary)</code> is
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extend</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to extend the
data region, with parameters </p>
 <dl>
<dt>list("n")</dt>
<dd>
<p>the number of edges
in the extended boundary (default=16)</p>
</dd> <dt>list("offset")</dt>
<dd>
<p>the extension
distance.  If negative, interpreted as a factor relative to the approximate
data diameter (default=-0.10)</p>
</dd> </dl>
<p> Setting to <code>FALSE</code> is only useful in
combination <code>lattice</code> or <code>boundary</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>refine</code></td>
<td>
<p><code>logical</code> or <code>list</code> specifying whether to refine the
triangulation, with parameters </p>
 <dl>
<dt>list("min.angle")</dt>
<dd>
<p>the
minimum allowed interior angle in any triangle.  The algorithm is guaranteed
to converge for <code>min.angle</code> at most 21 (default=<code>21</code>)</p>
</dd>
<dt>list("max.edge")</dt>
<dd>
<p>the maximum allowed edge length in any triangle.  If
negative, interpreted as a relative factor in an ad hoc formula depending on
the data density (default=<code>Inf</code>)</p>
</dd> <dt>list("max.n.strict")</dt>
<dd>
<p>the
maximum number of vertices allowed, overriding <code>min.angle</code> and
<code>max.edge</code> (default=-1, meaning no limit)</p>
</dd> <dt>list("max.n")</dt>
<dd>
<p>the
maximum number of vertices allowed, overriding <code>max.edge</code> only
(default=-1, meaning no limit)</p>
</dd> </dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lattice</code></td>
<td>
<p>An <code>fm_lattice_2d</code> object, generated by
<code>fm_lattice_2d()</code>, specifying points on a regular lattice.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>globe</code></td>
<td>
<p>If non-NULL, an integer specifying the level of subdivision
for global mesh points, used with <code>fmesher_globe_points()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>The minimum allowed distance between points.  Point at most as
far apart as this are replaced by a single vertex prior to the mesh
refinement step.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quality.spec</code></td>
<td>
<p>List of vectors of per vertex <code>max.edge</code> target
specification for each location in <code>loc</code>, <code>boundary/interior</code>
(<code>segm</code>), and <code>lattice</code>.  Only used if refining the mesh.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>crs</code></td>
<td>
<p>Optional crs object</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An <code>fm_mesh_2d</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fm_rcdt_2d_inla()</code>: Legacy method for the <code>INLA::inla.mesh.create()</code>
interface
</p>
</li>
<li> <p><code>fm_delaunay_2d()</code>: Construct a plain Delaunay triangulation.
</p>
</li>
</ul>
<h3>INLA compatibility</h3>

<p>For mesh and curve creation, the <code>fm_rcdt_2d_inla()</code>, <code>fm_mesh_2d_inla()</code>,
and <code>fm_nonconvex_hull_inla()</code> methods will keep the interface syntax used by
<code>INLA::inla.mesh.create()</code>, <code>INLA::inla.mesh.2d()</code>, and
<code>INLA::inla.nonconvex.hull()</code> functions, respectively, whereas the
<code>fm_rcdt_2d()</code>, <code>fm_mesh_2d()</code>, and <code>fm_nonconvex_hull()</code> interfaces may be
different, and potentially change in the future.
</p>


<h3>Examples</h3>

<pre><code class="language-R">(m &lt;- fm_rcdt_2d_inla(
  boundary = fm_nonconvex_hull(cbind(0, 0), convex = 5)
))

fm_delaunay_2d(matrix(rnorm(30), 15, 2))

</code></pre>


</div>