<div class="container">

<table style="width: 100%;"><tr>
<td>eval.basis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Values of Basis Functions or their Derivatives
</h2>

<h3>Description</h3>

<p>A set of basis functions are evaluated at a vector of argument values.
If a linear differential object is provided, the  values are the
result of applying the the operator to each basis function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">eval.basis(evalarg, basisobj, Lfdobj=0, returnMatrix=FALSE)
## S3 method for class 'basisfd'
predict(object, newdata=NULL, Lfdobj=0,
                          returnMatrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>evalarg, newdata</code></td>
<td>

<p>a vector of argument values at which the basis functiona is to be
evaluated.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basisobj</code></td>
<td>

<p>a basis object defining basis functions whose values
are to be computed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential.
operator object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>

<p>an object of class <code>basisfd</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>optional arguments for <code>predict</code>, not currently used
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a linear differential operator object is supplied, the basis must
be such that the highest order derivative can be computed. If a
B-spline basis is used, for example, its order must be one larger than
the highest order of derivative required.
</p>


<h3>Value</h3>

<p>a matrix of basis function values with rows corresponding
to argument values and columns to basis functions.
</p>
<p><code>predict.basisfd</code> is a convenience wrapper for
<code>eval.basis</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code>getbasismatrix</code>,
<code>eval.fd</code>,
<code>plot.basisfd</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">##
## 1.  B-splines
##
# The simplest basis currently available:
# a single step function
bspl1.1 &lt;- create.bspline.basis(norder=1, breaks=0:1)
eval.bspl1.1 &lt;- eval.basis(seq(0, 1, .2), bspl1.1)

# check
eval.bspl1.1. &lt;- matrix(rep(1, 6), 6,
       dimnames=list(NULL, 'bspl') )

all.equal(eval.bspl1.1, eval.bspl1.1.)


# The second simplest basis:
# 2 step functions, [0, .5], [.5, 1]
bspl1.2 &lt;- create.bspline.basis(norder=1, breaks=c(0,.5, 1))
eval.bspl1.2 &lt;- eval.basis(seq(0, 1, .2), bspl1.2)

# Second order B-splines (degree 1:  linear splines)
bspl2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))
eval.bspl2.3 &lt;- eval.basis(seq(0, 1, .1), bspl2.3)
# 3 bases:  order 2 = degree 1 = linear
# (1) line from (0,1) down to (0.5, 0), 0 after
# (2) line from (0,0) up to (0.5, 1), then down to (1,0)
# (3) 0 to (0.5, 0) then up to (1,1).

##
## 2.  Fourier
##
# The false Fourier series with 1 basis function
falseFourierBasis &lt;- create.fourier.basis(nbasis=1)
eval.fFB &lt;- eval.basis(seq(0, 1, .2), falseFourierBasis)

# Simplest real Fourier basis with 3 basis functions
fourier3 &lt;- create.fourier.basis()
eval.fourier3 &lt;- eval.basis(seq(0, 1, .2), fourier3)

# 3 basis functions on [0, 365]
fourier3.365 &lt;- create.fourier.basis(c(0, 365))
eval.F3.365 &lt;- eval.basis(day.5, fourier3.365)
oldpar &lt;- par(no.readonly=TRUE)
matplot(eval.F3.365, type="l")

# The next simplest Fourier basis (5  basis functions)
fourier5 &lt;- create.fourier.basis(nbasis=5)
eval.F5 &lt;- eval.basis(seq(0, 1, .1), fourier5)
matplot(eval.F5, type="l")

# A more complicated example
dayrng &lt;- c(0, 365)

nbasis &lt;- 51
norder &lt;- 6

weatherBasis &lt;- create.fourier.basis(dayrng, nbasis)
basisMat &lt;- eval.basis(day.5, weatherBasis)

matplot(basisMat[, 1:5], type="l")

##
## 3.  predict.basisfd
##
basisMat. &lt;- predict(weatherBasis, day.5)

all.equal(basisMat, basisMat.)


##
## 4.  Date and POSIXct
##
# Date
July4.1776 &lt;- as.Date('1776-07-04')
Apr30.1789 &lt;- as.Date('1789-04-30')
AmRev &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)
AmRevYears &lt;- seq(July4.1776, Apr30.1789, length.out=14)
AmRevBases &lt;- predict(BspRevolution, AmRevYears)
matplot(AmRevYears, AmRevBases, type='b')
# Image is correct, but
# matplot does not recogize the Date class of x

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev.ct &lt;- create.bspline.basis(AmRev.ct)
AmRevYrs.ct &lt;- seq(AmRev.ct[1], AmRev.ct[2], length.out=14)
AmRevBas.ct &lt;- predict(BspRev.ct, AmRevYrs.ct)
matplot(AmRevYrs.ct, AmRevBas.ct, type='b')
# Image is correct, but
# matplot does not recognize the POSIXct class of x
par(oldpar)
</code></pre>


</div>