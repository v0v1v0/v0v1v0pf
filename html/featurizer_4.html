<div class="container">

<table style="width: 100%;"><tr>
<td>par_sapply</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A friendlier parSapply.</h2>

<h3>Description</h3>

<p>A sleek wrapper on the function parSapply. This function does not require user to allocate clusters and then stop them. This function uses parSapply across half the available cores and after the computation is done, it stops the clusters as well. The inputs are same os parSapply from parallel package
</p>


<h3>Usage</h3>

<pre><code class="language-R">par_sapply(X, FUNC, detect_cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>The vector of value to perform paralleized sapply on.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>FUNC</code></td>
<td>
<p>Function to be applied to every value of X, similar to sapply</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detect_cores</code></td>
<td>
<p>If False (default), 2 cores are used. If True, half the number of cores are used on Mac OS else 2 cores are used.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The a vector just like sapply. It does applies the function on X in parallel and hence is very fast.
</p>


<h3>Examples</h3>

<pre><code class="language-R">par_sapply(1:100, function(x) x*100)
</code></pre>


</div>