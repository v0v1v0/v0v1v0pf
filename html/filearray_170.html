<div class="container">

<table style="width: 100%;"><tr>
<td>mapreduce</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A map-reduce method to iterate blocks of file-array data with little memory usage</h2>

<h3>Description</h3>

<p>A map-reduce method to iterate blocks of file-array data with little memory usage
</p>


<h3>Usage</h3>

<pre><code class="language-R">mapreduce(x, map, reduce, ...)

## S4 method for signature 'FileArray,ANY,function'
mapreduce(x, map, reduce, buffer_size = NA, ...)

## S4 method for signature 'FileArray,ANY,NULL'
mapreduce(x, map, reduce, buffer_size = NA, ...)

## S4 method for signature 'FileArray,ANY,missing'
mapreduce(x, map, reduce, buffer_size = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a file array object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>mapping function that receives 3 arguments; see 'Details'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduce</code></td>
<td>
<p><code>NULL</code>, or a function that takes a list as input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>passed to other methods</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>buffer_size</code></td>
<td>
<p>control how we split the array; see 'Details'</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>When handling out-of-memory arrays, it is recommended to load
a block of array at a time and execute on block level. See 
<code>apply</code> for a implementation. When an array is too large,
and when there are too many blocks, this operation will become 
very slow if computer memory is low. 
This is because the R will perform garbage collection frequently. 
Implemented in <code>C++</code>, <code>mapreduce</code> creates a buffer to store
the block data. By reusing the memory over and over again, it is possible
to iterate through the array with minimal garbage collections. Many 
statistics, including <code>min</code>, <code>max</code>, <code>sum</code>, 
<code>mean</code>, ... These statistics can be calculated in this 
way efficiently.
</p>
<p>The function <code>map</code> contains three arguments: <code>data</code> (mandate), 
<code>size</code> (optional), and <code>first_index</code> (optional). 
The <code>data</code> is the buffer,
whose length is consistent across iterations. <code>size</code> indicates
the effective size of the buffer. If the partition size
is not divisible by the buffer size, only first <code>size</code> elements of
the data are from array, and the rest elements will be <code>NA</code>. 
This situation could only occurs when <code>buffer_size</code> is manually 
specified. By default, all of <code>data</code> should belong to arrays.
The last argument <code>first_index</code> is the index of the first element
<code>data[1]</code> in the whole array. It is useful when positional data 
is needed. 
</p>
<p>The buffer size, specified by <code>buffer_size</code> is an 
additional optional argument in <code>...</code>. Its default is <code>NA</code>,
and will be calculated automatically. If manually specified, a
large buffer size would be desired to speed up the calculation.
The default buffer size will not exceed <code class="reqn">nThreads x 2MB</code>, where 
<code>nThreads</code> is the number of threads set by <code>filearray_threads</code>.
When partition length cannot be divided by the buffer size, instead of
trimming the buffer, <code>NA</code>s will be filled to the buffer, 
passed to <code>map</code> function; see previous paragraph for treatments.
</p>
<p>The function <code>mapreduce</code> ignores the missing partitions. That means
if a partition is missing, its data will not be read nor passed to 
<code>map</code> function. Please run <code>x$initialize_partition()</code> to make sure
partition files exist.
</p>


<h3>Value</h3>

<p>If <code>reduce</code> is <code>NULL</code>, return mapped results, otherwise
return reduced results from <code>reduce</code> function
</p>


<h3>Examples</h3>

<pre><code class="language-R">

x &lt;- filearray_create(tempfile(), c(100, 100, 10))
x[] &lt;- rnorm(1e5)

## calculate summation
# identical to sum(x[]), but is more feasible in large cases

mapreduce(x, map = function(data, size){
    # make sure `data` is all from array
    if(length(data) != size){
        data &lt;- data[1:size]
    }
    sum(data)
}, reduce = function(mapped_list){
    do.call(sum, mapped_list)
})


## Find elements are less than -3
positions &lt;- mapreduce(
    x,
    map = function(data, size, first_index) {
        if (length(data) != size) {
            data &lt;- data[1:size]
        }
        which(data &lt; -3) + (first_index - 1)
    },
    reduce = function(mapped_list) {
        do.call(c, mapped_list)
    }
)

if(length(positions)){
    x[[positions[1]]]
}


</code></pre>


</div>